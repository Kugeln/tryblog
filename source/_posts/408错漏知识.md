---
title: 408错漏知识
date: 2025-07-10 16:42:19
tags: 408日常
sticky: 339
categories: 408
banner_img: /img/1920x1080 (34).jpg
index_img: /img/1920x1080 (34).jpg
math: true
---

## DS（数据结构）

### 时间复杂度

![](/img/7750ecde-42cf-41d4-b421-33ad22b9a430.png)

### 外部排序

* I/O次数的计算：初始归并段生成的I/O次数+归并时的I/O次数
  * 初始归并段生成的I/O次数=磁盘块数*2（读写各I/O一次）
  * 归并时的I/O次数=磁盘块数* 2 *归并趟数
* 败者树中非叶子节点存储的是失败者的标记（归并段下标），而叶子节点存储的是各个路当前记录的索引值
* 败者树的空间复杂度是O(n)，时间复杂度是O(nlogn)
* 败者树为k路归并段内部排序所使用的，用于提高内部排序效率，与I/O次数无关

### 链表

#### 单链表

* 单链表中删除一个节点有两种方法
  * 1、将该点直接删除，让该点的上一个节点直接指向该点的下一个节点
  * 2、将该点变成该点的下一个点

#### 静态链表

* 静态链表删除或插入不需要移动元素

* 静态链表的存储空间虽然是顺序分配的，但元素的存储不是顺序的，查找时仍然要按照链依次进行，而插入、删除都不需要移动元素。静态链表的存储空间是一次性申请的，能容纳的最大元素个数在定义时就已经确定。由于并非每个空间都存储了元素，因此会导致存储空间的浪费

* 数组一旦确定，数据元素的容量和位置关系就是固定的，因此不能进行插入和删除等操作

* 稀疏矩阵压缩存储后，不能直接根据元素所在数组中的位置在内存中定址，也就意味着失去了随机存取的功能

* 广义表：

  ![](/img/21623.jpg)

  ![](/img/221639.jpg)

  ![](/img/221651.jpg)

### 串

#### kmp算法小总结

* 代码

```c++
//完整
#include<iostream>
using namespace std;
const int N =10010,M=100010;
int n ,m;
char p[N],s[M];
int ne[N];

int main(){
	
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n>>p+1>>m>>s+1;
	//求next数组的过程
	for(int i = 2,j=0;i<=n;i++){
		while(j&&p[i]!=p[j+1]) j = ne[j];
		if(p[i]==p[j+1])j++;
		ne[i] = j;//注意，此处的ne数组已经是优化过的ne数组
	}
	
	
	 
	//kmp匹配过程
	for(int i = 1,j=0;i<=m;i++) //i枚举Si ，j和Si匹配的是P(j+1) ,总往前错一位 
	{
		while(j&&s[i]!=p[j+1])//j没有退回起点，退回起点意味着要重新开始匹配 ;不等意味着那个位置不匹配了 
	    	j = ne[j];//ne[j]是当前j点的最长后缀的长度，j是不匹配后往后移动更新的检验分界点。由于j从0开始，所以当j等于上一个j的ne长度时，相当于j被更新到图示位置 
	    if(s[i]==p[j+1]) j++;//下一个字符终于匹配，继续检验下一个位置的字符是否匹配 
		if(j==n) {
			//匹配成功 
			cout<<i-n<<" ";//输出子串的位置
			j=ne[j];
		}
	}
	
	
} 
```

* next数组手算过程：

  * **next[1]都无脑写0，next[2]都无脑写1**
  * 其他next
  * next数组采用求匹配失败的元素的左边起子串的前缀后缀相同的下一个位置

  ![](/img/05205.jpg)

* nextval数组手算过程

  * 先求next数组
  * nextval数组j=1的位置无脑写0，然后后面的进行回溯，如果回溯到不一样的就保持不变，一样的就继续回溯

## CO（计组）

### 数据的表示和运算

* 原码一位乘共进行n次加法和n次逻辑右移
  * 补码booth乘法共进行n+1次加法和n次算术右移
* **补码的本质是取模**，对于补码表示的定点小数，模数是2，对于补码表示的定点小数，模数是2^n+1

### 指令系统

![](/img/15325.jpg)

### 中央处理器

* 所有信号在一个时钟周期内从状态单元1经组合逻辑到达状态单元2，信号到达状态单元2所需的时间决定了时钟周期的长度
  * **时钟周期以相邻状态单元间组合逻辑电路的最大延迟为基准确定**

#### 微程序控制器

* 微程序控制器中，执行指令微程序的首条微指令地址是**指令操作码**译码得到的
* 硬布线控制器又名组合逻辑控制器

#### 时钟信号

![](/img/235438.jpg)

![](/img/35518.jpg)

![](/img/235543.jpg)

![](/img/235604.jpg)

![](/img/235659.jpg)

![](/img/4d658007-85e3-40f2-812c-857e014a5484(1).png)

### 指令流水线

#### 数据冒险

* 旁路转发技术和load-use冒险：

  ![](/img/202405222222529.png)

  * load指令**在第四周期即M访存阶段结束时**，数据在流水段寄存器中已经有值，在此时可以采用数据转发技术可以使load指令后面第二条指令得到所需的指，但不能解决load指令和随后的第一条指令之间的数据冒险，**要延迟执行一条指令**

  ![](/img/202405222232608.png)

  ![](/img/202405222234220.png)

  * **普通数据冒险采用旁路转发技术不需要阻塞，而load-use需要阻塞一个时钟周期的根本原因是所需数据产生的阶段不同，使用ALU计算获得结果（所需数据）的在EX阶段可以产生所需数据，而load指令在M阶段从内存中获取所需数据**
  * load指令中的ID和EX是在获取所需数据的内存地址，M访存获得所需数据

* lw指令：从内存中读取一个字，并将其放在一个寄存器中

  sw指令：将一个寄存器中的字写入内存中

### 总线

* 采用数据/地址总线复用技术，总线中保留数据线，地址经过数据线传输

### 中断和异常

![](/img/211409.jpg)

* 概念厘清
  * 中断向量
    * **中断处理程序的入口地址（首地址）**
  * 中断类型号
    * **标识终端类型的编号**
  * 中断向量地址
    * **保存中断向量的内存地址，在中断响应阶段由中断向量地址形成部件（硬件）生成**
  * 中断优先级
    * 中断响应优先级
      * **硬件产生且不可更改**
    * 中断处理优先级
      * 由排队器、中断屏蔽字等硬件决定
  * 中断向量表
    * 记录了**中断编号和中断向量的对应关系**

## OS（操作系统）

### 操作系统概述

#### 进程的状态

* 挂起态通常是由于终端用户请求、父进程请求、系统负荷调节或者操作系统自身需要等原因，将进程置于静止状态

### 进程和线程

#### 互斥

* 自旋锁具有随机性，不能保证按先来后到的顺序使用cpu资源

  * 自旋锁：当进程申请锁之败后，会已知循环申请锁直到成功

  ![](/img/165446.jpg)

* 创建共享内存需要通过系统调用实现，需要先进入内核态，内核在物理内存中分配一块连续区域，指定共享内存的访问权限（如读写权限）和大小，然后进程再通过系统调用将共享内存映射到自己的虚拟地址空间。

#### 进程调度

![](/img/Cache_-248a4a6132183be9(1).png)

#### 死锁

![](/img/17d9245c-7f19-42a5-aa82-126fdcacd4ce(1).png)

### I/O

* ![](/img/3b4b4b7b-1d7e-4d06-b711-746bfcb3b128.png)

  ![](/img/be1df64f-5f9c-4787-81ad-6895df8c797e.png)

* 统一编址方式下，I/O地址是存储地址的一部分，可以直接用访存指令访问I/O设备，区分存储单元和I/O设备是依靠它们的地址码

* 独立编址方式下，需要用专门的I/O指令来访问I/O设备，区分存储单元和I/O设备是依靠指令类型

* **唤醒**因为I/O操作被阻塞的进程由**中断服务程序**完成。

  * **阻塞**I/O操作进程由对应的**系统调用服务例程**完成
  * 将数据**从设备控制器的寄存器送往内核缓冲区**由**中断服务程序**完成
  * 将数据**从内核缓冲区送往用户缓冲区**由**系统调用服务程序**在唤醒后完成
  * **初始化外设**的代码在**驱动程序**中

  ![](/img/15013.jpg)

* DMA进行数据传送之前，CPU先执行一段初始化程序，完成对DMA控制器中各参数寄存器的初始值的设定，因此**通过软件完成对DMA控制器中各参数寄存器的初始值的设定**

* 发生缺页中断时，若在缺页处理程序中将缺页调入内存采用DMA方式，则需要把磁盘物理地址写入DMA控制器中的设备地址寄存器DAR，将交换数据的主存起始位置（该页面的页基址）写入DMA接口中的主存地址寄存器

* 程序直接控制I/O方式包含无条件传送和条件传送，无条件传送较为简单，无状态等交互信息，只需定时查询即可，适合于巡回检测采样系统或过程控制系统，以及非随机启动的字符型设备。

  * 条件传送方式下，接口中含有“就绪”“完成”等状态，可继续分为独占查询和定时查询

### 内存管理

![](/img/md2card-1750735950162-1(1).png)

* 影响系统缺页率的要素

  * 页面置换算法

  * 工作集的大小

    * 工作集的大小决定了分配给进程的物理块数，分配给进程的物理块数越多，缺页率就越低

  * 进程的数量

    * 进程的数量越多，对内存资源的竞争越激烈，每个进程被分配的物理块数越少，缺页率也就越高

  * 页缓冲队列的长度

    * 页缓冲队列

    ![](/img/220631.jpg)

    ![](/img/220700.jpg)

  * 程序的编制方法

    * 编写程序的局部化程度越高，执行时的缺页率就越低，若存储采用的是按行存储，则访问时就要尽量采用相同的访问方式，避免按列访问造成缺页率过高的现象
  
* clock页面淘汰算法，**页面命中时，进改变访问位，不改变页框指针；页面未命中时，从当前页框出发，访问位为1，则改为0，直到找到访问位为0的页框，此后将此页框访问位改1，页指针指向下一个页框**

  * **最开始的页框指针指向第一个被放入的页面**

#### 虚拟存储管理

* 页式存储管理方式的虚拟地址空间维度是一维的

  * 段式存储管理方式的虚拟地址空间是二维的
  * 段页式存储管理方式的虚拟地址空间是二维的

  ![](/img/215613.jpg)

* 页式存储管理中每个进程有一个页表

* 段式存储管理中每个进程都有一个段表

* 段页式存储管理中，每个进程都有一个段表，每个进程的每个段都有一个页表

* **物理地址=基地址+相对地址**

* 页号=物理地址/页大小

#### 内存映射文件

![](/img/221511.jpg)

* 内存映射文件利用了操作系统的请求调页基址。当文件被映射时，并不会立即将其全部内容调入物理内存。只有当进程实际访问到映射区域中的某个特定页面，而该页面尚未在物理内存中时，才会触发缺页中断，操作系统再负责将对应的文件部分从磁盘调入物理内存。这种按需调页的方式使得可以映射远大于可用物理内存的文件

### 文件管理

* inode不包含文件名，文件名存储在目录文件的目录项中，每个目录文件将文件名与inode号关联

![](/img/23115.jpg)

* FAT在文件系统挂载的时候就被全部或大部分读入内存，并常驻内存当中，而不是打开单个文件的时候才去读入
* 空闲链表法分为空闲盘块链和空闲盘区链，空闲盘区链可以把连续的空闲盘块合并成一个区，支持合并
* 在引入索引节点（inode）的文件系统中，目录项通常包含文件名与该文件名对应的索引节点号。目录本身是一个包含这些目录项的文件。索引节点是存储文件元数据（如文件大小、权限、物理位置等）的数据结构，他们通常集中存放在磁盘的特定区域（索引节点区）。因此，目录是文件名到索引节点号的映射集合，而不是索引节点本身的有序集合。
* 超级块通常在磁盘上有多个副本（备份）。主超级块通常位于文件系统的固定位置，而备份超级块则分布在文件系统的其他位置，如果主超级块损坏，系统可以尝试从备份中恢复。

## CN（计网）

### 计算机网络体系结构

* 传输媒体（线）不属于网络体系结构
* 网络层参与拥塞控制
* 无确认无连接服务适用于实时性要求高的场景

### 数据链路层

* 负载均衡：允许多路并行转发数据，最大吞吐量为多路带宽之和
* 信道带宽=信道频率范围上限-信道频率范围下限

#### CSMA/CA

![](/img/b4nw4g.png)

![](/img/32311.jpg)

![](/img/32244.jpg)