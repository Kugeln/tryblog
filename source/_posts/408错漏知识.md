---
title: 408错漏知识
date: 2025-07-10 16:42:19
tags: 408日常
sticky: 339
categories: 408
banner_img: /img/1920x1080 (34).jpg
index_img: /img/1920x1080 (34).jpg
math: true
---

## DS（数据结构）

### 时间复杂度

![](/img/7750ecde-42cf-41d4-b421-33ad22b9a430.png)

### 外部排序

* I/O次数的计算：初始归并段生成的I/O次数+归并时的I/O次数
  * 初始归并段生成的I/O次数=磁盘块数*2（读写各I/O一次）
  * 归并时的I/O次数=磁盘块数* 2 *归并趟数
* 败者树中非叶子节点存储的是失败者的标记（归并段下标），而叶子节点存储的是各个路当前记录的索引值
* 败者树的空间复杂度是O(n)，时间复杂度是O(nlogn)
* 败者树为k路归并段内部排序所使用的，用于提高内部排序效率，与I/O次数无关

![](/img/3125237.jpg)

### 链表

* 从长度为n的顺序表中删除任一各元素，平均时间复杂度是O(n)

#### 单链表

* 单链表中删除一个节点有两种方法
  * 1、将该点直接删除，让该点的上一个节点直接指向该点的下一个节点
  * 2、将该点变成该点的下一个点

#### 静态链表

* 静态链表删除或插入不需要移动元素

* 静态链表的存储空间虽然是顺序分配的，但元素的存储不是顺序的，查找时仍然要按照链依次进行，而插入、删除都不需要移动元素。静态链表的存储空间是一次性申请的，能容纳的最大元素个数在定义时就已经确定。由于并非每个空间都存储了元素，因此会导致存储空间的浪费

* 数组一旦确定，数据元素的容量和位置关系就是固定的，因此不能进行插入和删除等操作

* 稀疏矩阵压缩存储后，不能直接根据元素所在数组中的位置在内存中定址，也就意味着失去了随机存取的功能

* 广义表：

  ![](/img/21623.jpg)

  ![](/img/221639.jpg)

  ![](/img/221651.jpg)

### 栈和队列和数组

* 最适合用作链队的链表就是**带有队首指针和队尾指针的非循环单链表**
* 循环队列的三种判满方式都需要额外的开销，需要牺牲一个队列空间
* 三元组的内容为（行，列，值），其次还要存储稀疏矩阵和行列总数（否则无法分辨矩阵规模）和非零元素个数（三元组表的大小）。交换每个三元组的行列以外，还要交换总行和总列才可以实现转置
* 十字链表法适合频繁插入删除和快速定位行列元素，三元组的存储效率一般低于十字链表

#### 卡特兰数的应用

![](/img/190334.jpg)

![](/img/202106.jpg)

* n个不同元素进栈，出栈元素不同排列的个数N可由卡特兰数确定
* 先序序列为入栈次序，中序序列为出栈序列，因为前序序列和中序序列可以唯一确定一棵二叉树，因此**问先序序列为xxxx的不同二叉树的个数是？相当于问以xxxx为入栈次序，出栈序列的个数是？**
* **进栈出栈操作与二叉树中序遍历的关系**
  * 一个节点进栈后有两种处理方式：
    * 要么立即出栈（此时该入栈结点没有左孩子），要么下一个结点进栈（有左孩子）
  * 一个结点出栈后有两种处理方式
    * 继续出栈（该结点无右孩子）
    * 要么下一个结点进栈（有右孩子）

### 串

* 普通匹配算法的时间复杂度为O(mn)，kmp算法时间复杂度为O(m+n)，如果每次匹配部分匹配都接近模式串长度n，那么普通匹配算法达到最坏时间复杂度O(mn)，相反普通匹配算法和kmp算法接近

#### kmp算法小总结

* 代码

```c++
//完整
#include<iostream>
using namespace std;
const int N =10010,M=100010;
int n ,m;
char p[N],s[M];
int ne[N];

int main(){
	
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n>>p+1>>m>>s+1;
	//求next数组的过程
	for(int i = 2,j=0;i<=n;i++){
		while(j&&p[i]!=p[j+1]) j = ne[j];
		if(p[i]==p[j+1])j++;
		ne[i] = j;//注意，此处的ne数组已经是优化过的ne数组
	}
	
	
	 
	//kmp匹配过程
	for(int i = 1,j=0;i<=m;i++) //i枚举Si ，j和Si匹配的是P(j+1) ,总往前错一位 
	{
		while(j&&s[i]!=p[j+1])//j没有退回起点，退回起点意味着要重新开始匹配 ;不等意味着那个位置不匹配了 
	    	j = ne[j];//ne[j]是当前j点的最长后缀的长度，j是不匹配后往后移动更新的检验分界点。由于j从0开始，所以当j等于上一个j的ne长度时，相当于j被更新到图示位置 
	    if(s[i]==p[j+1]) j++;//下一个字符终于匹配，继续检验下一个位置的字符是否匹配 
		if(j==n) {
			//匹配成功 
			cout<<i-n<<" ";//输出子串的位置
			j=ne[j];
		}
	}
	
	
} 
```

* next数组手算过程：

  * **next[1]都无脑写0，next[2]都无脑写1**
  * 其他next
  * next数组采用求匹配失败的元素的左边起子串的前缀后缀相同的下一个位置

  ![](/img/05205.jpg)

* nextval数组手算过程

  * 先求next数组
  * nextval数组j=1的位置无脑写0，然后后面的进行回溯，如果回溯到不一样的就保持不变，一样的就继续回溯

### 栈

* 上溢是指存储器满，还往里写，下溢是指存储器空，还往外读。

### 树

![](/img/74229.jpg)

* 只要按照前序序列的顺序入栈，那么无论怎么出栈，肯定是符合中序序列的

* 原森林中每一个**分支节点**产生**唯一一个对应二叉树中没有右孩子的结点**，森林中**最右边子树的根节点在二叉树中也没有右孩子**，所以**原森林中分支节点个数+1=二叉树中没有右孩子的结点数量**

* 任一二叉树的叶节点在先序、中序、后序遍历序列中相对位置一定是相同的。
* 要交换二叉树的所有分支节点的左右子树的位置，利用前序或后序遍历框架解决最合适

#### 二叉树的迭代遍历

![](/img/74517.jpg)

![](/img/174531.jpg)

![](/img/174545.jpg)

![](/img/174556.jpg)

![](/img/73936.jpg)

#### 根据遍历序列确定二叉树的形态

![](/img/24507.jpg)

### 图

* 只有在无向图中，DFS的调用次数=连通分量的个数
  * 有向图中因为强连通分量要求互相之间都有去往边，而DFS只保证有从一个顶点向另一个顶点的边，不保证有反向的边

#### 图的顶点和边的关系

![](/img/25140.jpg)

### 查找

#### 平衡二叉树(AVL)

* 平衡二叉树的删除
  * 删除的是叶子节点：直接删除
  * 删除的是只有左子树或者右子树的节点：删除后用子树替代原节点
  * 删除的是有两个孩子的节点：用直接前驱（左子树最右下）或者直接后继（右子树最左下）来替代原节点，然后进行调整
* 平衡二叉树的结点数计算

![](/img/30420.jpg)

#### B树

* B树的删除
  * 叶子节点：直接删除
    * 符合规则无需改动
    * 不满足最低叶子节点：
      * 兄弟够借借兄弟
      * 兄弟不够借，合并兄弟节点和自己以及夹在中间的双亲结点
  * 非叶子节点：删除后用直接前驱或者直接后继替代，相当于在叶子节点删除直接前驱或者直接后继

![](/img/230953.jpg)

![](/img/31007.jpg)

### 排序

* 快速排序的枢轴值将序列划分的越平均排序速度越快
* 快速排序越有序，递归深度越深

## CO（计组）

### 计算机系统概述

#### 冯诺依曼计算机的特点

![](/img/31517.jpg)

![](/img/231538.jpg)

#### 计算机分层系统

![](/img/231635.jpg)

![](/img/31726.jpg)

#### 计算机性能指标

* MIPS=（主频/CPI）/10^6
* 时间=CPI*指令总数/主频
* 影响平均CPI的因素
  * 微体系结构决定硬件执行指令的效率
    * 如流水线、超标量、分支预测等
  * 指令调度策略用于优化指令执行顺序，减少数据依赖或者控制依赖导致的冒险
    * 如编译器静态调度或硬件动态调度
  * 指令系统结构直接决定指令的复杂度和执行效率
    * 如RISC或CISC

### 数据的表示和运算

* 原码一位乘共进行n次加法和n次逻辑右移
  * 补码booth乘法共进行n+1次加法和n次算术右移
* **补码的本质是取模**，对于补码表示的定点小数，模数是2，对于补码表示的定点小数，模数是2^n+1
* 两个短相加变长，会先对两短进行扩展，扩展的时候按照短自己的类型进行扩展（短的是无符号数就0扩展，是有符号数就符号扩展）。

![](/img/214328.jpg)

* 加减法电路

  ![](/img/143336.jpg)

  sub=1，一个作为控制信号传到多路选择器控制取反后的Y进入加法器，而另一个作为cin也就是低位的进位加到加法器

  **最好会画**

#### 浮点数

* 浮点数的舍入

![](/img/32644.jpg)

### 存储系统

#### 主存储器

* 行列地址线复用的情况下，由于DRAM按行刷新，因此行地址位数要小于等于列位地址数，而地址线条数=max（列地址位数，行地址位数）

* **地址线和译码器输出的选择线的关系：n条地址线，译码输出的选择线是2^n条**

* DRAM按行刷新，刷新计数器和行地址一样，送往行译码器再进行行选，所以**刷新计数器即地址线根数=10bit**

* **行缓冲为一行的数据大小=列数*数据位数**

* **多路选择器是一种能够从多个输入信号中选择一个输出的信号转换设备。译码器是一种将二进制编码转换为一组特定输出信号的设备。在寄存器堆中，译码器常常用于地址译码，从而控制对特定寄存器的访问。**

  ![](/img/91810.jpg)

  * **执行寄存器写相关指令时（将结果保存在寄存器中），指令中的寄存器编号被送到一个地址译码器进行译码，选中某个寄存器进行写入，读出时（从寄存器中获得计算数据）寄存器编号作为一个控制信号来控制一个多路选择器，选择相应的寄存器读出。**
  * 读口（组合逻辑操作）：无需时钟控制，busA和busB分别由RA和RB给出地址。地址RA或RB有效后，经一个“取数时间（AccessTime）”，busA和busB有效
  * 写口（时序逻辑操作）：需要时钟控制。写使能为1的情况下，时钟边沿到来时，busW传来的值开始被写入RW指定的寄存器中。
    * 写是需要改变寄存器的值的，需要等到数据的信号稳定后写入，防止出错。而读只需要和寄存器里的值相等就行

* SRAM不地址复用,DRAM地址复用

### Cache

* cache比较器个数

![](/img/215517.jpg)

### 虚拟存储器

* 段式的比较先后：

  * 越界与否→缺失与否→越权与否

  ![](/img/20305.jpg)
  
* **逻辑地址空间的大小受限于CPU的寻址能力（如32位CPU理论上可以寻址4GB，64位CPU则大得多）**，而这些逻辑地址空间中的内容，一部分在物理内存中，大部分则存放在外存（通常是磁盘的交换区或对换区）上。因此，虚拟存储的总容量可以理解为物理内存和可用外存空间之和，但实际上限更多地由CPU寻址范围和外存大小决定

### 指令系统

![](/img/15325.jpg)

* 调用指令第一条指令比须显式给出转移的目标地址，否则无法调用子程序
* **一条指令的处理时间为：取指令时间+执行指令时间+中断周期时间（关中断、保存断点、中断服务程序入口地址送PC），中断周期时间不包括中断服务程序的执行时间**

* 扩展指令码
  * 扩展指令码上层是多地址指令，下层是少地址指令，少地址指令
  * 前缀不能相同

![](/img/010539.jpg)

#### 寻址方式

* 遇到基址寻址计算操作数地址的时候，都可以将基址寄存器的内容和形式地址进行符号扩展以后的结果直接相加

### 中央处理器

* 所有信号在一个时钟周期内从状态单元1经组合逻辑到达状态单元2，信号到达状态单元2所需的时间决定了时钟周期的长度
  * **时钟周期以相邻状态单元间组合逻辑电路的最大延迟为基准确定**
* 若单周期处理器中所有指令的指令周期为一个时钟周期，则可以采用多总线结构的数据通路

#### 微程序控制器

* 微程序控制器中，执行指令微程序的首条微指令地址是**指令操作码**译码得到的
* 硬布线控制器又名组合逻辑控制器
* 取指微程序是每条机器指令公共的微程序，入口地址通常固定（μPC初始置0，即CM中的首条就是取指微程序的首地址，然后执行取指微程序进行取指）
* **取指微程序和机器指令微程序的关系和区别**

![](/img/4932414346.jpg)

![](/img/225011.jpg)

![](/img/25026.jpg)

![](/img/25043.jpg)

![](/img/225053.jpg)

#### 时钟信号

![](/img/235438.jpg)

![](/img/35518.jpg)

![](/img/235543.jpg)

![](/img/235604.jpg)

![](/img/235659.jpg)

![](/img/4d658007-85e3-40f2-812c-857e014a5484(1).png)

### 指令流水线

* 虽然增加流水线级数可能缩短每级延迟，但“必然”提高主频的说法过于绝对。实际中，流水线级数增加会引入额外的寄存器延迟（如建立时间、保持时间），且若各阶段延迟不均衡，最慢阶段仍会限制主频。此外，过深的流水线可能导致控制复杂度上升，反而影响性能。因此，当段数达到一定数量时，流水线技术增加不一定会提高主频了。
* 流水线的时钟周期必须覆盖最慢阶段的延迟（包括组合逻辑延迟和流水线寄存器延迟），否则会导致数据无法正确传递。因此，CPU的最高频率由流水线中最关键路径（即延迟最大的阶段）决定。
* 流水线技术的核心优势在于提高吞吐率（单位时间内完成的指令数），而非减少单条指令的执行时间。由于流水线寄存器延迟的存在，单条指令的总执行时间可能反而略有增加（如从单周期变为多周期）。虽然主频提高可能缩短时钟周期，但单条指令仍需经历多个阶段，其总执行时间并未减少
* 流水线级数的核心思想正是通过指令级并行（ILP）实现多条指令的不同阶段同时执行。

#### 数据冒险

* 旁路转发技术和load-use冒险：

  ![](/img/202405222222529.png)

  * load指令**在第四周期即M访存阶段结束时**，数据在流水段寄存器中已经有值，在此时可以采用数据转发技术可以使load指令后面第二条指令得到所需的指，但不能解决load指令和随后的第一条指令之间的数据冒险，**要延迟执行一条指令**

  ![](/img/202405222232608.png)

  ![](/img/202405222234220.png)

  * **普通数据冒险采用旁路转发技术不需要阻塞，而load-use需要阻塞一个时钟周期的根本原因是所需数据产生的阶段不同，使用ALU计算获得结果（所需数据）的在EX阶段可以产生所需数据，而load指令在M阶段从内存中获取所需数据**
  * load指令中的ID和EX是在获取所需数据的内存地址，M访存获得所需数据

* lw指令：从内存中读取一个字，并将其放在一个寄存器中

  sw指令：将一个寄存器中的字写入内存中

### 总线

* 采用数据/地址总线复用技术，总线中保留数据线，地址经过数据线传输

### 中断和异常

![](/img/211409.jpg)

* 概念厘清
  * 中断向量
    * **中断处理程序的入口地址（首地址）**
  * 中断类型号
    * **标识终端类型的编号**
  * 中断向量地址
    * **保存中断向量的内存地址，在中断响应阶段由中断向量地址形成部件（硬件）生成**
  * 中断优先级
    * 中断响应优先级
      * **硬件产生且不可更改**
    * 中断处理优先级
      * 由排队器、中断屏蔽字等硬件决定
  * 中断向量表
    * 记录了**中断编号和中断向量的对应关系**



## OS（操作系统）

### 操作系统概述

#### 进程的状态

* 挂起态通常是由于终端用户请求、父进程请求、系统负荷调节或者操作系统自身需要等原因，将进程置于静止状态

#### 系统调用

* 从用户态到内核态
  * 执行一条当前CPU不支持的指令
    * 引发“非法指令”异常（内中断）
    * 当CPU检测到无法识别的指令时，会强制从用户态切换到内核态，由操作系统内核处理该异常，因此，这会导致模式切换
  * 地址非法/缺页
  * 执行系统调用
    * 执行系统调用会主动引发陷入（trap），使cpu从用户态切换到内核态
  * 除数为0
    * 引发算数异常（内中断），强制从用户态切换到内核态，由操作系统内核处理该异常

#### 操作系统结构

* ![](/img/201705.jpg)
* 写入内核的驱动程序（静态驱动程序）再启动内核时架子啊，其他的在系统初始化时由内核加载，支持即插即用的设备再插入时加载，不支持即插即用的驱动程序需要手动安装。驱动程序的加载过程中需要申请中断号并且注册中断向量表。

#### 操作系统引导过程

* ①激活CPU。
  按下开机键，电源开始向主板供电，CPU收到一个reset信号，开始复位初始化，读取内存ROM中的BIOS程序（固化在芯片中的程序），将IR设置为BIOS的第一条指令并开始执行（CPU初始化后执行的第一条指令）
  
* ②硬件自检。
  BIOS构建中断向量表，开始POST（通电自检/硬件自检）
  
* ③加载带有操作系统的硬盘。
  硬件自检完成后，BIOS开始读取Boot Sequence，找到启动顺序排在第一位的存储设备，将控制权转交给下一阶段的启动程序，然后CPU将该存储设备引导扇区的内容加载到内存中
  
* ④加载主引导记录（MBR）
  计算机读取该设备的第一个扇区，也就是前512B（主引导记录MBR），如果这512B的最后两个字节是0x55和0xAA，说明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给启动顺序中的下一个设备，如无其他启动设备，就会死机。主引导记录的作用是告诉计算机到硬盘的哪一个位置去找操作系统。
  主引导记录包括①调用操作系统的机器码（找PBR活动分区）②分区表③主引导记录签名
  
* ⑤扫描硬盘分区表，并加载硬盘活动分区。
  MBR包含硬盘分区表，硬盘分区表以特定的标识符区分活动分区和非活动分区（第一个字节如果为0x80，则代表该主分区是激活分区，控制权要转交给这个分区，n个分区中只能有一个是激活的）。主引导记录MBR扫描硬盘分区表，进而识别含有操作系统的硬盘分区（活动分区）。找到硬盘活动分区后，开始加载硬盘活动分区，将控制权交给活动分区。
  
  * MBR 是硬盘的第一个扇区，其大小为 512 字节，通常位于硬盘的最前面。它独立于于任何分区，它是硬盘的“引导区域”，用于存储启动引导信息和硬盘的分区表。
  
* ⑥加载分区引导记录PBR。
  读取活动分区的第一个扇区，这个扇区称为分区引导记录（PBR），其作用是寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）。
  
  * **MBR的机器码**：计算机开机后，CPU 会首先读取硬盘的 MBR。MBR 中的机器码检查分区表，识别活动分区，假设活动分区是分区 1。
    
    **PBR的机器码**：MBR 将控制权交给分区 1 的第一个扇区（即 PBR）。PBR 中的引导程序负责加载操作系统的引导程序（例如，GRUB 或 Windows 启动管理器）。
    
    **操作系统引导程序**：PBR 会启动操作系统引导程序，操作系统的内核就会被加载到内存中，并完成操作系统的初始化。
  
* ⑦加载启动管理器。分区引导记录PBR搜索活动分区的启动管理器

* ⑧加载操作系统。将操作系统的初始化程序加载到内存中执行
  顺序：BIOS通过bootsequence→硬盘通过MBR→分区通过PBR→操作系统引导程序

![](/img/02931.jpg)

![](/img/180815.jpg)

![](/img/80856.jpg)

* PBR和操作系统引导程序的关系：

  * PBR 通常包含以下几部分内容：

    - **引导程序（Boot Loader）**：
      - 这是 PBR 中的主要内容，包含了用于引导操作系统的机器码。通常这个引导程序会非常小，负责将操作系统的更大部分（如启动管理器或操作系统内核）加载到内存中。
      - 引导程序也会通过加载操作系统的启动管理器（如 **GRUB** 或 **Windows 引导程序**），进一步引导系统进入操作系统内核的启动过程。
    - **文件系统信息**：
      - PBR 中也可能包含一些与分区文件系统相关的信息，比如分区的类型（如 FAT32、NTFS、EXT4 等）和一些文件系统的启动信息，这样操作系统的引导程序才能理解如何访问分区内的数据。
    - **操作系统引导程序的地址**：
      - 在 PBR 中，引导程序会知道如何找到并加载操作系统的主引导程序。通常这包括操作系统内核或者启动管理器的文件路径和位置。这个过程对于多操作系统的启动至关重要。
    - **引导记录签名**：
      - PBR 的最后 2 字节通常是 **0x55AA**，这个签名用于验证该扇区是否有效。如果 PBR 中的签名正确，表示该分区有一个有效的引导记录，可以继续加载操作系统。否则，启动过程会失败。

  * **PBR** 读取并执行内嵌的引导程序，该程序负责将操作系统的启动程序加载到内存中。

    启动程序（如 **GRUB** 或 **Windows 引导程序**）加载操作系统的内核到内存并启动操作系统。

  * **PBR** 是活动分区的第一个扇区，包含了启动操作系统所需的引导程序。

    **PBR 中的引导程序**会加载操作系统的主引导程序（如 GRUB 或 Windows 启动管理器），进而启动操作系统。

    **引导操作系统的程序**通常是非常小的，它的主要任务是将操作系统的核心部分加载到内存中，并确保操作系统能够正确启动。

### 进程和线程

#### 互斥

* 自旋锁具有随机性，不能保证按先来后到的顺序使用cpu资源

  * 自旋锁：当进程申请锁之败后，会已知循环申请锁直到成功

  ![](/img/165446.jpg)

* 创建共享内存需要通过系统调用实现，需要先进入内核态，内核在物理内存中分配一块连续区域，指定共享内存的访问权限（如读写权限）和大小，然后进程再通过系统调用将共享内存映射到自己的虚拟地址空间。

* **408范围内只有记录型信号量和管程（条件变量）可以实现让权等待**

* **条件变量和信号量的重要区别**

  ![](/img/22546.jpg)

  ![](/img/22559.jpg)

  * 条件变量**没有值**，仅实现了**排队等待**的功能；信号量是**有值**的，信号量的值反映了**剩余资源数**。
    * 在管程中，剩余资源数用共享数据结构记录
  * 条件变量的wait/signal操作与信号量不同，如果在管程中的一个进程发信号，但没有在这个条件变量上等待的任务，则丢弃这个信号
    * 条件变量的设计目的是在特定条件下让线程等待，并在条件满足时唤醒等待线程。信号的丢弃防止了不必要的唤醒，也避免了不必要的资源浪费

#### 进程调度

![](/img/Cache_-248a4a6132183be9(1).png)

* 进程调度的时机：
  * 阻塞一个进程
  * 中断返回之前
    * 在每次系统调用和中断之后，标志位need_resched被例程检查，如果标志位为1，那么调度程序需要在此时被调用。
      * need_resched是linux内核中的一个调度标志，用于标记当前的CPU是否需要进行进程切换（上下文切换）
      * resched是re-schedule的缩写，意思是重新调度
  * 终止一个进程
* 内核锁属于内核数据结构，**内核临界区不能发生进程调用**

#### 死锁

![](/img/17d9245c-7f19-42a5-aa82-126fdcacd4ce(1).png)

### I/O

* ![](/img/3b4b4b7b-1d7e-4d06-b711-746bfcb3b128.png)

  ![](/img/be1df64f-5f9c-4787-81ad-6895df8c797e.png)

* 统一编址方式下，I/O地址是存储地址的一部分，可以直接用访存指令访问I/O设备，区分存储单元和I/O设备是依靠它们的地址码

* 独立编址方式下，需要用专门的I/O指令来访问I/O设备，区分存储单元和I/O设备是依靠指令类型

* **唤醒**因为I/O操作被阻塞的进程由**中断服务程序**完成。

  * **阻塞**I/O操作进程由对应的**系统调用服务例程**完成
  * 将数据**从设备控制器的寄存器送往内核缓冲区**由**中断服务程序**完成
  * 将数据**从内核缓冲区送往用户缓冲区**由**系统调用服务程序**在唤醒后完成
  * **初始化外设**的代码在**驱动程序**中

  ![](/img/15013.jpg)
  
* 由于CPU处理时间比I/O设备短得多，因此设立缓冲区机制，用于缓和CPU与I/O设备的速度差异，提高CPU与I/O设备之间的并行性；当I/O花费的时间比CPU处理时间短得多，则缓冲区的存在就毫无意义了

#### I/O方式

##### DMA方式

* DMA进行数据传送之前，CPU先执行一段初始化程序，完成对DMA控制器中各参数寄存器的初始值的设定，因此**通过软件完成对DMA控制器中各参数寄存器的初始值的设定**
* 发生缺页中断时，若在缺页处理程序中将缺页调入内存采用DMA方式，则需要把磁盘物理地址写入DMA控制器中的设备地址寄存器DAR，将交换数据的主存起始位置（该页面的页基址）写入DMA接口中的主存地址寄存器
* 对于外中断的请求响应发生在每个指令周期结束后，对DMA请求的响应发生在每个总线事务结束之后
* DMA控制器是一个独立的硬件，有自己独立的寄存器控制数据传输，**在传输数据时不需要CPU的参与，也不需要修改CPU的现场信息，无须保护现场**，而中断方式需要CPU运行中断服务程序进行数据传输，因此需要保存CPU现场信息

##### 程序查询方式

* 程序直接控制I/O方式包含无条件传送和条件传送，无条件传送较为简单，无状态等交互信息，只需定时查询即可，适合于巡回检测采样系统或过程控制系统，以及非随机启动的字符型设备。

  * 条件传送方式下，接口中含有“就绪”“完成”等状态，可继续分为独占查询和定时查询

#### I/O软件层次结构

* ![](/img/223932432.jpg)
* **内核缓冲区和用户缓冲区之间的拷贝**由**设备独立性软件**实现，通常位于**系统调用服务程序**内，**系统调用服务程序属于设备独立性软件**的层次。**设备独立性软件**向用户提供**统一的设备I/O接口即系统调用**
* 对**设备的统一操作接口**是由驱动程序向上层提供的
* **I/O接口到内核缓冲区的数据传输代码在设备驱动程序里**
* **检查对I/O设备的请求的合法性是在设备驱动程序里完成的**，比如对打印机进行读操作就是非法的，应该向I/O系统报告I/O请求出错。
* **检查参数的合法性是在设备独立性软件实现的**
* **所有跟设备相关的逻辑都由设备驱动程序实现**

##### 设备独立性软件和设备驱动程序提供统一接口的区别

* **设备独立性软件提供的接口面向应用**

  * 设备独立性软件面向用户或文件曾提供统一逻辑接口，如统一使用read/write、open/close等系统调用去访问各种设备
  * 设备独立性软件定义的是**用户可见、跨设备一致的I/O抽象接口**

* **设备驱动程序提供的接口（面向硬件设备）**

  *  接收来自设备独立性软件的统一I/O请求（如read/write），然后将其翻译为具体硬件的控制命令，并通过总线或控制器与设备交互
  * **系统内部用于驱动特性设备的接口和实现**

* ![](/img/21828.jpg)

  ![](/img/222038.jpg)

  ![](/img/22225.jpg)

  ![](/img/222237.jpg)

  ![](/img/22256.jpg)

* ![](/img/6884ea46e022038c5f59ecf4(1).jpg)

#### 缓冲区

##### 单缓冲

![](/img/201332.jpg)

##### 双缓冲

![](/img/201746.jpg)

![](/img/201801.jpg)

![](/img/01817.jpg)

#### 磁盘

* 交换区是将内存中的部分数据临时转移到磁盘上，以释放内存空间，从而让内存能运行更多的程序或处理更大的数据。增大交换区并不能减少I/O速度
* 提高磁盘I/O速度的方法
  * 设置磁盘缓冲区
    * 磁盘缓冲区是内存中的一片区域，利用局部性原理，可以保留部分磁盘数据的拷贝，在命中时可以直接从磁盘缓冲区拿数据，无需磁盘I/O。
      * 但是需要考量置换算法。
      * 交付数据给用户的方式有两种：
        * 数据交互
          * 直接从磁盘缓冲区把数据传送到用户区
        * 指针交付
          * 只把磁盘缓冲区某区域的指针交付给进程，节省了数据的拷贝开销
  * 提前读和延迟写
    * 提前读是指把当前访问的盘块相邻的几个连续的盘快一起读入磁盘缓冲区，利用了空间局部性，命中时无需启动磁盘I/O
    * 延迟写是指磁盘缓冲区的数据本应该立即写回磁盘，但考虑不久的将来该数据还会被访问，所以不会立即写回磁盘，而是会把它挂在空闲缓冲区队列的末尾，当有进程申请这片磁盘缓冲区时，才把该修改的内容写回磁盘，同样也可以减少I/O时间（其实是时间局部性）
  * 优化物理块的分布
    * 尽可能地为文件分配相邻的磁盘块，这样磁盘就无需多次寻道，减少I/O时间

### 内存管理

![](/img/md2card-1750735950162-1(1).png)

* 影响系统缺页率的要素

  * 页面置换算法

  * 工作集的大小

    * 工作集的大小决定了分配给进程的物理块数，分配给进程的物理块数越多，缺页率就越低

  * 进程的数量

    * 进程的数量越多，对内存资源的竞争越激烈，每个进程被分配的物理块数越少，缺页率也就越高

  * 页缓冲队列的长度

    * 页缓冲队列

    ![](/img/220631.jpg)

    ![](/img/220700.jpg)

  * 程序的编制方法

    * 编写程序的局部化程度越高，执行时的缺页率就越低，若存储采用的是按行存储，则访问时就要尽量采用相同的访问方式，避免按列访问造成缺页率过高的现象
  
* clock页面淘汰算法，**页面命中时，进改变访问位，不改变页框指针；页面未命中时，从当前页框出发，访问位为1，则改为0，直到找到访问位为0的页框，此后将此页框访问位改1，页指针指向下一个页框**

  * **最开始的页框指针指向第一个被放入的页面**

#### 虚拟存储管理

* 页式存储管理方式的虚拟地址空间维度是一维的

  * 段式存储管理方式的虚拟地址空间是二维的
  * 段页式存储管理方式的虚拟地址空间是二维的

  ![](/img/215613.jpg)

* 页式存储管理中每个进程有一个页表

* 段式存储管理中每个进程都有一个段表

* 段页式存储管理中，每个进程都有一个段表，每个进程的每个段都有一个页表

* **物理地址=基地址+相对地址**

* 页号=物理地址/页大小

##### 是否会产生内外碎片总结

![](/img/182234.jpg)

![](/img/82330.jpg)

#### 内存映射文件

![](/img/221511.jpg)

* 内存映射文件利用了操作系统的请求调页基址。当文件被映射时，并不会立即将其全部内容调入物理内存。只有当进程实际访问到映射区域中的某个特定页面，而该页面尚未在物理内存中时，才会触发缺页中断，操作系统再负责将对应的文件部分从磁盘调入物理内存。这种按需调页的方式使得可以映射远大于可用物理内存的文件
* **创建共享内存**需要通过**系统调用**实现，需要先进入**内核态**，内核在**物理内存中**分配一块**连续区域**，指定共享内存的**访问权限（如读写权限）和大小**，然后**进程**再通过**系统调用**，将共享内存映射到自己的虚拟地址空间。因此**共享内存映射的建立**发生在**内核态**下。
  * 在虚拟页式内存管理的操作系统中，**内存修改进程的页表**，将**指定的虚拟地址范围映射到共享内存的物理页框**。多个进程的虚拟地址可以不同，但最终指向同一物理内存。
* 对**共享内存的读写**通常是在**用户态**下进行的。用户进程可以通过其**虚拟地址直接读写内存共享空间**

### 文件管理

![](/img/23115.jpg)

* FAT在文件系统挂载的时候就被全部或大部分读入内存，并常驻内存当中，而不是打开单个文件的时候才去读入
* 空闲链表法分为空闲盘块链和空闲盘区链，空闲盘区链可以把连续的空闲盘块合并成一个区，支持合并
* 在引入索引节点（inode）的文件系统中，目录项通常包含文件名与该文件名对应的索引节点号。目录本身是一个包含这些目录项的文件。索引节点是存储文件元数据（如文件大小、权限、物理位置等）的数据结构，他们通常集中存放在磁盘的特定区域（索引节点区）。因此，目录是文件名到索引节点号的映射集合，而不是索引节点本身的有序集合。
* 超级块通常在磁盘上有多个副本（备份）。主超级块通常位于文件系统的固定位置，而备份超级块则分布在文件系统的其他位置，如果主超级块损坏，系统可以尝试从备份中恢复。
* ![](/img/203944.jpg)

#### inode

* inode不包含文件名，文件名存储在目录文件的目录项中，每个目录文件将文件名与inode号关联

* 对于 **第一次打开文件**，操作系统必须去硬盘读取对应的 **inode**，而不依赖于内存中的 **inode 缓存**。即使是其他 inode 已经被调入内存，只要是 **第一次打开文件**，操作系统都需要去硬盘读取该文件的 inode。下面我进一步澄清这个过程：

1. **第一次打开文件时必须去硬盘读取 inode**：

- 当进程请求打开一个文件时，**文件系统必须找到该文件的 inode**，而 inode 存储着文件的元数据。
- **即使其他 inode 已经被加载到内存中**（比如在之前访问其他文件时已经调入），**操作系统也不能直接假设该文件的 inode 已经在内存中**。这是因为 inode 的存储是**按块（block）**来组织的，多个 inode 可能会被存储在同一个块中。操作系统在读取一个 inode 时，实际上是将该块从硬盘加载到内存中，而不是只读取一个单独的 inode。

2. **inode 缓存的作用**：

- 操作系统会将访问过的 inode 缓存到内存中的 **inode 缓存**，以提高后续访问同一文件时的效率。**如果 inode 已经在内存中，操作系统可以直接从内存中获取**。
- 然而，**第一次打开文件时**，因为该文件的 inode 还没有被缓存到内存中，操作系统就必须去硬盘上查找和加载该 inode。

3. **不存在“先查看内存”的步骤**：

- 虽然操作系统会维护一个 **inode 缓存**，但它**并不在第一次打开文件时先检查内存**。操作系统在打开文件时会直接通过文件的路径来定位 inode（通常是通过目录项与 inode 的映射关系）。如果这个 inode 不在内存中，操作系统会去硬盘读取。
- 只有当文件的 inode 被加载到内存中后，才会通过 **inode 缓存**来提高后续对同一文件的访问效率。

4. **总结**：

- **第一次打开文件时**，操作系统**必须去硬盘读取 inode**，并将其加载到内存中。
- 即使**其他 inode 已经在内存中**，也不能影响第一次打开文件的过程，因为**每个 inode 都是单独按块存储的**，而且操作系统无法预先知道该 inode 是否已经在内存中。
- **inode 缓存**只在后续访问同一文件时提供帮助，减少了磁盘 I/O 操作。

举个简单例子：

1. **第一次打开文件**时，操作系统必须去磁盘读取该文件的 inode。它会读取硬盘的目录结构，找到 inode 所在的块，将该块读取到内存中。
2. 以后如果再次访问相同的文件，操作系统就可以直接从内存中的 inode 缓存中获取 inode，避免了磁盘读取。

#### 文件共享

* **硬链接和原文件共享一个inode**，**软连接**是一个新的link文件，**有自己的inode**
* count计数制的本质是该inode有几个主题共享
* **硬链接不能跨文件系统使用，因为每个文件系统各自维护自己的inode数据结构和列表，而软连接存的是文件路径，可以跨文件使用**

#### 磁盘空闲块的管理方法

* 成组链表法

  * 原理

  ![](/img/jkk.drawio.png)

  ![](/img/erwer.drawio.png)

  ![](/img/200229.jpg)

  * 分配

  ![](/img/kongxiankuaifenpei.drawio.png)

  * 回收

  ![](/img/kongxiankuaihuishou.drawio.png)

## CN（计网）

### 计算机网络体系结构

* 传输媒体（线）不属于网络体系结构
* 网络层参与拥塞控制
* 无确认无连接服务适用于实时性要求高的场景

### 物理层

* 电路交换：
  * 一旦专用电路建立，路径上的任何障碍都会导致整个连接中断
* 数据报分组交换
  * 每个分组独立路由，某个后继路由器故障后，发往该路由器的分组将失败，除非路由协议（如OSPF，RIP）能够检测到故障并找到一条不经过该路由器的新路径到达目的服务器，否则后续分组将无法到达
* 报文交换
  * 如果报文已经完整到达某路由器，但是下一跳路由器故障，某路由器无法将报文转发出去。该报文可能会在某路由器的存储中因超时而丢弃，或者如果系统有动态路由能力且存在备用路径，可能会尝试重路由（但这超出了基本报文交换的范畴，更接近高级网络功能）。基本情况下可以认为报文受阻于某路由
* **集线器**是**物理层设备**，会将收到的信号**广播到除接收端口以外的所有端口**。所有链接到集线器的设备共享同一个冲突域，因此**同一时间只能有一个设备发送数据，否则会发生冲突**
* 过程特性定义了在物理连接的建立、维持和释放过程中，各种事件发生的合法顺序。
* 在采用粗同轴电缆的**10BASE5以太网**规范中，**互相串联的中继器的个数不能超过4个，而且用4个中继器串联的5段通信介质中，只有3段可以挂接计算机，其余2段只能用作扩展通信范围的链路段，不能挂接计算机**

### 数据链路层

* 负载均衡：允许多路并行转发数据，最大吞吐量为多路带宽之和
* 信道带宽=信道频率范围上限-信道频率范围下限
* 时延带宽积=传播时延*信号带宽
* 交换机（或网桥）对终端设备透明，**不改变帧的MAC地址**。路由器在将IP数据报从一个网络转发到另一个网络时，需要重新封装数据链路层帧头，**此时源MAC地址是路由器出接口的MAC，目的MAC地址是下一跳或最终目标主机的MAC**
* 传输数据量只用在意时间内发送方能发送多少，不需要在意对方收没收到
* 数据链路层帧尾部的帧检验字段（FCS）会检验包括IP分片在内的整个帧的内容。一旦发生比特差错，数据链路层在收到该帧时就会因FCS校验失败而发现错误并将其丢弃。
  * **网络的IP头部检验和只管头部，不管数据**
* CRC循环冗余码，如果首位是 1，就商 1；如果首位是 0，就商 0。
* **交换机**是**数据链路层设备**，**每个端口都是一个独立的冲突域**，当端口连接单个设备时，可以工作在**全双工模式下，同时收发数据而不会发生冲突**。

#### CSMA/CA

![](/img/b4nw4g.png)

![](/img/32311.jpg)

![](/img/32244.jpg)

#### CSMA/CD

* 路由器是网络层设备，只认识目的主机的IP地址，**无法看见链路层的AP**，因此如果ARP表为空，会广播ARP请求报文，获取目的主机的MAC地址
* **路由器发到AP的是以太网帧，AP将以太网帧转换成802.11帧后转发**

### 网络层

* 路由器在查找路由表时使用最长前缀匹配原则来确定最佳路由。交换机在查找MAC地址表时，是进行**精准匹配**，级查找与帧目的MAC地址完全相同的表项。如果找不到，则泛洪（对未知单播）。没有“最长匹配”的概念用于交换机的MAC地址表查找。
* 虚电路只在网络层建立，TCP在传输层建立的只能叫可靠连接不能叫虚电路。
* 虚电路服务于点到点的通信而非端到端的通信，因此两台主机之间的多条虚电路服务于主机，主机可以分配不同进程使用不同虚电路，因此虚电路不单独为某个进程服务，而是为多个进程服务。
  * 只有一条虚电路也可以为不同进程服务

* NAT路由器会修改源IP和源端口

### 应用层

* FTP协议在整个会话期间，只使用一条TCP连接来传输控制命令（如登录、改变目录、上传/下载文件的请求等），这个连接在会话开始时建立，在会话结束时关闭。**每当有一次实际的文件传输（无论是上传还是下载）发生时，FTP都会新建一条临时的TCP数据连接，文件传输完成后，该数据连接就会关闭。**