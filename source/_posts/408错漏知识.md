---
title: 408错漏知识
date: 2025-07-10 16:42:19
tags: 408日常
sticky: 339
categories: 408
banner_img: /img/1920x1080 (34).jpg
index_img: /img/1920x1080 (34).jpg
math: true
---

## DS（数据结构）

### 时间复杂度

![](/img/7750ecde-42cf-41d4-b421-33ad22b9a430.png)

### 外部排序

* I/O次数的计算：初始归并段生成的I/O次数+归并时的I/O次数
  * 初始归并段生成的I/O次数=磁盘块数*2（读写各I/O一次）
  * 归并时的I/O次数=磁盘块数* 2 *归并趟数
* 败者树中非叶子节点存储的是失败者的标记（归并段下标），而叶子节点存储的是各个路当前记录的索引值
* 败者树的空间复杂度是O(n)，时间复杂度是O(nlogn)
* 败者树为k路归并段内部排序所使用的，用于提高内部排序效率，与I/O次数无关

![](/img/3125237.jpg)

### 链表

* 从长度为n的顺序表中删除任一各元素，平均时间复杂度是O(n)

#### 单链表

* 单链表中删除一个节点有两种方法
  * 1、将该点直接删除，让该点的上一个节点直接指向该点的下一个节点
  * 2、将该点变成该点的下一个点

#### 静态链表

* 静态链表删除或插入不需要移动元素

* 静态链表的存储空间虽然是顺序分配的，但元素的存储不是顺序的，查找时仍然要按照链依次进行，而插入、删除都不需要移动元素。静态链表的存储空间是一次性申请的，能容纳的最大元素个数在定义时就已经确定。由于并非每个空间都存储了元素，因此会导致存储空间的浪费

* 数组一旦确定，数据元素的容量和位置关系就是固定的，因此不能进行插入和删除等操作

* 稀疏矩阵压缩存储后，不能直接根据元素所在数组中的位置在内存中定址，也就意味着失去了随机存取的功能

* 广义表：

  ![](/img/21623.jpg)

  ![](/img/221639.jpg)

  ![](/img/221651.jpg)

### 串

#### kmp算法小总结

* 代码

```c++
//完整
#include<iostream>
using namespace std;
const int N =10010,M=100010;
int n ,m;
char p[N],s[M];
int ne[N];

int main(){
	
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n>>p+1>>m>>s+1;
	//求next数组的过程
	for(int i = 2,j=0;i<=n;i++){
		while(j&&p[i]!=p[j+1]) j = ne[j];
		if(p[i]==p[j+1])j++;
		ne[i] = j;//注意，此处的ne数组已经是优化过的ne数组
	}
	
	
	 
	//kmp匹配过程
	for(int i = 1,j=0;i<=m;i++) //i枚举Si ，j和Si匹配的是P(j+1) ,总往前错一位 
	{
		while(j&&s[i]!=p[j+1])//j没有退回起点，退回起点意味着要重新开始匹配 ;不等意味着那个位置不匹配了 
	    	j = ne[j];//ne[j]是当前j点的最长后缀的长度，j是不匹配后往后移动更新的检验分界点。由于j从0开始，所以当j等于上一个j的ne长度时，相当于j被更新到图示位置 
	    if(s[i]==p[j+1]) j++;//下一个字符终于匹配，继续检验下一个位置的字符是否匹配 
		if(j==n) {
			//匹配成功 
			cout<<i-n<<" ";//输出子串的位置
			j=ne[j];
		}
	}
	
	
} 
```

* next数组手算过程：

  * **next[1]都无脑写0，next[2]都无脑写1**
  * 其他next
  * next数组采用求匹配失败的元素的左边起子串的前缀后缀相同的下一个位置

  ![](/img/05205.jpg)

* nextval数组手算过程

  * 先求next数组
  * nextval数组j=1的位置无脑写0，然后后面的进行回溯，如果回溯到不一样的就保持不变，一样的就继续回溯

### 栈

* 上溢是指存储器满，还往里写，下溢是指存储器空，还往外读。

### 树

#### 根据遍历序列确定二叉树的形态

![](/img/24507.jpg)

### 图

* 只有在无向图中，DFS的调用次数=连通分量的个数
  * 有向图中因为强连通分量要求互相之间都有去往边，而DFS只保证有从一个顶点向另一个顶点的边，不保证有反向的边

#### 图的顶点和边的关系

![](/img/25140.jpg)

### 查找

#### 平衡二叉树(AVL)

* 平衡二叉树的删除
  * 删除的是叶子节点：直接删除
  * 删除的是只有左子树或者右子树的节点：删除后用子树替代原节点
  * 删除的是有两个孩子的节点：用直接前驱（左子树最右下）或者直接后继（右子树最左下）来替代原节点，然后进行调整
* 平衡二叉树的结点数计算

![](/img/30420.jpg)

#### B树

* B树的删除
  * 叶子节点：直接删除
    * 符合规则无需改动
    * 不满足最低叶子节点：
      * 兄弟够借借兄弟
      * 兄弟不够借，合并兄弟节点和自己以及夹在中间的双亲结点
  * 非叶子节点：删除后用直接前驱或者直接后继替代，相当于在叶子节点删除直接前驱或者直接后继

![](/img/230953.jpg)

![](/img/31007.jpg)

### 排序

* 快速排序的枢轴值将序列划分的越平均排序速度越快
* 快速排序越有序，递归深度越深

## CO（计组）

### 计算机系统概述

#### 冯诺依曼计算机的特点

![](/img/31517.jpg)

![](/img/231538.jpg)

#### 计算机分层系统

![](/img/231635.jpg)

![](/img/31726.jpg)

#### 计算机性能指标

* MIPS=（主频/CPI）/10^6
* 时间=CPI*指令总数/主频
* 影响平均CPI的因素
  * 微体系结构决定硬件执行指令的效率
    * 如流水线、超标量、分支预测等
  * 指令调度策略用于优化指令执行顺序，减少数据依赖或者控制依赖导致的冒险
    * 如编译器静态调度或硬件动态调度
  * 指令系统结构直接决定指令的复杂度和执行效率
    * 如RISC或CISC

### 数据的表示和运算

* 原码一位乘共进行n次加法和n次逻辑右移
  * 补码booth乘法共进行n+1次加法和n次算术右移
* **补码的本质是取模**，对于补码表示的定点小数，模数是2，对于补码表示的定点小数，模数是2^n+1
* 两个短相加变长，会先对两短进行扩展，扩展的时候按照短自己的类型进行扩展（短的是无符号数就0扩展，是有符号数就符号扩展）。

![](/img/214328.jpg)

#### 浮点数

* 浮点数的舍入

![](/img/32644.jpg)

### 存储系统

#### 主存储器

* 行列地址线复用的情况下，由于DRAM按行刷新，因此行地址位数要小于等于列位地址数，而地址线条数=max（列地址位数，行地址位数）

* **地址线和译码器输出的选择线的关系：n条地址线，译码输出的选择线是2^n条**

* DRAM按行刷新，刷新计数器和行地址一样，送往行译码器再进行行选，所以**刷新计数器即地址线根数=10bit**

* **行缓冲为一行的数据大小=列数*数据位数**

* **多路选择器是一种能够从多个输入信号中选择一个输出的信号转换设备。译码器是一种将二进制编码转换为一组特定输出信号的设备。在寄存器堆中，译码器常常用于地址译码，从而控制对特定寄存器的访问。**

  ![](/img/91810.jpg)

  * **执行寄存器写相关指令时（将结果保存在寄存器中），指令中的寄存器编号被送到一个地址译码器进行译码，选中某个寄存器进行写入，读出时（从寄存器中获得计算数据）寄存器编号作为一个控制信号来控制一个多路选择器，选择相应的寄存器读出。**
  * 读口（组合逻辑操作）：无需时钟控制，busA和busB分别由RA和RB给出地址。地址RA或RB有效后，经一个“取数时间（AccessTime）”，busA和busB有效
  * 写口（时序逻辑操作）：需要时钟控制。写使能为1的情况下，时钟边沿到来时，busW传来的值开始被写入RW指定的寄存器中。
    * 写是需要改变寄存器的值的，需要等到数据的信号稳定后写入，防止出错。而读只需要和寄存器里的值相等就行

* SRAM不地址复用,DRAM地址复用

### Cache

* cache比较器个数

![](/img/215517.jpg)

### 虚拟存储器

* 段式的比较先后：

  * 越界与否→缺失与否→越权与否

  ![](/img/20305.jpg)
  
* **逻辑地址空间的大小受限于CPU的寻址能力（如32位CPU理论上可以寻址4GB，64位CPU则大得多）**，而这些逻辑地址空间中的内容，一部分在物理内存中，大部分则存放在外存（通常是磁盘的交换区或对换区）上。因此，虚拟存储的总容量可以理解为物理内存和可用外存空间之和，但实际上限更多地由CPU寻址范围和外存大小决定

### 指令系统

![](/img/15325.jpg)

* 调用指令第一条指令比须显式给出转移的目标地址，否则无法调用子程序
* **一条指令的处理时间为：取指令时间+执行指令时间+中断周期时间（关中断、保存断点、中断服务程序入口地址送PC），中断周期时间不包括中断服务程序的执行时间**

* 扩展指令码
  * 扩展指令码上层是多地址指令，下层是少地址指令，少地址指令
  * 前缀不能相同

![](/img/010539.jpg)

#### 寻址方式

* 遇到基址寻址计算操作数地址的时候，都可以将基址寄存器的内容和形式地址进行符号扩展以后的结果直接相加

### 中央处理器

* 所有信号在一个时钟周期内从状态单元1经组合逻辑到达状态单元2，信号到达状态单元2所需的时间决定了时钟周期的长度
  * **时钟周期以相邻状态单元间组合逻辑电路的最大延迟为基准确定**
* 若单周期处理器中所有指令的指令周期为一个时钟周期，则可以采用多总线结构的数据通路

#### 微程序控制器

* 微程序控制器中，执行指令微程序的首条微指令地址是**指令操作码**译码得到的
* 硬布线控制器又名组合逻辑控制器
* 取指微程序是每条机器指令公共的微程序，入口地址通常固定（μPC初始置0，即CM中的首条就是取指微程序的首地址，然后执行取指微程序进行取指）
* **取指微程序和机器指令微程序的关系和区别**

![](/img/4932414346.jpg)

![](/img/225011.jpg)

![](/img/25026.jpg)

![](/img/25043.jpg)

![](/img/225053.jpg)

#### 时钟信号

![](/img/235438.jpg)

![](/img/35518.jpg)

![](/img/235543.jpg)

![](/img/235604.jpg)

![](/img/235659.jpg)

![](/img/4d658007-85e3-40f2-812c-857e014a5484(1).png)

### 指令流水线

* 虽然增加流水线级数可能缩短每级延迟，但“必然”提高主频的说法过于绝对。实际中，流水线级数增加会引入额外的寄存器延迟（如建立时间、保持时间），且若各阶段延迟不均衡，最慢阶段仍会限制主频。此外，过深的流水线可能导致控制复杂度上升，反而影响性能。因此，当段数达到一定数量时，流水线技术增加不一定会提高主频了。
* 流水线的时钟周期必须覆盖最慢阶段的延迟（包括组合逻辑延迟和流水线寄存器延迟），否则会导致数据无法正确传递。因此，CPU的最高频率由流水线中最关键路径（即延迟最大的阶段）决定。
* 流水线技术的核心优势在于提高吞吐率（单位时间内完成的指令数），而非减少单条指令的执行时间。由于流水线寄存器延迟的存在，单条指令的总执行时间可能反而略有增加（如从单周期变为多周期）。虽然主频提高可能缩短时钟周期，但单条指令仍需经历多个阶段，其总执行时间并未减少
* 流水线级数的核心思想正是通过指令级并行（ILP）实现多条指令的不同阶段同时执行。

#### 数据冒险

* 旁路转发技术和load-use冒险：

  ![](/img/202405222222529.png)

  * load指令**在第四周期即M访存阶段结束时**，数据在流水段寄存器中已经有值，在此时可以采用数据转发技术可以使load指令后面第二条指令得到所需的指，但不能解决load指令和随后的第一条指令之间的数据冒险，**要延迟执行一条指令**

  ![](/img/202405222232608.png)

  ![](/img/202405222234220.png)

  * **普通数据冒险采用旁路转发技术不需要阻塞，而load-use需要阻塞一个时钟周期的根本原因是所需数据产生的阶段不同，使用ALU计算获得结果（所需数据）的在EX阶段可以产生所需数据，而load指令在M阶段从内存中获取所需数据**
  * load指令中的ID和EX是在获取所需数据的内存地址，M访存获得所需数据

* lw指令：从内存中读取一个字，并将其放在一个寄存器中

  sw指令：将一个寄存器中的字写入内存中

### 总线

* 采用数据/地址总线复用技术，总线中保留数据线，地址经过数据线传输

### 中断和异常

![](/img/211409.jpg)

* 概念厘清
  * 中断向量
    * **中断处理程序的入口地址（首地址）**
  * 中断类型号
    * **标识终端类型的编号**
  * 中断向量地址
    * **保存中断向量的内存地址，在中断响应阶段由中断向量地址形成部件（硬件）生成**
  * 中断优先级
    * 中断响应优先级
      * **硬件产生且不可更改**
    * 中断处理优先级
      * 由排队器、中断屏蔽字等硬件决定
  * 中断向量表
    * 记录了**中断编号和中断向量的对应关系**



## OS（操作系统）

### 操作系统概述

#### 进程的状态

* 挂起态通常是由于终端用户请求、父进程请求、系统负荷调节或者操作系统自身需要等原因，将进程置于静止状态

### 进程和线程

#### 互斥

* 自旋锁具有随机性，不能保证按先来后到的顺序使用cpu资源

  * 自旋锁：当进程申请锁之败后，会已知循环申请锁直到成功

  ![](/img/165446.jpg)

* 创建共享内存需要通过系统调用实现，需要先进入内核态，内核在物理内存中分配一块连续区域，指定共享内存的访问权限（如读写权限）和大小，然后进程再通过系统调用将共享内存映射到自己的虚拟地址空间。

#### 进程调度

![](/img/Cache_-248a4a6132183be9(1).png)

#### 死锁

![](/img/17d9245c-7f19-42a5-aa82-126fdcacd4ce(1).png)

### I/O

* ![](/img/3b4b4b7b-1d7e-4d06-b711-746bfcb3b128.png)

  ![](/img/be1df64f-5f9c-4787-81ad-6895df8c797e.png)

* 统一编址方式下，I/O地址是存储地址的一部分，可以直接用访存指令访问I/O设备，区分存储单元和I/O设备是依靠它们的地址码

* 独立编址方式下，需要用专门的I/O指令来访问I/O设备，区分存储单元和I/O设备是依靠指令类型

* **唤醒**因为I/O操作被阻塞的进程由**中断服务程序**完成。

  * **阻塞**I/O操作进程由对应的**系统调用服务例程**完成
  * 将数据**从设备控制器的寄存器送往内核缓冲区**由**中断服务程序**完成
  * 将数据**从内核缓冲区送往用户缓冲区**由**系统调用服务程序**在唤醒后完成
  * **初始化外设**的代码在**驱动程序**中

  ![](/img/15013.jpg)
  
* 由于CPU处理时间比I/O设备短得多，因此设立缓冲区机制，用于缓和CPU与I/O设备的速度差异，提高CPU与I/O设备之间的并行性；当I/O花费的时间比CPU处理时间短得多，则缓冲区的存在就毫无意义了

#### I/O方式

##### DMA方式

* DMA进行数据传送之前，CPU先执行一段初始化程序，完成对DMA控制器中各参数寄存器的初始值的设定，因此**通过软件完成对DMA控制器中各参数寄存器的初始值的设定**
* 发生缺页中断时，若在缺页处理程序中将缺页调入内存采用DMA方式，则需要把磁盘物理地址写入DMA控制器中的设备地址寄存器DAR，将交换数据的主存起始位置（该页面的页基址）写入DMA接口中的主存地址寄存器
* 对于外中断的请求响应发生在每个指令周期结束后，对DMA请求的响应发生在每个总线事务结束之后
* DMA控制器是一个独立的硬件，有自己独立的寄存器控制数据传输，**在传输数据时不需要CPU的参与，也不需要修改CPU的现场信息，无须保护现场**，而中断方式需要CPU运行中断服务程序进行数据传输，因此需要保存CPU现场信息

##### 程序查询方式

* 程序直接控制I/O方式包含无条件传送和条件传送，无条件传送较为简单，无状态等交互信息，只需定时查询即可，适合于巡回检测采样系统或过程控制系统，以及非随机启动的字符型设备。

  * 条件传送方式下，接口中含有“就绪”“完成”等状态，可继续分为独占查询和定时查询

#### I/O软件层次结构

* ![](/img/223932432.jpg)

### 内存管理

![](/img/md2card-1750735950162-1(1).png)

* 影响系统缺页率的要素

  * 页面置换算法

  * 工作集的大小

    * 工作集的大小决定了分配给进程的物理块数，分配给进程的物理块数越多，缺页率就越低

  * 进程的数量

    * 进程的数量越多，对内存资源的竞争越激烈，每个进程被分配的物理块数越少，缺页率也就越高

  * 页缓冲队列的长度

    * 页缓冲队列

    ![](/img/220631.jpg)

    ![](/img/220700.jpg)

  * 程序的编制方法

    * 编写程序的局部化程度越高，执行时的缺页率就越低，若存储采用的是按行存储，则访问时就要尽量采用相同的访问方式，避免按列访问造成缺页率过高的现象
  
* clock页面淘汰算法，**页面命中时，进改变访问位，不改变页框指针；页面未命中时，从当前页框出发，访问位为1，则改为0，直到找到访问位为0的页框，此后将此页框访问位改1，页指针指向下一个页框**

  * **最开始的页框指针指向第一个被放入的页面**

#### 虚拟存储管理

* 页式存储管理方式的虚拟地址空间维度是一维的

  * 段式存储管理方式的虚拟地址空间是二维的
  * 段页式存储管理方式的虚拟地址空间是二维的

  ![](/img/215613.jpg)

* 页式存储管理中每个进程有一个页表

* 段式存储管理中每个进程都有一个段表

* 段页式存储管理中，每个进程都有一个段表，每个进程的每个段都有一个页表

* **物理地址=基地址+相对地址**

* 页号=物理地址/页大小

#### 内存映射文件

![](/img/221511.jpg)

* 内存映射文件利用了操作系统的请求调页基址。当文件被映射时，并不会立即将其全部内容调入物理内存。只有当进程实际访问到映射区域中的某个特定页面，而该页面尚未在物理内存中时，才会触发缺页中断，操作系统再负责将对应的文件部分从磁盘调入物理内存。这种按需调页的方式使得可以映射远大于可用物理内存的文件

### 文件管理

* inode不包含文件名，文件名存储在目录文件的目录项中，每个目录文件将文件名与inode号关联

![](/img/23115.jpg)

* FAT在文件系统挂载的时候就被全部或大部分读入内存，并常驻内存当中，而不是打开单个文件的时候才去读入
* 空闲链表法分为空闲盘块链和空闲盘区链，空闲盘区链可以把连续的空闲盘块合并成一个区，支持合并
* 在引入索引节点（inode）的文件系统中，目录项通常包含文件名与该文件名对应的索引节点号。目录本身是一个包含这些目录项的文件。索引节点是存储文件元数据（如文件大小、权限、物理位置等）的数据结构，他们通常集中存放在磁盘的特定区域（索引节点区）。因此，目录是文件名到索引节点号的映射集合，而不是索引节点本身的有序集合。
* 超级块通常在磁盘上有多个副本（备份）。主超级块通常位于文件系统的固定位置，而备份超级块则分布在文件系统的其他位置，如果主超级块损坏，系统可以尝试从备份中恢复。
* ![](/img/203944.jpg)

## CN（计网）

### 计算机网络体系结构

* 传输媒体（线）不属于网络体系结构
* 网络层参与拥塞控制
* 无确认无连接服务适用于实时性要求高的场景

### 物理层

* 电路交换：
  * 一旦专用电路建立，路径上的任何障碍都会导致整个连接中断
* 数据报分组交换
  * 每个分组独立路由，某个后继路由器故障后，发往该路由器的分组将失败，除非路由协议（如OSPF，RIP）能够检测到故障并找到一条不经过该路由器的新路径到达目的服务器，否则后续分组将无法到达
* 报文交换
  * 如果报文已经完整到达某路由器，但是下一跳路由器故障，某路由器无法将报文转发出去。该报文可能会在某路由器的存储中因超时而丢弃，或者如果系统有动态路由能力且存在备用路径，可能会尝试重路由（但这超出了基本报文交换的范畴，更接近高级网络功能）。基本情况下可以认为报文受阻于某路由

### 数据链路层

* 负载均衡：允许多路并行转发数据，最大吞吐量为多路带宽之和
* 信道带宽=信道频率范围上限-信道频率范围下限
* 时延带宽积=传播时延*信号带宽
* 交换机（或网桥）对终端设备透明，**不改变帧的MAC地址**。路由器在将IP数据报从一个网络转发到另一个网络时，需要重新封装数据链路层帧头，**此时源MAC地址是路由器出接口的MAC，目的MAC地址是下一跳或最终目标主机的MAC**
* 传输数据量只用在意时间内发送方能发送多少，不需要在意对方收没收到

#### CSMA/CA

![](/img/b4nw4g.png)

![](/img/32311.jpg)

![](/img/32244.jpg)

### 网络层

* 路由器在查找路由表时使用最长前缀匹配原则来确定最佳路由。交换机在查找MAC地址表时，是进行**精准匹配**，级查找与帧目的MAC地址完全相同的表项。如果找不到，则泛洪（对未知单播）。没有“最长匹配”的概念用于交换机的MAC地址表查找。

