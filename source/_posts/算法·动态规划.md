---
title: 算法·动态规划
date: 2024-03-29 12:25:48
tags: 算法
sticky: 105
categories: 算法
banner_img: /img/1920x1080 (6).jpg
index_img: /img/1920x1080 (6).jpg
---

# 动态规划

* 状态表示，考虑用几维的状态来表示，背包问题一般为两维f(i,j)，每一个状态的含义

  * 集合（如选法集合）
    * 所有选法
    * 条件
      * 只从前i个物品中选
      * 总体积<=j
  * 属性（如最大值，最小值，数量）

* 状态计算，如何能把每一个状态算出来

  * 集合划分

    * 如何把该集合划分成更小的子集，使得每一个自己都可以用前面更小的状态表示出来

      ![](/img/145246.jpg)

      ![](/img/150150.jpg)

      ![](/img/150232.jpg)

      * 不重复//个数不重复，最大值重复无所谓
      * 不漏

* DP优化一般是对动态规划的代码或者计算方程进行等价变形

## 背包问题

### 01背包

* N个物品和容量是V的背包，每个物品有体积V和重量W两个属性，每件物品使用1次，要么0次要么1次，求容量内最大价值之和
* 特点是每件物品最多只用一次

```c++
//二维
#include <iostream>
#include <algorithm>
using namespace std;
const int N =1010;
int n,m;
int v[N],w[N];
int f[N][N];

int main(){
	cin >> n>>m;//读入背包容量和个数 
	for(int i  =1;i<=n;i++)
		cin>>v[i]>>w[i];//读入体积重量 
		
	for(int i = 1;i<=n;i++)
		for(int j = 0;i<=m;j++)
			{
				f[i][j]=f[i-1][j];
				if(j>=v[i])f[i][j]=max(f[i][j],f[i-1][j-v[i]]+w[i]);
				
			}
			cout<<f[n][m]<<endl;
			return 0;
	
} 
```

```c++
//一维
#include <iostream>
#include <algorithm>
using namespace std;
const int N =1010;
int n,m;
int v[N],w[N];
int f[N];

int main(){
	cin >> n>>m;//读入背包容量和个数 
	for(int i  =1;i<=n;i++)
		cin>>v[i]>>w[i];//读入体积重量 
		
	for(int i = 1;i<=n;i++)
		for(int j = m;j>=v[i];j--)			
				f[j]=max(f[j],f[j-v[i]]+w[i]);				
			cout<<f[m]<<endl;
			return 0;
	
} 
```

### 完全背包

* 每件物品可以用无限次



```c++

```



### 多重背包问题

* 每个物品的个数不一样，有个数限制，最多有Si个
* 有朴素版和优化版

### 分组背包问题

* 物品有N组，每一组物品里有若干种，每一组里面最多选一种物品

## 线性DP

## 区间DP

## 计数类DP

## 数位统计DP

## 状态压缩DP

## 树形DP

## 记忆化搜索