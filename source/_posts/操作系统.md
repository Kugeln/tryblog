---
title: 操作系统
date: 2024-07-31 23:28:42
tags: 408专业课
sticky: 143
categories: 408
banner_img: 1920x1080 (26).jpg
index_img: 1920x1080 (26).jpg
math: true
---
## 第一章

### 1.1 操作系统的基本概念

#### 1.1.1 操作系统的概念、功能

![](/img/095405.jpg)

![](/img/213953.jpg)

##### 操作系统的概念（定义）

![](/img/094324.jpg)

##### 操作系统的功能和目标——作为系统资源的管理者

![](/img/94413.jpg)

![](/img/94501.jpg)

##### 操作系统的功能和目标——向上层提供方便易用的服务

![](/img/094636.jpg)

![](/img/094723.jpg)

![](/img/094758.jpg)

![](/img/4923.jpg)

* 相当于把一系列的命令罗列在了该清单里面，当我们执行这个bat文件的时候，操作系统根据文件当中的这些命令一条一条往后执行

![](/img/095137.jpg)

* 狭义的用户接口不包括GUI

##### 操作系统的功能和目标——作为最接近硬件的层次

![](/img/095337.jpg)

#### 1.1.2 操作系统的特征

![](/img/095540.jpg)

##### 并发

![](/img/114510.jpg)

![](/img/559.jpg)

![](/img/14618.jpg)

![](/img/23644.jpg)

![](/img/3704.jpg)

##### 共享

![](/img/123857.jpg)

##### 并发和共享的关系

![](/img/24019.jpg)

##### 虚拟

![](/img/124345.jpg)

![](/img/213151.jpg)

![](/img/213259.jpg)

##### 异步

![](/img/213919.jpg)

### 1.2 操作系统发展历程

![](/img/4238.jpg)

![](/img/4001632.jpg)

##### 手工操作阶段

![](/img/33702.jpg)

##### 批处理阶段——单道批处理系统

![](/img/001041.jpg)

![](/img/001155.jpg)

##### 批处理阶段——多道批处理系统

![](/img/001312.jpg)

##### 分时操作系统

![](/img/001428.jpg)

![](/img/01528.jpg)

##### 其他集中操作系统

![](/img/001615.jpg)

### 1.3 操作系统的运行环境

#### 1.3.1 操作系统的运行机制

![](/img/03133.jpg)

* 本节的指令指的是二进制机器指令

##### 预备知识：程序是如何运行的

![](/img/002020.jpg)

##### 内核程序vs应用程序

![](/img/02124.jpg)

##### 特权指令vs非特权指令

![](/img/002303.jpg)

##### 内核态vs用户态

![](/img/002400.jpg)

##### 内核态、用户态的切换

![](/img/02505.jpg)

![](/img/02530.jpg)

![](/img/002553.jpg)

![](/img/002721.jpg)

![](/img/02806.jpg)

![](/img/002919.jpg)

![](/img/03052.jpg)

* CPU从用户态变为内核态以后，他会停止运行当前正在运行的应用程序，转而运行一个内核程序

#### 1.3.2 中断和异常

![](/img/005706.jpg)

![](/img/11021.jpg)

##### 中断的作用

![](/img/004050.jpg)

##### 中断的类型

![](/img/04255.jpg)

![](/img/05556.jpg)

##### 内中断的例子

* 与当前执行的指令有关，中断信号来源于CPU内部

![](/img/004404.jpg)

![](/img/004425.jpg)

![](/img/004459.jpg)

![](/img/04538.jpg)

![](/img/004632.jpg)

![](/img/004656.jpg)

![](/img/004747.jpg)

* 陷入指令不是特权指令

##### 外中断的例子

![](/img/004859.jpg)

![](/img/04951.jpg)

![](/img/005022.jpg)

![](/img/005104.jpg)

![](/img/005131.jpg)

##### 中断机制的基本原理

![](/img/005648.jpg)

#### 1.3.3 系统调用

##### 什么是系统调用，有何作用

![](/img/05923.jpg)

##### 系统调用与库函数的区别

![](/img/10056.jpg)

##### 什么功能要用到系统调用

![](/img/010326.jpg)

##### 系统调用的过程

![](/img/010423.jpg)

![](/img/10543.jpg)

![](/img/10623.jpg)

![](/img/010745.jpg)

![](/img/010756.jpg)

![](/img/10942.jpg)

### 1.4 操作系统结构

![](/img/030657.jpg)

![](/img/011201.jpg)

![](/img/30757.jpg)

![](/img/030810.jpg)

##### 操作系统的内核

![](/img/11239.jpg)

![](/img/011344.jpg)

![](/img/011441.jpg)

* 有的操作系统并不把这些管理功能放在内核当中，而只在内核当中保留与硬件接触最紧密的这些部分
  * 采用微内核结构的情况下，树与内核的功能是要运行在内核态的，不属于内核的管理功能在用户态运行

![](/img/011725.jpg)

##### 操作系统的体系结构

![](/img/030550.jpg)

* 采用微内核的体系结构，应用程序向操作系统提出服务的请求，接下来操作系统的这几个模块都需要为应用程序服务
  * 而进程管理这个模块在处理应用程序的请求的时候，同样需要得到内核的支持，所以这个模块对内核的访问就涉及到了CPU从用户态转到内核态
  * 服务完成了之后，又会从内核态再转回用户态
  * 同样的，其他管理模块在完成相应的工作的时候，同样也需要得到内核的支持，因此每一个模块都需要请求内核的服务
  * 每一次请求内核的服务，都会涉及到一个cpu状态转换的过程

##### 操作系统结构——分层结构

![](/img/033234.jpg)

* 每一层只能向下调用相邻那一层的结构

![](/img/033421.jpg)

##### 操作系统结构——模块化

* 主模块就是必不可少的，最重要最核心的模块，没有这些模块，操作系统就无法运行

![](/img/3728.jpg)

##### 操作系统结构——宏内核、微内核

* 所有系统功能都放在内核里面

![](/img/33856.jpg)

##### 操作系统结构——外核

* 应用程序可以通过系统提供的这些库函数，直接调用普通内核的一些功能
  * 也可以通过库函数去调用外核所提供的一些功能

![](/img/034048.jpg)

![](/img/055954.jpg)

### 1.5 操作系统引导

![](/img/060151.jpg)

##### 安装操作系统后

![](/img/71704.jpg)

* 分区表里面记录了每一个盘每个分区分别占多大的空间，以及每个分区的地址范围

![](/img/073626.jpg)

##### 开机过程

![](/img/073542.jpg)

* BIOS是基本输入输出系统
* 自举程序（boot程序）
* RAM里面的数据只要关机断电就会清空，但是ROM里面的数据不会因为断电清空
* 执行ROM引导程序的作用就是，指示CPU去把磁盘的主引导记录读入内存
  * 读入主存后，CPU执行磁盘主引导程序，磁盘引导程序会根据分区表去判断C盘的位置，接下来就可以读入C盘的第一部分即引导记录PBR的数据
    * 然后CPU去执行这个引导记录PBR里的程序
    * PBR里的程序的主要作用是会负责找到启动管理器
    * 启动管理器程序通常存放在根目录下面的某个位置
    * 从根目录找到这个启动管理程序，然后CPU再执行这个启动管理程序
    * 接下来这个启动管理程序就会完成操作系统初始化的一系列的工作

![](/img/073847.jpg)

### 1.6 虚拟机

##### 传统计算机

![](/img/074719.jpg)

* 两个进程在同一个操作系统上，可能存在一些安全隐患
  * 二者之间可能相互影响，也会相互地争夺操作系统管理的这些资源

##### 虚拟机

* 虚拟机管理程序（VMM）
* 第一类的虚拟机管理程序，会直接运行在硬件之上，由虚拟机管理程序，会把一个物理机器虚拟化为多台虚拟机器，会把一个总的硬件资源划分为多个部分分别给各个虚拟机使用，每一台虚拟机上面，可以安装各自的操作系统，在每个操作系统之上，又可以运行各自的用户进程
* 只有虚拟机管理程序是运行在内核态的，只有它可以使用特权最高的那些指令，而上层的操作系统和应用程序，实际上是运行在用户态的
  * 因此当上层的操作系统想要使用特权指令的时候，这个行为动作会被虚拟机管理程序给截获，这个虚拟机管理程序会把上层的操作系统想要执行的这个特权指令进行等价转换，模拟出指令执行成功的效果
* 第二类的虚拟机管理程序，并不是直接运行在硬件之上，而是运行在宿主操作系统上面，这个虚拟机管理程序想要给各个虚拟机器分配硬件资源，只能请求操作系统分配，再由虚拟机管理程序进行再分配，硬件资源的管理者依旧是宿主操作系统

![](/img/80442.jpg)

###### 常用的虚拟机软件

![](/img/075501.jpg)

##### 两类虚拟机管理程序的对比

![](/img/080515.jpg)

![](/img/080706.jpg)

![](/img/080820.jpg)

##### 支持虚拟化的CPU通常分更多指令等级

![](/img/080950.jpg)

## 第二章 进程与线程

### 2.1 进程与线程

#### 2.1.1 进程的概念、组成、特征

![](/img/235330.jpg)

* 在引入了线程之后，进程就不再是接受调度的基本单位了，但是进程依然是获得资源的基本单位

##### 进程的概念 

![](/img/214526.jpg)

![](/img/214615.jpg)

##### 进程的组成——PCB

![](/img/214917.jpg)

![](/img/15002.jpg)

##### 进程的组成——程序段、数据段

![](/img/21838.jpg)

![](/img/222439.jpg)

##### 程序是如何运行的

![](/img/2127.jpg)

##### 进程的特征

![](/img/5434.jpg)

#### 2.1.2 进程的状态与转换、进程的组织

![](/img/235620.jpg)

![](/img/053946.jpg)

##### 进程的状态——创建态、就绪态

![](/img/52605.jpg)

##### 进程的状态——运行态

![](/img/52813.jpg)

![](/img/052844.jpg)

##### 进程的状态——阻塞态

![](/img/53041.jpg)

##### 进程的状态——终止态

![](/img/53127.jpg)

![](/img/53145.jpg)

##### 进程状态的转换

![](/img/3452.jpg)

![](/img/053548.jpg)

##### 进程的组织——链接方式

![](/img/053758.jpg)

![](/img/53815.jpg)

##### 进程的组织——索引方式

![](/img/053900.jpg)

##### 进程的组织

![](/img/053927.jpg)

#### 2.1.3 进程控制

![](/img/54205.jpg)

![](/img/060002.jpg)

##### 什么是进程控制

![](/img/54126.jpg)

##### 如何实现进程控制

![](/img/4233.jpg)

![](/img/054332.jpg)

![](/img/054420.jpg)

##### 如何实现原语的原子性

![](/img/54519.jpg)

![](/img/054551.jpg)

![](/img/4620.jpg)

![](/img/054648.jpg)

* 关中断指令和开中断指令是特权指令，只能让内核程序使用，不能让普通的用户程序使用

##### 进程控制相关的原语

![](/img/5100.jpg)

* 作业：此时还放在外存里面的，还没有投入运行的程序
  * 作业调度：从外存当中挑选一个程序，把它放入内存让其开始运行

![](/img/055340.jpg)

![](/img/055434.jpg)

![](/img/5536.jpg)

![](/img/055602.jpg)

![](/img/055657.jpg)

![](/img/55744.jpg)

![](/img/55822.jpg)

![](/img/55835.jpg)

![](/img/55908.jpg)

#### 2.1.4 进程通信

![](/img/060107.jpg)

![](/img/1138.jpg)

##### 什么是进程间通信

![](/img/60231.jpg)

##### 为什么进程通信需要操作系统支持

![](/img/60510.jpg)

##### 共享存储

![](/img/061839.jpg)

![](/img/062002.jpg)

![](/img/62029.jpg)

* 数据结构的共享灵活性差、速度慢
* 基于存储区的共享灵活性高、速度快

##### 消息传递

![](/img/62211.jpg)

###### 直接通信方式

![](/img/065413.jpg)

![](/img/65743.jpg)

![](/img/065811.jpg)

![](/img/065846.jpg)

###### 间接通信方式

![](/img/65939.jpg)

![](/img/070019.jpg)

![](/img/0044.jpg)

![](/img/70056.jpg)

![](/img/070207.jpg)

##### 管道通信

* 管道通信下数据流动只能是单向的
* 管道通信的情况下数据具有先进先出（FIFO）的特性
* 和共享存储的区别
  * 在共享存储方式中数据的读写很自由，没有限制
  * 管道通信下，数据读写遵从先进先出的特性
    * 固定大小的内存缓冲区本质上是循环队列

![](/img/070937.jpg)

* 半双工通信指的是同一时刻只能支持单向的传输，全双工通信是指同一时刻支持双向的传输
* 写进程往管道写数据，即便管道没被写满，只要管道没空，读进程就可以从管道读数据
* 读进程从管道读数据，即便管道没被读空，只要管道没满，写进程就可以往管道写数据

#### 2.1.5 线程的概念

##### 什么是线程，为什么要引入线程

![](/img/71503.jpg)

![](/img/72034.jpg)

* 在传统的进程机制当中，CPU会轮流地为各个进程进行服务，那么这些进程就可以并发地执行，并且每一个进程会有他自己相应的一系列程序代码，被CPU服务的时候，这些代码就可以一句一句开始往下执行
* 为了满足一个进程当中宏观上同时做很多事情，引入了线程机制，用来增加系统的并发度
  * 引入了线程之后，CPU的调度服务对象就不再是进程，而是进程当中的线程，每一个进程当中可能会包含多个线程，CPU会被轮流地，用一定算法轮流地为这些线程进行服务

![](/img/072130.jpg)

##### 线程带来的变化

![](/img/072252.jpg)

##### 线程的属性

![](/img/072400.jpg)

#### 2.1.6 线程的实现方式和多线程模型

![](/img/080551.jpg)

##### 线程的实现方式

###### 用户级线程

![](/img/072550.jpg)

![](/img/72640.jpg)

![](/img/572955.jpg)

* 用户级线程的情况下
  * 线程的管理工作由应用程序通过线程库来完成的，并不是操作系统负责的
  * 线程切换的管理是由线程库即应用程序自己完成的，在用户态下就可以完成线程的切换工作，并不需要操作系统的干涉
  * 操作系统只能看到进程的村早，不能意识到用户级线程的存在

![](/img/075411.jpg)

* 用户级线程下CPU的调度单位依然是进程

###### 内核级线程

![](/img/075745.jpg)

* 内核级线程的管理工作由操作系统完成
* 线程切换需要操作系统介入，由用户态变为内核态
* 操作系统可以意识到内核级线程的存在

![](/img/075937.jpg)

* 在多核CPU的环境下，这几个线程可以分别分派到不同的核心下并行地执行，不同的内核级线程可以跑不同的代码逻辑

###### 多线程模型

* 一对一模型

![](/img/080123.jpg)

* 多对一模型

![](/img/080236.jpg)

* 多对多模型

![](/img/080402.jpg)

* 引入内核级线程之后，一个进程可能会对应多个内核级线程，而只有所有的这些内核级线程都被阻塞的时候，我们才说这个进程进入了阻塞状态

#### 2.1.7 线程的状态与转换

##### 线程的状态与转换

![](/img/080717.jpg)

##### 线程的组织与控制

![](/img/080940.jpg)

### 2.2 CPU调度

#### 2.2.1 调度的概念、层次

![](/img/2630.jpg)

##### 调度的基本概念

![](/img/5081105.jpg)

##### 调度的三个层次——高级调度

![](/img/81157.jpg)

![](/img/081219.jpg)

##### 调度的三个层次——低级调度

![](/img/081319.jpg)

##### 调度的三个层次——中级调度

![](/img/081358.jpg)

![](/img/081443.jpg)

##### 进程的挂起态与七状态模型

![](/img/082227.jpg)

* 一个处于就绪态的进程，如果此时系统的负载比较高，内存空间已经不够用，就可能把一个处于就绪态的进程暂时调到外存当中，然后该进程就进入了一个就绪挂起的状态。
  * 一直到内存空间空闲或者这个进程又需要继续执行，那么这个进程又会被激活，把它的数据又挪回到内存当中。这样一个就绪挂起的进程又回到了就绪态
* 一个阻塞态的进程也可以被挂起，相应的也可以再重新被调入内存，进行激活，重新回到阻塞态
* 有的操作系统有可能会使一个处于阻塞挂起的进程，当他等待的阻塞事件发生的时候，这个进程就会直接进入到一个就绪挂起的状态，然后之后当他再被重新调回内存的时候，是直接回到就绪态而非阻塞态
* 有的死后一个进程处于运行态，运行结束后，可能这个进程下处理机的时候，可能就会被直接放到外存当中，让他进入就绪挂起的状态
* 有的时候一个处于创建态的进程，当他创建结束之后，创建完PCB之后，有可能出现内存空间不够的情况，这种情况下有可能处于创建态的进程之后会先进入到一个就绪挂起的状态

##### 三层调度的联系、对比

* 高级调度是面向作业的调度
  * 一个作业在刚开始会被调入一次被调出一次，并且作业调入的时候，会为这个作业建立相应的PCB，也就是建立它相应的进程
* 中级、低级调度是面向进程的调度
  * 中级调度是把暂时不会运行的进程相关的一些数据调到外存里

![](/img/082548.jpg)

#### 2.2.2 进程调度的时机、切换与过程、方式

![](/img/085245.jpg)

##### 进程调度的时机

![](/img/82841.jpg)

![](/img/083559.jpg)

* 各个进程只能互斥地进入临界区，互斥地执行访问临界资源的代码

![](/img/083647.jpg)

![](/img/083728.jpg)

![](/img/083740.jpg)

![](/img/84939.jpg)

##### 进程调度的方式

![](/img/85053.jpg)

##### 进程的切换与过程

![](/img/85211.jpg)

#### 2.2.3 调度器与闲逛进程

##### 调度器/调度程序

![](/img/085523.jpg)

![](/img/85553.jpg)

##### 闲逛进程

![](/img/085644.jpg)

#### 2.2.4 调度算法的评价指标

![](/img/5713.jpg)

![](/img/90409.jpg)

##### CPU利用率

![](/img/085839.jpg)

##### 系统吞吐量

![](/img/085910.jpg)

![](/img/090001.jpg)

##### 周转时间

![](/img/090117.jpg)

* 带权周转时间表示的是这个进程的整个周转时间比运行时间大多少倍

##### 等待时间

![](/img/90256.jpg)

* 平均等待时间就是把所有进程或者作业的等待时间做一个加和再除以作业的数量

##### 响应时间

![](/img/90348.jpg)

#### 2.2.5 调度算法

![](/img/090528.jpg)

![](/img/92717.jpg)

![](/img/04721.jpg)

##### 先来先服务

![](/img/091037.jpg)

* 后备队列在外存当中

![](/img/090847.jpg)

##### 短作业优先

![](/img/092025.jpg)

###### 非抢占式的短作业优先算法

![](/img/091305.jpg)

![](/img/091230.jpg)

###### 抢占式的短作业优先算法

![](/img/091505.jpg)

![](/img/91631.jpg)

* 采用了抢占式的短作业优先之后得到的平均周转、平均带权周转、平均等待时间这三个指标比非抢占式的还要更小

![](/img/91923.jpg)

##### 对FCFS和SJF两种算法的思考

![](/img/92117.jpg)

##### 高响应比优先

![](/img/2421.jpg)

![](/img/092323.jpg)

##### 时间片轮转

![](/img/102629.jpg)

![](/img/093005.jpg)

![](/img/93030.jpg)

![](/img/093053.jpg)

![](/img/93133.jpg)

![](/img/093217.jpg)

![](/img/093247.jpg)

![](/img/093326.jpg)

![](/img/02047.jpg)

![](/img/102132.jpg)

![](/img/102159.jpg)

![](/img/02316.jpg)

![](/img/02440.jpg)

![](/img/02536.jpg)

![](/img/102600.jpg)

##### 优先级调度算法

![](/img/103411.jpg)

![](/img/03011.jpg)

![](/img/103128.jpg)

![](/img/03326.jpg)

##### 多级反馈队列调度算法

![](/img/04421.jpg)

![](/img/103618.jpg)

![](/img/641.jpg)

![](/img/103718.jpg)

![](/img/03746.jpg)

![](/img/103822.jpg)

![](/img/3846.jpg)

![](/img/103911.jpg)

![](/img/03924.jpg)

![](/img/103947.jpg)

![](/img/04050.jpg)

![](/img/04118.jpg)

![](/img/104136.jpg)

##### 多级队列调度算法

![](/img/105022.jpg)

### 2.3 同步与互斥

#### 2.3.1 进程同步、进程互斥

![](/img/110231.jpg)

* 进程同步又可以称之为进程之间的直接制约关系，进程之间是有直接的合作的
* 进程互斥又可以称作为进程之间的间接制约关系，因为进程之间并没有直接的合作关系，他们之间只是因为想要互斥地使用某一种系统临界资源，所以才会产生这种制约关系

##### 什么是进程同步

![](/img/05639.jpg)

![](/img/5731.jpg)

##### 什么是进程互斥

![](/img/05827.jpg)

![](/img/10045.jpg)

![](/img/0209.jpg)

#### 2.3.2 进程互斥的软件实现方法

![](/img/135908.jpg)

![](/img/192057.jpg)

* 单标志法的精髓在于用一个turn的变量来表示谦让这个动作
* 双标志法的精髓在于用一个flag数组来表示自己想要进入临界区的一个意愿
* peterson算法结合了双标志法和单标志法思想的精髓，每个进程在进入区当中都会先主动地争取和表达自己想要进入临界区的意愿，同时又主动地做出谦让的动作

##### 如果没有注意进程互斥

![](/img/140046.jpg)

##### 单标志法

![](/img/140235.jpg)

![](/img/40344.jpg)

##### 双标志先检查法

![](/img/190252.jpg)

![](/img/90458.jpg)

##### 双标志后检查法

![](/img/0729.jpg)

![](/img/1037.jpg)

##### peterson算法

![](/img/91606.jpg)

![](/img/1842.jpg)

![](/img/192040.jpg)

* 让权等待指的是，当进程进不了临界区，就应该立即释放处理机资源，而不应该继续在CPU上跑

#### 2.3.3 进程互斥的硬件实现方法

![](/img/15432.jpg)

##### 中断屏蔽方法

![](/img/10418.jpg)

* 关中断指令只对执行关中断指令的那个处理机有用，因此有可能发生两个处理机上的两个进程同时对临界区进行访问的情况

##### test and set指令

![](/img/210756.jpg)

* 在TSL循环中，如果lock本来就是true，即临界区本来就是被上锁的，那么他返回来的old的这个值也会为true，while这个循环就会一直循环下去
  * 一直到lock这个值被当前访问临界区的那个进程在退出区改成了false，那么testandset返回来的old值变为了false
  * 于是之前一直被卡在while循环的进程就可以跳出这个循环，然后正式地开始访问临界区的代码段，一直到访问结束之后再把自己上的锁给解除

##### swap指令

![](/img/215402.jpg)

* old记录原来的lock值，swap交换之后，以前的lock的值会放在old里面，old本来是true，true这个值又会被设置到lock里面
  * 之后while循环会检查以前的lock值是否为true，如果old值为true（即原lock为true），说明在之前这个临界区就已经被上锁了，那么这个循环会一直循环下去，一直到old为false，说明之前这个临界区是没有被上锁的状态，那么就会跳出这个循环，顺利地进入临界区访问这些代码段

#### 2.3.4 互斥锁

##### 进程互斥：锁

* 锁相当于一个bool型变量，当变量为true，说明已经上锁，变量为false，说明没有上锁

![](/img/15820.jpg)

* 缺点：锁都有忙等的问题，违反让权等待原则，一直占用cpu资源
  * 一个进程在忙等，暂时进不了临界区，并不会一直占用处理机，如果这个进程的时间片用完，调度程序依旧会让他下处理机

![](/img/20924.jpg)

* 多核处理器系统中一个核的运算能力可能会被吃掉在忙等，但其他核可以照常工作，并且快速释放临界区
* 单处理机系统下，进程吃掉了唯一的核，只有他的时间片用完并且上锁的那个进程上处理机解锁之后，才有可能获得这个锁

#### 2.3.5 信号量机制

![](/img/221157.jpg)

##### 信号量机制

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

#### 2.3.6 用信号量实现进程互斥、同步、前驱关系

#### 2.3.7 生产者-消费者问题

#### 2.3.8 多生产者-多消费者问题

#### 2.3.9 吸烟者问题

#### 2.3.10 读者写者问题

#### 2.3.11 哲学家进餐问题

#### 2.3.12 管程

### 2.4 死锁

#### 2.4.1 思索的概念

#### 2.4.2 死锁的处理策略——预防死锁

#### 2.4.3 死锁的处理策略——避免死锁

#### 2.4.4 死锁的处理策略——检测和解除

## 第三章 内存管理

### 3.1 内存管理概念

### 3.2 虚拟内存管理

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()