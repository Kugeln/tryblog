---
title: 操作系统
date: 2024-07-31 23:28:42
tags: 408专业课
sticky: 143
categories: 408
banner_img: 1920x1080 (26).jpg
index_img: 1920x1080 (26).jpg
math: true
---
## 第一章

### 1.1 操作系统的基本概念

#### 1.1.1 操作系统的概念、功能

![](/img/095405.jpg)

![](/img/213953.jpg)

##### 操作系统的概念（定义）

![](/img/094324.jpg)

##### 操作系统的功能和目标——作为系统资源的管理者

![](/img/94413.jpg)

![](/img/94501.jpg)

##### 操作系统的功能和目标——向上层提供方便易用的服务

![](/img/094636.jpg)

![](/img/094723.jpg)

![](/img/094758.jpg)

![](/img/4923.jpg)

* 相当于把一系列的命令罗列在了该清单里面，当我们执行这个bat文件的时候，操作系统根据文件当中的这些命令一条一条往后执行

![](/img/095137.jpg)

* 狭义的用户接口不包括GUI

##### 操作系统的功能和目标——作为最接近硬件的层次

![](/img/095337.jpg)

#### 1.1.2 操作系统的特征

![](/img/095540.jpg)

##### 并发

![](/img/114510.jpg)

![](/img/559.jpg)

![](/img/14618.jpg)

![](/img/23644.jpg)

![](/img/3704.jpg)

##### 共享

![](/img/123857.jpg)

##### 并发和共享的关系

![](/img/24019.jpg)

##### 虚拟

![](/img/124345.jpg)

![](/img/213151.jpg)

![](/img/213259.jpg)

##### 异步

![](/img/213919.jpg)

### 1.2 操作系统发展历程

![](/img/4238.jpg)

![](/img/4001632.jpg)

##### 手工操作阶段

![](/img/33702.jpg)

##### 批处理阶段——单道批处理系统

![](/img/001041.jpg)

![](/img/001155.jpg)

##### 批处理阶段——多道批处理系统

![](/img/001312.jpg)

##### 分时操作系统

![](/img/001428.jpg)

![](/img/01528.jpg)

##### 其他集中操作系统

![](/img/001615.jpg)

### 1.3 操作系统的运行环境

#### 1.3.1 操作系统的运行机制

![](/img/03133.jpg)

* 本节的指令指的是二进制机器指令

##### 预备知识：程序是如何运行的

![](/img/002020.jpg)

##### 内核程序vs应用程序

![](/img/02124.jpg)

##### 特权指令vs非特权指令

![](/img/002303.jpg)

##### 内核态vs用户态

![](/img/002400.jpg)

##### 内核态、用户态的切换

![](/img/02505.jpg)

![](/img/02530.jpg)

![](/img/002553.jpg)

![](/img/002721.jpg)

![](/img/02806.jpg)

![](/img/002919.jpg)

![](/img/03052.jpg)

* CPU从用户态变为内核态以后，他会停止运行当前正在运行的应用程序，转而运行一个内核程序

#### 1.3.2 中断和异常

![](/img/005706.jpg)

![](/img/11021.jpg)

##### 中断的作用

![](/img/004050.jpg)

##### 中断的类型

![](/img/04255.jpg)

![](/img/05556.jpg)

##### 内中断的例子

* 与当前执行的指令有关，中断信号来源于CPU内部

![](/img/004404.jpg)

![](/img/004425.jpg)

![](/img/004459.jpg)

![](/img/04538.jpg)

![](/img/004632.jpg)

![](/img/004656.jpg)

![](/img/004747.jpg)

* 陷入指令不是特权指令

##### 外中断的例子

![](/img/004859.jpg)

![](/img/04951.jpg)

![](/img/005022.jpg)

![](/img/005104.jpg)

![](/img/005131.jpg)

##### 中断机制的基本原理

![](/img/005648.jpg)

#### 1.3.3 系统调用

##### 什么是系统调用，有何作用

![](/img/05923.jpg)

##### 系统调用与库函数的区别

![](/img/10056.jpg)

##### 什么功能要用到系统调用

![](/img/010326.jpg)

##### 系统调用的过程

![](/img/010423.jpg)

![](/img/10543.jpg)

![](/img/10623.jpg)

![](/img/010745.jpg)

![](/img/010756.jpg)

![](/img/10942.jpg)

### 1.4 操作系统结构

![](/img/030657.jpg)

![](/img/011201.jpg)

![](/img/30757.jpg)

![](/img/030810.jpg)

##### 操作系统的内核

![](/img/11239.jpg)

![](/img/011344.jpg)

![](/img/011441.jpg)

* 有的操作系统并不把这些管理功能放在内核当中，而只在内核当中保留与硬件接触最紧密的这些部分
  * 采用微内核结构的情况下，树与内核的功能是要运行在内核态的，不属于内核的管理功能在用户态运行

![](/img/011725.jpg)

##### 操作系统的体系结构

![](/img/030550.jpg)

* 采用微内核的体系结构，应用程序向操作系统提出服务的请求，接下来操作系统的这几个模块都需要为应用程序服务
  * 而进程管理这个模块在处理应用程序的请求的时候，同样需要得到内核的支持，所以这个模块对内核的访问就涉及到了CPU从用户态转到内核态
  * 服务完成了之后，又会从内核态再转回用户态
  * 同样的，其他管理模块在完成相应的工作的时候，同样也需要得到内核的支持，因此每一个模块都需要请求内核的服务
  * 每一次请求内核的服务，都会涉及到一个cpu状态转换的过程

##### 操作系统结构——分层结构

![](/img/033234.jpg)

* 每一层只能向下调用相邻那一层的结构

![](/img/033421.jpg)

##### 操作系统结构——模块化

* 主模块就是必不可少的，最重要最核心的模块，没有这些模块，操作系统就无法运行

![](/img/3728.jpg)

##### 操作系统结构——宏内核、微内核

* 所有系统功能都放在内核里面

![](/img/33856.jpg)

##### 操作系统结构——外核

* 应用程序可以通过系统提供的这些库函数，直接调用普通内核的一些功能
  * 也可以通过库函数去调用外核所提供的一些功能

![](/img/034048.jpg)

![](/img/055954.jpg)

### 1.5 操作系统引导

![](/img/060151.jpg)

##### 安装操作系统后

![](/img/71704.jpg)

* 分区表里面记录了每一个盘每个分区分别占多大的空间，以及每个分区的地址范围

![](/img/073626.jpg)

##### 开机过程

![](/img/073542.jpg)

* BIOS是基本输入输出系统
* 自举程序（boot程序）
* RAM里面的数据只要关机断电就会清空，但是ROM里面的数据不会因为断电清空
* 执行ROM引导程序的作用就是，指示CPU去把磁盘的主引导记录读入内存
  * 读入主存后，CPU执行磁盘主引导程序，磁盘引导程序会根据分区表去判断C盘的位置，接下来就可以读入C盘的第一部分即引导记录PBR的数据
    * 然后CPU去执行这个引导记录PBR里的程序
    * PBR里的程序的主要作用是会负责找到启动管理器
    * 启动管理器程序通常存放在根目录下面的某个位置
    * 从根目录找到这个启动管理程序，然后CPU再执行这个启动管理程序
    * 接下来这个启动管理程序就会完成操作系统初始化的一系列的工作

![](/img/073847.jpg)

### 1.6 虚拟机

##### 传统计算机

![](/img/074719.jpg)

* 两个进程在同一个操作系统上，可能存在一些安全隐患
  * 二者之间可能相互影响，也会相互地争夺操作系统管理的这些资源

##### 虚拟机

* 虚拟机管理程序（VMM）
* 第一类的虚拟机管理程序，会直接运行在硬件之上，由虚拟机管理程序，会把一个物理机器虚拟化为多台虚拟机器，会把一个总的硬件资源划分为多个部分分别给各个虚拟机使用，每一台虚拟机上面，可以安装各自的操作系统，在每个操作系统之上，又可以运行各自的用户进程
* 只有虚拟机管理程序是运行在内核态的，只有它可以使用特权最高的那些指令，而上层的操作系统和应用程序，实际上是运行在用户态的
  * 因此当上层的操作系统想要使用特权指令的时候，这个行为动作会被虚拟机管理程序给截获，这个虚拟机管理程序会把上层的操作系统想要执行的这个特权指令进行等价转换，模拟出指令执行成功的效果
* 第二类的虚拟机管理程序，并不是直接运行在硬件之上，而是运行在宿主操作系统上面，这个虚拟机管理程序想要给各个虚拟机器分配硬件资源，只能请求操作系统分配，再由虚拟机管理程序进行再分配，硬件资源的管理者依旧是宿主操作系统

![](/img/80442.jpg)

###### 常用的虚拟机软件

![](/img/075501.jpg)

##### 两类虚拟机管理程序的对比

![](/img/080515.jpg)

![](/img/080706.jpg)

![](/img/080820.jpg)

##### 支持虚拟化的CPU通常分更多指令等级

![](/img/080950.jpg)

## 第二章 进程与线程

### 2.1 进程与线程

#### 2.1.1 进程的概念、组成、特征

![](/img/235330.jpg)

* 在引入了线程之后，进程就不再是接受调度的基本单位了，但是进程依然是获得资源的基本单位

##### 进程的概念 

![](/img/214526.jpg)

![](/img/214615.jpg)

##### 进程的组成——PCB

![](/img/214917.jpg)

![](/img/15002.jpg)

##### 进程的组成——程序段、数据段

![](/img/21838.jpg)

![](/img/222439.jpg)

##### 程序是如何运行的

![](/img/2127.jpg)

##### 进程的特征

![](/img/5434.jpg)

#### 2.1.2 进程的状态与转换、进程的组织

![](/img/235620.jpg)

![](/img/053946.jpg)

##### 进程的状态——创建态、就绪态

![](/img/52605.jpg)

##### 进程的状态——运行态

![](/img/52813.jpg)

![](/img/052844.jpg)

##### 进程的状态——阻塞态

![](/img/53041.jpg)

##### 进程的状态——终止态

![](/img/53127.jpg)

![](/img/53145.jpg)

##### 进程状态的转换

![](/img/3452.jpg)

![](/img/053548.jpg)

##### 进程的组织——链接方式

![](/img/053758.jpg)

![](/img/53815.jpg)

##### 进程的组织——索引方式

![](/img/053900.jpg)

##### 进程的组织

![](/img/053927.jpg)

#### 2.1.3 进程控制

![](/img/54205.jpg)

![](/img/060002.jpg)

##### 什么是进程控制

![](/img/54126.jpg)

##### 如何实现进程控制

![](/img/4233.jpg)

![](/img/054332.jpg)

![](/img/054420.jpg)

##### 如何实现原语的原子性

![](/img/54519.jpg)

![](/img/054551.jpg)

![](/img/4620.jpg)

![](/img/054648.jpg)

* 关中断指令和开中断指令是特权指令，只能让内核程序使用，不能让普通的用户程序使用

##### 进程控制相关的原语

![](/img/5100.jpg)

* 作业：此时还放在外存里面的，还没有投入运行的程序
  * 作业调度：从外存当中挑选一个程序，把它放入内存让其开始运行

![](/img/055340.jpg)

![](/img/055434.jpg)

![](/img/5536.jpg)

![](/img/055602.jpg)

![](/img/055657.jpg)

![](/img/55744.jpg)

![](/img/55822.jpg)

![](/img/55835.jpg)

![](/img/55908.jpg)

#### 2.1.4 进程通信

![](/img/060107.jpg)

![](/img/1138.jpg)

##### 什么是进程间通信

![](/img/60231.jpg)

##### 为什么进程通信需要操作系统支持

![](/img/60510.jpg)

##### 共享存储

![](/img/061839.jpg)

![](/img/062002.jpg)

![](/img/62029.jpg)

* 数据结构的共享灵活性差、速度慢
* 基于存储区的共享灵活性高、速度快

##### 消息传递

![](/img/62211.jpg)

###### 直接通信方式

![](/img/065413.jpg)

![](/img/65743.jpg)

![](/img/065811.jpg)

![](/img/065846.jpg)

###### 间接通信方式

![](/img/65939.jpg)

![](/img/070019.jpg)

![](/img/0044.jpg)

![](/img/70056.jpg)

![](/img/070207.jpg)

##### 管道通信

* 管道通信下数据流动只能是单向的
* 管道通信的情况下数据具有先进先出（FIFO）的特性
* 和共享存储的区别
  * 在共享存储方式中数据的读写很自由，没有限制
  * 管道通信下，数据读写遵从先进先出的特性
    * 固定大小的内存缓冲区本质上是循环队列

![](/img/070937.jpg)

* 半双工通信指的是同一时刻只能支持单向的传输，全双工通信是指同一时刻支持双向的传输
* 写进程往管道写数据，即便管道没被写满，只要管道没空，读进程就可以从管道读数据
* 读进程从管道读数据，即便管道没被读空，只要管道没满，写进程就可以往管道写数据

#### 2.1.5 线程的概念

##### 什么是线程，为什么要引入线程

![](/img/71503.jpg)

![](/img/72034.jpg)

* 在传统的进程机制当中，CPU会轮流地为各个进程进行服务，那么这些进程就可以并发地执行，并且每一个进程会有他自己相应的一系列程序代码，被CPU服务的时候，这些代码就可以一句一句开始往下执行
* 为了满足一个进程当中宏观上同时做很多事情，引入了线程机制，用来增加系统的并发度
  * 引入了线程之后，CPU的调度服务对象就不再是进程，而是进程当中的线程，每一个进程当中可能会包含多个线程，CPU会被轮流地，用一定算法轮流地为这些线程进行服务

![](/img/072130.jpg)

##### 线程带来的变化

![](/img/072252.jpg)

##### 线程的属性

![](/img/072400.jpg)

#### 2.1.6 线程的实现方式和多线程模型

![](/img/080551.jpg)

##### 线程的实现方式

###### 用户级线程

![](/img/072550.jpg)

![](/img/72640.jpg)

![](/img/572955.jpg)

* 用户级线程的情况下
  * 线程的管理工作由应用程序通过线程库来完成的，并不是操作系统负责的
  * 线程切换的管理是由线程库即应用程序自己完成的，在用户态下就可以完成线程的切换工作，并不需要操作系统的干涉
  * 操作系统只能看到进程的村早，不能意识到用户级线程的存在

![](/img/075411.jpg)

* 用户级线程下CPU的调度单位依然是进程

###### 内核级线程

![](/img/075745.jpg)

* 内核级线程的管理工作由操作系统完成
* 线程切换需要操作系统介入，由用户态变为内核态
* 操作系统可以意识到内核级线程的存在

![](/img/075937.jpg)

* 在多核CPU的环境下，这几个线程可以分别分派到不同的核心下并行地执行，不同的内核级线程可以跑不同的代码逻辑

###### 多线程模型

* 一对一模型

![](/img/080123.jpg)

* 多对一模型

![](/img/080236.jpg)

* 多对多模型

![](/img/080402.jpg)

* 引入内核级线程之后，一个进程可能会对应多个内核级线程，而只有所有的这些内核级线程都被阻塞的时候，我们才说这个进程进入了阻塞状态

#### 2.1.7 线程的状态与转换

##### 线程的状态与转换

![](/img/080717.jpg)

##### 线程的组织与控制

![](/img/080940.jpg)

### 2.2 CPU调度

#### 2.2.1 调度的概念、层次

![](/img/2630.jpg)

##### 调度的基本概念

![](/img/5081105.jpg)

##### 调度的三个层次——高级调度

![](/img/81157.jpg)

![](/img/081219.jpg)

##### 调度的三个层次——低级调度

![](/img/081319.jpg)

##### 调度的三个层次——中级调度

![](/img/081358.jpg)

![](/img/081443.jpg)

##### 进程的挂起态与七状态模型

![](/img/082227.jpg)

* 一个处于就绪态的进程，如果此时系统的负载比较高，内存空间已经不够用，就可能把一个处于就绪态的进程暂时调到外存当中，然后该进程就进入了一个就绪挂起的状态。
  * 一直到内存空间空闲或者这个进程又需要继续执行，那么这个进程又会被激活，把它的数据又挪回到内存当中。这样一个就绪挂起的进程又回到了就绪态
* 一个阻塞态的进程也可以被挂起，相应的也可以再重新被调入内存，进行激活，重新回到阻塞态
* 有的操作系统有可能会使一个处于阻塞挂起的进程，当他等待的阻塞事件发生的时候，这个进程就会直接进入到一个就绪挂起的状态，然后之后当他再被重新调回内存的时候，是直接回到就绪态而非阻塞态
* 有的死后一个进程处于运行态，运行结束后，可能这个进程下处理机的时候，可能就会被直接放到外存当中，让他进入就绪挂起的状态
* 有的时候一个处于创建态的进程，当他创建结束之后，创建完PCB之后，有可能出现内存空间不够的情况，这种情况下有可能处于创建态的进程之后会先进入到一个就绪挂起的状态

##### 三层调度的联系、对比

* 高级调度是面向作业的调度
  * 一个作业在刚开始会被调入一次被调出一次，并且作业调入的时候，会为这个作业建立相应的PCB，也就是建立它相应的进程
* 中级、低级调度是面向进程的调度
  * 中级调度是把暂时不会运行的进程相关的一些数据调到外存里

![](/img/082548.jpg)

#### 2.2.2 进程调度的时机、切换与过程、方式

![](/img/085245.jpg)

##### 进程调度的时机

![](/img/82841.jpg)

![](/img/083559.jpg)

* 各个进程只能互斥地进入临界区，互斥地执行访问临界资源的代码

![](/img/083647.jpg)

![](/img/083728.jpg)

![](/img/083740.jpg)

![](/img/84939.jpg)

##### 进程调度的方式

![](/img/85053.jpg)

##### 进程的切换与过程

![](/img/85211.jpg)

#### 2.2.3 调度器与闲逛进程

##### 调度器/调度程序

![](/img/085523.jpg)

![](/img/85553.jpg)

##### 闲逛进程

![](/img/085644.jpg)

#### 2.2.4 调度算法的评价指标

![](/img/5713.jpg)

![](/img/90409.jpg)

##### CPU利用率

![](/img/085839.jpg)

##### 系统吞吐量

![](/img/085910.jpg)

![](/img/090001.jpg)

##### 周转时间

![](/img/090117.jpg)

* 带权周转时间表示的是这个进程的整个周转时间比运行时间大多少倍

##### 等待时间

![](/img/90256.jpg)

* 平均等待时间就是把所有进程或者作业的等待时间做一个加和再除以作业的数量

##### 响应时间

![](/img/90348.jpg)

#### 2.2.5 调度算法

![](/img/090528.jpg)

![](/img/92717.jpg)

![](/img/04721.jpg)

##### 先来先服务

![](/img/091037.jpg)

* 后备队列在外存当中

![](/img/090847.jpg)

##### 短作业优先

![](/img/092025.jpg)

###### 非抢占式的短作业优先算法

![](/img/091305.jpg)

![](/img/091230.jpg)

###### 抢占式的短作业优先算法

![](/img/091505.jpg)

![](/img/91631.jpg)

* 采用了抢占式的短作业优先之后得到的平均周转、平均带权周转、平均等待时间这三个指标比非抢占式的还要更小

![](/img/91923.jpg)

##### 对FCFS和SJF两种算法的思考

![](/img/92117.jpg)

##### 高响应比优先

![](/img/2421.jpg)

![](/img/092323.jpg)

##### 时间片轮转

![](/img/102629.jpg)

![](/img/093005.jpg)

![](/img/93030.jpg)

![](/img/093053.jpg)

![](/img/93133.jpg)

![](/img/093217.jpg)

![](/img/093247.jpg)

![](/img/093326.jpg)

![](/img/02047.jpg)

![](/img/102132.jpg)

![](/img/102159.jpg)

![](/img/02316.jpg)

![](/img/02440.jpg)

![](/img/02536.jpg)

![](/img/102600.jpg)

##### 优先级调度算法

![](/img/103411.jpg)

![](/img/03011.jpg)

![](/img/103128.jpg)

![](/img/03326.jpg)

##### 多级反馈队列调度算法

![](/img/04421.jpg)

![](/img/103618.jpg)

![](/img/641.jpg)

![](/img/103718.jpg)

![](/img/03746.jpg)

![](/img/103822.jpg)

![](/img/3846.jpg)

![](/img/103911.jpg)

![](/img/03924.jpg)

![](/img/103947.jpg)

![](/img/04050.jpg)

![](/img/04118.jpg)

![](/img/104136.jpg)

##### 多级队列调度算法

![](/img/105022.jpg)

### 2.3 同步与互斥

#### 2.3.1 进程同步、进程互斥

![](/img/110231.jpg)

* 进程同步又可以称之为进程之间的直接制约关系，进程之间是有直接的合作的
* 进程互斥又可以称作为进程之间的间接制约关系，因为进程之间并没有直接的合作关系，他们之间只是因为想要互斥地使用某一种系统临界资源，所以才会产生这种制约关系

##### 什么是进程同步

![](/img/05639.jpg)

![](/img/5731.jpg)

##### 什么是进程互斥

![](/img/05827.jpg)

![](/img/10045.jpg)

![](/img/0209.jpg)

#### 2.3.2 进程互斥的软件实现方法

![](/img/135908.jpg)

![](/img/192057.jpg)

* 单标志法的精髓在于用一个turn的变量来表示谦让这个动作
* 双标志法的精髓在于用一个flag数组来表示自己想要进入临界区的一个意愿
* peterson算法结合了双标志法和单标志法思想的精髓，每个进程在进入区当中都会先主动地争取和表达自己想要进入临界区的意愿，同时又主动地做出谦让的动作

##### 如果没有注意进程互斥

![](/img/140046.jpg)

##### 单标志法

![](/img/140235.jpg)

![](/img/40344.jpg)

##### 双标志先检查法

![](/img/190252.jpg)

![](/img/90458.jpg)

##### 双标志后检查法

![](/img/0729.jpg)

![](/img/1037.jpg)

##### peterson算法

![](/img/91606.jpg)

![](/img/1842.jpg)

![](/img/192040.jpg)

* 让权等待指的是，当进程进不了临界区，就应该立即释放处理机资源，而不应该继续在CPU上跑

#### 2.3.3 进程互斥的硬件实现方法

![](/img/15432.jpg)

##### 中断屏蔽方法

![](/img/10418.jpg)

* 关中断指令只对执行关中断指令的那个处理机有用，因此有可能发生两个处理机上的两个进程同时对临界区进行访问的情况

##### test and set指令

![](/img/210756.jpg)

* 在TSL循环中，如果lock本来就是true，即临界区本来就是被上锁的，那么他返回来的old的这个值也会为true，while这个循环就会一直循环下去
  * 一直到lock这个值被当前访问临界区的那个进程在退出区改成了false，那么testandset返回来的old值变为了false
  * 于是之前一直被卡在while循环的进程就可以跳出这个循环，然后正式地开始访问临界区的代码段，一直到访问结束之后再把自己上的锁给解除

##### swap指令

![](/img/215402.jpg)

* old记录原来的lock值，swap交换之后，以前的lock的值会放在old里面，old本来是true，true这个值又会被设置到lock里面
  * 之后while循环会检查以前的lock值是否为true，如果old值为true（即原lock为true），说明在之前这个临界区就已经被上锁了，那么这个循环会一直循环下去，一直到old为false，说明之前这个临界区是没有被上锁的状态，那么就会跳出这个循环，顺利地进入临界区访问这些代码段

#### 2.3.4 互斥锁

![](/img/223447.jpg)

##### 进程互斥：锁

* 锁相当于一个bool型变量，当变量为true，说明已经上锁，变量为false，说明没有上锁

![](/img/15820.jpg)

* 缺点：锁都有忙等的问题，违反让权等待原则，一直占用cpu资源
  * 一个进程在忙等，暂时进不了临界区，并不会一直占用处理机，如果这个进程的时间片用完，调度程序依旧会让他下处理机

![](/img/20924.jpg)

* 多核处理器系统中一个核的运算能力可能会被吃掉在忙等，但其他核可以照常工作，并且快速释放临界区
* 单处理机系统下，进程吃掉了唯一的核，只有他的时间片用完并且上锁的那个进程上处理机解锁之后，才有可能获得这个锁

#### 2.3.5 信号量机制

![](/img/221157.jpg)

##### 信号量机制

![](/img/222232.jpg)

##### 整型信号量

![](/img/222509.jpg)

##### 记录型信号量

![](/img/222807.jpg)

* 如果value--之后value的值小于0，说明在这之前已经没有空闲资源分配给申请的进程
* 如果value++之后value的值小于等于0，说明在这个进程释放这个资源之前，依然还有一些进程是处于等待队列的

![](/img/222944.jpg)

![](/img/23038.jpg)

![](/img/23058.jpg)

![](/img/23223.jpg)

![](/img/223354.jpg)

#### 2.3.6 用信号量实现进程互斥、同步、前驱关系

![](/img/3555.jpg)

![](/img/004255.jpg)

* 每年至少1个大题

##### 信号量机制实现进程互斥

* 系统中的某些资源是比须互斥访问的，而访问这种系统资源的那段代码叫做临界区

![](/img/234639.jpg)

* 如果题目没有特别说明的话，我们对一个信号量的定义，只需要写semaphore mutex=多少即可，并不需要写出这个信号量的数据结构
* 只要用semaphore这个关键字来开头的话，就意味着这个信号量不是整型信号量，而是记录型信号量，也就是说这个信号量是带有排队阻塞功能的，并不会忙等

##### 信号量机制实现进程同步

![](/img/35208.jpg)

![](/img/000806.jpg)

##### 信号量机制实现前驱关系

![](/img/04124.jpg)

#### 2.3.7 生产者-消费者问题

![](/img/005943.jpg)

##### 问题描述

![](/img/6004431.jpg)

![](/img/6004559.jpg)

* 当一个消费者从缓冲区取走数据之后，如果此时有生产者是处于阻塞状态的，那么消费者进程应该把生产者进程给唤醒，让他重新回到就绪态

![](/img/04625.jpg)

![](/img/004704.jpg)

##### 问题分析

![](/img/021344930.jpg)

* 消费者消费同步关系中，P操作实际上是在申请一个产品，同步信号量对应的资源应该是产品的数量，也就是非空缓冲区的数量

![](/img/05225.jpg)

##### 如何实现

* 生产者进程在把产品放入缓冲区之前，需要申请一个空闲的缓冲区，因此当它放入产品之前，需要对empty这个同步信号量执行一个p操作
* P是消耗，V是增加

![](/img/005535.jpg)

![](/img/005516.jpg)

##### 思考：能否改变相邻P、V操作的顺序

![](/img/05739.jpg)

* 逻辑上看使用和生产产品的指令可以放在PV操作中间，但这样做会导致临界区代码更长，即一个进程对临界区上锁的时间变得更长，不利于各个进程交替地使用临界区资源

#### 2.3.8 多生产者-多消费者问题

![](/img/10958.jpg)

![](/img/10958.jpg)

![](/img/011217.jpg)

##### 问题描述

![](/img/010111.jpg)

* 多消费者的多不是指数量而是指类别
* 一说P是测试，V是增加

##### 问题分析

![](/img/10338.jpg)

##### 如何实现

![](/img/010542.jpg)

![](/img/010729.jpg)

![](/img/010831.jpg)

![](/img/10916.jpg)

#### 2.3.9 吸烟者问题

![](/img/12008.jpg)

##### 问题描述

![](/img/11444.jpg)

##### 问题分析

![](/img/011631.jpg)

![](/img/011730.jpg)

##### 如何实现

![](/img/11913.jpg)

#### 2.3.10 读者写者问题

![](/img/14522.jpg)

* 第一个读者进程会对共享资源上锁，而当最后一个读者读完文件之后，会对共享文件进行一个解锁

##### 问题描述

![](/img/06012139.jpg)

![](/img/12338.jpg)

##### 问题分析

![](/img/12440.jpg)

##### 如何实现

![](/img/13758.jpg)

![](/img/013847.jpg)

![](/img/14000.jpg)

![](/img/6014157.jpg)

![](/img/014316.jpg)

#### 2.3.11 哲学家进餐问题

![](/img/15607.jpg)

##### 问题描述

![](/img/14702.jpg)

##### 问题分析

![](/img/14743.jpg)

![](/img/014922.jpg)

##### 如何实现

![](/img/014956.jpg)

![](/img/5057.jpg)

![](/img/015152.jpg)

![](/img/015233.jpg)

![](/img/015257.jpg)

![](/img/015357.jpg)

![](/img/015511.jpg)

#### 2.3.12 管程

![](/img/20817.jpg)

##### 为什么要引入管程

![](/img/015739.jpg)

##### 管程的定义和基本特征

![](/img/020132.jpg)

* 管程当中定义的这些共享的数据结构，只能被管程当中定义的这一些函数所修改

##### 拓展1：用管程解决生产者消费者问题

![](/img/020352.jpg)

![](/img/20451.jpg)

![](/img/20514.jpg)

![](/img/20705.jpg)

##### 拓展2：JAVA中类似于管程的机制

![](/img/020741.jpg)

### 2.4 死锁

#### 2.4.1 死锁的概念

![](/img/31108.jpg)

##### 什么是死锁

![](/img/021311.jpg)

![](/img/21406.jpg)

##### 死锁、饥饿、死循环的区别

![](/img/021647.jpg)

* 死锁和饥饿肯定不会是运行态

##### 死锁产生的必要条件

![](/img/021851.jpg)

##### 什么时候会发生死锁

![](/img/1005.jpg)

##### 死锁的处理策略

![](/img/31042.jpg)

#### 2.4.2 死锁的处理策略——预防死锁

![](/img/31257.jpg)

![](/img/032250.jpg)

##### 破坏互斥条件

![](/img/031510.jpg)

![](/img/031521.jpg)

![](/img/031608.jpg)

##### 破坏不剥夺条件

![](/img/031833.jpg)

##### 破坏请求和保持条件

![](/img/32006.jpg)

##### 破坏循环等待条件

![](/img/032215.jpg)

#### 2.4.3 死锁的处理策略——避免死锁

![](/img/32327.jpg)

![](/img/34031.jpg)

##### 什么是安全序列

![](/img/32507.jpg)

![](/img/032515.jpg)

![](/img/55234429.jpg)

![](/img/032617.jpg)

![](/img/32634.jpg)

![](/img/032650.jpg)

##### 安全序列、不安全状态、死锁的联系

![](/img/32950.jpg)

* 进入不安全状态未必发生死锁，但如果发生了死锁，一定是处于不安全状态

##### 银行家算法

![](/img/3054.jpg)

![](/img/3139.jpg)

![](/img/33220.jpg)

![](/img/033309.jpg)

###### 实际做题手算的快速方法

* 找得到安全序列的情况

![](/img/033407.jpg)

![](/img/33431.jpg)

* 找不到安全序列的情况

![](/img/033521.jpg)

![](/img/33556.jpg)

###### 用代码实现银行家算法

![](/img/033920.jpg)

#### 2.4.4 死锁的处理策略——检测和解除

![](/img/034115.jpg)

![](/img/035457.jpg)

##### 死锁的检测

![](/img/034305.jpg)

![](/img/4402.jpg)

* 结束了归还资源相当于把边拆了

![](/img/34520.jpg)

![](/img/34620.jpg)

###### 检测死锁的算法

![](/img/4851.jpg)

* 不阻塞是说这个进程申请的这些资源的数量足够满足它的需求
  * 图中p1是不阻塞进程，p2是阻塞进程
* 不是孤点指的是与这个进程至少有一个边相连

![](/img/034911.jpg)

![](/img/34935.jpg)

##### 死锁的解除

![](/img/35411.jpg)

* 优先级低的优先牺牲
  * 执行时间越长，说明让其回退或者撤销的代价越高，所以一般选择执行时间较短的进程进行牺牲
  * 优先让马上结束的进程优先获得资源
  * 优先把拥有更多资源的进程牺牲
  * 优先牺牲批处理式的进程

## 第三章 内存管理

### 3.1 内存管理概念

#### 3.1.1 内存的基础知识

![](/img/0440.jpg)

![](/img/043300.jpg)

##### 内存的定义和作用

![](/img/040710.jpg)

![](/img/040806.jpg)

##### 指令的工作原理

![](/img/041024.jpg)

![](/img/41126.jpg)

![](/img/041217.jpg)

##### 装入的三种方式

###### 绝对装入

![](/img/641414.jpg)

###### 静态重定位（可重定位装入）

![](/img/1536.jpg)

###### 动态重定位（动态运行时装入）

![](/img/06041605.jpg)

![](/img/041737.jpg)

##### 从写程序到程序运行

![](/img/041852.jpg)

##### 链接的三种方式

###### 静态链接

![](/img/041942.jpg)

###### 装入时动态链接

![](/img/042022.jpg)

###### 运行时动态链接

![](/img/3216.jpg)

#### 3.1.2 内存管理的概念

![](/img/044056.jpg)

##### 内存空间的分配与回收

![](/img/43423.jpg)

##### 内存空间的扩展

![](/img/3514.jpg)

##### 地址转换

![](/img/043613.jpg)

![](/img/043715.jpg)

* 绝对装入由编译器而非操作系统完成

##### 内存保护

![](/img/043807.jpg)

![](/img/905.jpg)

![](/img/044110.jpg)

#### 3.1.3 覆盖与交换

![](/img/044148.jpg)

![](/img/045155.jpg)

* 一般来说只会在选择题中考察

##### 覆盖技术

![](/img/044343.jpg)

![](/img/4525.jpg)

##### 交换技术

![](/img/6044622.jpg)

![](/img/4639.jpg)

![](/img/044653.jpg)

![](/img/44722.jpg)

![](/img/044836.jpg)

![](/img/045021.jpg)

#### 3.1.4 连续分配管理方式

![](/img/45310.jpg)

![](/img/45423.jpg)

![](/img/051217.jpg)

##### 单一连续分配

* 并不支持多道程序并发运行

![](/img/45423.jpg)

![](/img/45540.jpg)

##### 固定分区分配

![](/img/045653.jpg)

![](/img/45800.jpg)

![](/img/045925.jpg)

##### 动态分区分配（可变分区分配）

![](/img/50211.jpg)

![](/img/50253.jpg)

![](/img/050324.jpg)

![](/img/050408.jpg)

![](/img/050437.jpg)

![](/img/050500.jpg)

![](/img/50509.jpg)

![](/img/50520.jpg)

![](/img/50528.jpg)

![](/img/050539.jpg)

![](/img/50600.jpg)

![](/img/050801.jpg)

![](/img/50816.jpg)

![](/img/51027.jpg)

![](/img/51056.jpg)

![](/img/051110.jpg)

#### 3.1.5 动态分区分配算法

![](/img/051330.jpg)

![](/img/053408.jpg)

* 很可能作为选择题考察，甚至会作为大题进行考察

##### 首次适应算法

![](/img/1423.jpg)

![](/img/051444.jpg)

![](/img/51539.jpg)

![](/img/051638.jpg)

##### 最佳适应算法

![](/img/51845.jpg)

![](/img/051925.jpg)

![](/img/1942.jpg)

![](/img/52031.jpg)

##### 最坏适应算法

![](/img/52115.jpg)

![](/img/52332232159.jpg)

![](/img/052233.jpg)

![](/img/052934534506.jpg)

##### 邻近适应算法

![](/img/53012.jpg)

![](/img/53103.jpg)

![](/img/53141.jpg)

![](/img/53154.jpg)

![](/img/053310.jpg)

#### 3.1.6 基本分页存储管理的概念

![](/img/053516.jpg)

![](/img/162637.jpg)

##### 什么是分页存储

![](/img/053742.jpg)

![](/img/53833.jpg)

##### 重要的数据结构——页表

![](/img/54115.jpg)

* 页面是虚拟的逻辑空间，而页框是内存块的区域

###### 每个页表占多少字节

![](/img/54410.jpg)

* 先计算内存块会被分为几个页框
  * 页框大小=页面大小
  * 页框数量=物理内存大小空间/页框大小

![](/img/4516.jpg)

![](/img/054625.jpg)

###### 如何实现地址的转换

![](/img/0723.jpg)

![](/img/60838.jpg)

![](/img/61835.jpg)

* 页号=逻辑地址/页面长度（取除法的整数部分）
* 页内偏移量=逻辑地址%页面长度（取除法的余数部分）

![](/img/2039.jpg)

![](/img/236.jpg)

![](/img/62253.jpg)

##### 逻辑地址结构

![](/img/62419.jpg)

#### 3.1.7 基本地址变换机构

![](/img/2707.jpg)

![](/img/163846.jpg)

* 既有可能作为选择题也有可能作为大题进行考察

##### 基本地址变换机构

* 逻辑地址转换为物理地址的几个要素
  * 知道逻辑地址对应的页号
  * 知道逻辑地址对应的页内偏移量
  * 知道逻辑地址对应的页面在内存当中存放的位置
  * 根据页面在内存当中的起始位置和页内偏移量得到最终的物理地址

![](/img/162937.jpg)

![](/img/63033.jpg)

![](/img/163153.jpg)

![](/img/163347.jpg)

![](/img/163401.jpg)

![](/img/63544.jpg)

##### 对页表项大小的进一步探讨

![](/img/3657.jpg)

![](/img/3721.jpg)

![](/img/163738.jpg)

#### 3.1.8 具有快表的地址变换机构

![](/img/63916.jpg)

![](/img/12364957.jpg)

##### 什么是快表

![](/img/164148.jpg)

![](/img/164514.jpg)

* 快表是专门的硬件，当进程切换的时候，快表的内容也需要被清除

##### 引入快表后，地址的变换过程

![](/img/64742.jpg)

![](/img/2314421364820.jpg)

##### 局部性原理

![](/img/164922.jpg)

#### 3.1.9 两级页表

![](/img/185549.jpg)

##### 单级页表存在的问题

![](/img/170557.jpg)

##### 如何解决单级页表的问题

![](/img/171247.jpg)

![](/img/184003.jpg)

##### 两级页表的原理、地址结构

![](/img/174120.jpg)

![](/img/74216.jpg)

* 这里的二级页表相当于页表的逻辑地址

![](/img/180204.jpg)

![](/img/180337.jpg)

##### 需要注意的几个细节

![](/img/85458.jpg)

#### 3.1.10 基本分段存储管理方式

![](/img/224147.jpg)

##### 分段

![](/img/000.jpg)

* 用户编程的时候使用的是段名，在cpu具体执行的时候，使用的是段号这个参数

![](/img/92352.jpg)

##### 段表

![](/img/22915.jpg)

![](/img/2948.jpg)

##### 地址变换

![](/img/23208.jpg)

!![](/img/223509.jpg)

![](/img/223811.jpg)

##### 分段、分页管理的对比

![](/img/223912.jpg)

![](/img/000.jpg)

![](/img/224046.jpg)

![](/img/224123.jpg)

#### 3.1.11 段页式管理方式

![](/img/31906.jpg)

##### 分页、分段的优缺点分析

![](/img/224321.jpg)

![](/img/224336.jpg)

##### 分段+分页=段页式管理

![](/img/24503.jpg)

##### 段页式管理的逻辑地址结构

![](/img/25008.jpg)

* 段式管理中地址结构是二维的，页式管理中地址结构是一维的

##### 段表、页表

![](/img/231523.jpg)

* 一个进程会对应一个段表，但一个进程可能对应多个页表

![](/img/231733.jpg)

### 3.2 虚拟内存管理

#### 3.2.1 虚拟内存的基本概念

![](/img/232813.jpg)

##### 传统存储管理方式的特征、缺点

![](/img/32110.jpg)

##### 虚拟内存的定义和特征

![](/img/232232.jpg)

![](/img/232259.jpg)

##### 如何实现虚拟内存技术

![](/img/232725.jpg)

* 这里的请求掉调页和页面置换对应的是分页存储管理方式，如果采用分段式存储管理，则需要请求调段和段置换功能

#### 3.2.2 请求分页管理方式

![](/img/232901.jpg)

##### 页表机制

![](/img/233027.jpg)

##### 缺页中断机构

![](/img/33138.jpg)

![](/img/233219.jpg)

![](/img/233234.jpg)

![](/img/33251.jpg)

![](/img/23332207.jpg)

![](/img/23342251.jpg)

##### 地址变换机构

![](/img/33548.jpg)

![](/img/233620.jpg)

![](/img/233714.jpg)

* 红框内是请求分页管理方式和分页管理方式相比增加的部分和内容

![](/img/33952.jpg)

![]()

![]()

![]()

![]()

#### 3.2.3 页面置换算法

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

#### 3.2.4 页面分配策略、抖动、工作集

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

#### 3.2.5 内存映射文件

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

## 第四章 文件管理

### 4.1 文件系统基础

![]()

![]()

![]()

![]()

![]()

![]()

![]()

### 4.2 目录

### 4.3 文件系统

## 第五章 输入/输出（I/O）管理

### 5.1 I/O管理概述

### 5.2 设备独立性软件

### 5.3 磁盘和固态硬盘