---
title: 操作系统大题强化
date: 2025-06-12 17:50:46
tags: 408日常
sticky: 269
banner_img: /img/1920x1080 (40).jpg
index_img: /img/1920x1080 (40).jpg
---

## PV操作大题总结

![](/img/WREC.png)

### PV操作常见的考法

![](/img/jmhtgbrsfvadcs.png)

* 生产者消费者问题
  * 一类进程负责生产资源，另一类进程负责消费资源
* 理发师问题：
  * 一类进程负责生产服务，另一类资源负责消费服务
* 读者写者问题：
  * 同类不互斥，异类互斥
* 哲学家进餐问题：
  * 只有一类进程，每个进程需要同时拥有多种资源才能运行
  * 核心问题是解决思索，如何让每个进程持有多种资源去运行，同时还不造成这种循环等待的死锁
* 单纯的同步问题：
  * 前驱后继图

### 生产者—消费者问题

![](/img/grefasdf.png)

![](/img/yhstrae.png)

* 进程→动作→PV同步→PV互斥缓冲区→信号量→死锁
* 1、分析有几类进程
  * 每类进程对应一个函数
  * 具体有几类进程得看这些进程需要做的动作完全一致，就属于同一进程，如果要做的动作不完全一致，那就属于不同类的进程
* 2、在每个函数内部分析，用中文描述各类进程的动作是什么
  * 动作有两种：
    * 只做一次？
      * 不加while
    * 不断重复？
      * 加while（1）
* 3、依次分析每一类动作之前，是否需要P什么？
  * 先确定P操作，在哪些地方需要P一个资源
    * 这些动作需不需要等待某一事情的发生才能进行，那么在这种动作之前，需要P一种资源（有没有可能因为什么资源不到位而导致这个动作被阻塞）
      * 不需要等待某件事情的发生就能够进行，那么在该动作之前不需要P操作
  * 再想办法去思考这个V操作，只要有P必有V，每写一个P，就要安排V，这个V操作应该安排在什么位置
    * 也就是前面P操作申请的某种资源在哪里会得到释放，在对应的动作后面加入V操作
  * 注意隐含的互斥（eg：缓冲区访问需要加P（mutex））
    * 缓冲区需要互斥访问，p1写的时候p2不能读
    * 访问前p（mutex）访问后v（mutex），保证对缓冲区的互斥访问
    * 如果需要把产品放到某个地方或者说某个缓冲区（所有用于存放零件存放产品的这些东西，都把他视为所谓的缓冲区），那么就需要加P（mutex）和V（mutex）
      * 互斥信号量的初始值=1
* 4、所有PV写完后，再去定义信号量，定义完再思考每个信号量的初值是多少？
* 5、检查多个P连续出现的地方，是否可能产生死锁？
  * 可以尝试调整P顺序，若某信号量P、V操作总时连续出现，中间没有夹其他P，则不可能因此产生死锁
  * 同步问题和互斥问题同时出现的时候，要确保互斥锁P的操作在同步的P操作的后面，同步操作把互斥操作包含在内
  * 死锁产生的条件：请求和保持
    * 手里面持有资源的同时在等待新的资源
    * 一般来说缓冲区的互斥访问PV里面没有夹杂其他PV操作，所以一般来说互斥访问缓冲区的PV操作不会产生死锁
* 6、读题检查，是否满足题目要求

#### 习题带练

##### 1

![](/img/thsagrfd.png)

![](/img/rstfvds.png)

##### 2

* 第一种思路

![](/img/gaerds.png)

![](/img/aergds.png)

* 第二种思路

![](/img/IMG_4575.jpg)

环形缓冲区：按照环形有序的序列去放产品

![](/img/IMG_4576.jpg)

![](/img/IMG_4577.jpg)

![](/img/IMG_4579.jpg)

实现方式：利用循环队列，队头队尾取数存数
in：队尾指针，进队前移
out：队头指针，出队前移

![](/img/IMG_4580.jpg)

在环形缓冲区的条件下，生产者进程所访问的位置一定是in指针所指的位置，消费者进程所访问的位置一定是out指针所指的位置，因此生产者进程和消费者进程就不可能同时访问同一个缓冲区，这就打破了经典的生产者消费者问题里面的限制，即生产者和消费者对于缓冲区的互斥访问，生产者进程和消费者进程可以同时访问缓冲区

![](/img/IMG_4581.jpg)

互斥关系变成了生产者之间，消费者之间，各自的互斥访问，而生产者和消费者之间不再互斥。程序的并发度提高。

![](/img/IMG_4582.jpg)

![](/img/IMG_4583.jpg)

因为in和out指针指向的是缓冲区的位置，我们改变的in和out指针其实就相当于改变缓冲区，因此对in和out指针改变的操作应该用互斥信号量进行控制

![](/img/IMG_4584.jpg)

并不是代表缓冲区有10个产品才可以开始取，就算缓冲区只有一个产品，此时消费者进程也可以开始取产品，只不过取完一个产品之后，需要等生产者进程继续往里面放产品，然后消费者进程才可以接着取

![](/img/IMG_4585.jpg)

##### 3

![](/img/iutyjthrsge.png)

![](/img/htrsfsd.png)

### 哲学家问题

![](/img/dhgsfdss.png)

* 1、限制申请资源的顺序（解法一不通用，不建议使用）
  * 如：规定单号哲学家先取左筷子，双号先取右筷子
    * 破坏了请求和保持这个条件
* 2、限制并发进程数量（解法二通用，但并发度不高，不建议使用）
  * 如：规定同一时间只能有一个哲学家就餐（禁止并行）
* 3、让进程一口气取得所有资源，再开始运行（通用，且并发度高，建议使用）
  * 如：哲学家只有能够取得两个筷子时才会就餐
* 第二种和第三种解决方法的区别：
  * 第二种可能出现尚未就餐的哲学家部分占有资源而等待用餐哲学家释放所需资源的情况，而第三种则不可能出现部分占有，要么全拿要么一个都没有
* 一类进程需要同时持有多种资源才能正常往下运行
* 哲学家问题大概率出现防止死锁的题眼

#### 哲学家问题模板

![](/img/iuynhtbgrvfd.png)

* 用int型变量定义各类资源，在每一个进程开始做事之前，一口气把所有的资源都拿到手，然后再开始做他该做的事情，做完这些事情之后，再一口气归还所有的资源。
  * 这样可以确保死锁不发生，也可以确保进程和进程之间的并发度

![](/img/iuynhtbgrvfd.png)

* 表示资源的常用方法：

  * 模板1：用int变量表示资源（并发度高）

    * ①定义大锁

      * semephore lock=1
        * 互斥信号量
        * 所有哲学家进程在获取资源之前都需要先获取这个大锁
        * 保证获取这些资源是互斥进行的

    * ②定义资源数int

      * 如：有a、b、c三类资源，分别有9个、8个、5个，定义3个int变量
        * int a=9;
          * 表示a的剩余数量
        * int b=8;
          * 表示b的剩余数量
        * int c=5;
          * 表示c的剩余数量

    * ③写代码模板：

      * 一口气拿所有资源

      ```c++
      Process(){
      while(1){//不断轮询去检查资源够不够
      	p(lock);//上锁，同一时刻只有一个哲学家进程去检查这些资源够不够，也就是确保每个哲学家对于各种资源的访问是互斥的，不会同时去访问这些变量
          if(所有资源都够){//ifa>=3 &&b>=2(假如需要3个a，2个b)
          	所有资源int值减少;//题目会告诉你每类资源要几个，需要多少减多少
              取xxx资源;//一口气拿走所有资源
              V(lock);//拿完资源，解锁
              break;//跳出while循环，到第4个步骤
          }
          v(lock);//资源不够，解锁，再循环尝试一次，直到if的条件成立，才进入if内最后到break跳出循环
      
      }//while结束
      }
      ```

    * ④做进程该做的事（如：哲学家干饭）

      * 用中文说明即可
      * 到这一步进程所需要的所有资源都已经够了

    * ⑤一口气归还所有资源

      ```c++
      P(Lock);
      归还所有资源，所有资源int值增加;
      V(Lock);
      ```

    * 并发度问题：

      * 这种情况下进程的并发度一定是很高的，比如有p1p2p3p4进程，都在轮询检查资源够不够
        * p1检查了一段时间后时间片用完，处理机调度（CPU调度）切换成另一个进程上CPU运行，也会while循环检查
        * 此时如果另一个进程p5释放了资源，那p2就能一口气获得所需要的资源
        * 因此这种while循环不会让一个进程无限制地占用处理机，因为操作系统有CPU调度这个功能
        * 所以一个进程运行了若干个时间片之后，会下处理及运行，虽然这个进程没有被阻塞，但是会下处理机，然后调度另一个进程继续执行，所有进程等待资源的时候都在轮询检查，直到能够一口气获取所有资源，这样进程的并发度就能够得到保证

  * 模板2：每一类资源对应一种信号量

    * 为了确保可以一口气拿走所有资源，可以用一个mutex，先p（mutex）然后p所有资源，再v（mutex）
    * 并发度不高，剩余资源足够的可能因为mutex取不到导致并发度不高

#### 习题带练

##### 1

![](/img/tsrfdg.png)

![](/img/220654.jpg)

### 单纯的同步问题

* 前V后P，每一对前驱后继关系中间定义一个信号量（暴力）

![](/img/jsrthargd.png)

#### 习题带练

##### 1

![](/img/uythrgeafw.png)

![](/img/214750.jpg)

##### 2

![](/img/thrrdsa.png)

![](/img/215009.jpg)

### 理发师问题

#### 理发师问题和生产者消费者问题的区别

![](/img/fdbdzb.png)

* 生产者消费者问题
  * A进程生产数据，数据会放到缓冲区里
  * B进程会从缓冲区里取走数据
  * 二者一个生产资源一个消费资源

* 理发师问题

  * 没有明显的生产资源消费资源的关系
  * 服务和被服务的关系

* 思路

  * 顾客（被服务）
    * 如何用代码表示”取号“动作？
    * 是否有”等位区座位上限“？

  ```c++
  //顾客
  int waiting=0;//当前有多少个顾客正在等待被服务（已取号但未被服务的顾客）
  semaphore mutex=1;//用互斥变量保证对waiting变量的互斥访问
  semaphore service=0;//服务信号量，特殊的生产者消费者关系
  customer_i(){//因为被服务一次即完成，所以不用循环
      p(mutex);//互斥访问waiting，上锁
      取号;
      waiting ++;
      v(mutex);//解锁
      等待被叫号;
      p(service);//因为需要申请一个服务才能够被服务，所以需要p一种资源
      被服务;
      
  }
  ```

  * 服务人员（提供服务）
    * 如何用代码表示”叫号“？
    * 没有顾客时，应该”忙等“or”睡觉“？
      * 睡觉：p操作阻塞
      * 忙等：while循环

  ```c++
  //服务人员
  int waiting=0;//当前有多少个顾客正在等待被服务
  semaphore mutex=1;//用互斥变量保证对waiting变量的互斥访问
  semaphore service=0;//服务信号量，特殊的生产者消费者关系
  server_j(){
      while(1){//不停服务，所以要循环
         p(mutex);//互斥访问waiting,上锁
      if(waiting>0){//有顾客在等待
          
          叫号;
          waiting --;
          v(mutex);//解锁
          v(service);//提供一个服务
          提供服务;
      }
      else{
          v(mutex);//在无顾客的时候也要解锁
          
      	}//else end
  	}//while end
  }
  ```

  * 总结

    **顾客无等位区需求，服务人员忙等的情况**

  ```c++
  int waiting=0;//当前有多少个顾客正在等待被服务（已取号但未被服务的顾客）
  semaphore mutex=1;//用互斥变量保证对waiting变量的互斥访问
  semaphore service=0;//服务信号量，特殊的生产者消费者关系
  //顾客
  customer_i(){//因为被服务一次即完成，所以不用循环
      p(mutex);//互斥访问waiting，上锁
      取号;
      waiting ++;
      v(mutex);//解锁
      等待被叫号;
      p(service);//因为需要申请一个服务才能够被服务，所以需要p一种资源
      被服务;
      
  }
  //服务人员
  server_j(){
      while(1){//不停服务，所以要循环
         p(mutex);//互斥访问waiting,上锁
      if(waiting>0){//有顾客在等待
          
          叫号;
          waiting --;
          v(mutex);//解锁
          v(service);//提供一个服务
          提供服务;
      }
      else{
          v(mutex);//在无顾客的时候也要解锁
          
      	}//else end
  	}//while end
  }
  ```

  **顾客有等位区需求，服务人员忙等的情况**

  ```c++
  int waiting=0;//当前有多少个顾客正在等待被服务（已取号但未被服务的顾客）
  semaphore mutex=1;//用互斥变量保证对waiting变量的互斥访问
  semaphore service=0;//服务信号量，特殊的生产者消费者关系
  //顾客
  customer_i(){//因为被服务一次即完成，所以不用循环
      p(mutex);//互斥访问waiting，上锁
      if(waiting>=max){
          v(mutex);//释放互斥信号量
          return;//离开
      }
      取号;
      waiting ++;
      v(mutex);//解锁
      等待被叫号;
      p(service);//因为需要申请一个服务才能够被服务，所以需要p一种资源
      被服务;
      
  }
  //服务人员
  server_j(){
      while(1){//不停服务，所以要循环
         p(mutex);//互斥访问waiting,上锁
      if(waiting>0){//有顾客在等待
          
          叫号;
          waiting --;
          v(mutex);//解锁
          v(service);//提供一个服务
          提供服务;
      }
      else{
          v(mutex);//在无顾客的时候也要解锁
          
      	}//else end
  	}//while end
  }
  ```

  **顾客有等位区需求，服务人员闲时阻塞的情况**

  ```c++
  int waiting=0;//当前有多少个顾客正在等待被服务（已取号但未被服务的顾客）
  semaphore customer= 0;
  semaphore mutex=1;//用互斥变量保证对waiting变量的互斥访问
  semaphore service=0;//服务信号量，特殊的生产者消费者关系
  //顾客
  customer_i(){//因为被服务一次即完成，所以不用循环
      p(mutex);//互斥访问waiting，上锁
      if(waiting>=max){
          v(mutex);//释放互斥信号量
          return;//离开
      }
      取号;
      waiting ++;
      v(mutex);//解锁
      v(customer);
      等待被叫号;
      p(service);//因为需要申请一个服务才能够被服务，所以需要p一种资源
      被服务;
      
  }
  //服务人员
  server_j(){
      while(1){//不停服务，所以要循环
         p(mutex);//互斥访问waiting,上锁
      if(waiting>0){//有顾客在等待
          
          叫号;
          waiting --;
          v(mutex);//解锁
          v(service);//提供一个服务
          提供服务;
      }
      else{
          v(mutex);//在无顾客的时候也要解锁
          p(customer);//有顾客才被唤醒，此处需要p操作p一种资源才能进行
      	}//else end
  	}//while end
  }
  ```

  ![](/img/jdhgbffsrshr.png)

#### 习题带练

##### 1

![](/img/rgeaf.png)

* 睡觉：阻塞等待

##### 2

![](/img/uyrg.png)

* 循环忙等

##### 3

![](/img/sh.png)

![](/img/wva3v532.png)

##### 4

![](/img/ytejertrt.png)

![](/img/qwecqwcr.png)



##### 5

![](/img/uyj.png)

![](/img/htrh.png)

##### 6

![](/img/kuydtst.png)

![](/img/4w5wv.png)

### PV操作带练

![](/img/wh.png)

![](/img/23qc.png)

![](/img/v34q.png)

#### 同步问题

![](/img/aqr5y.png)

![](/img/q3v.png)

* 同一个进程本身的动作不需要我们去同步

![](/img/34qb.png)

* 没有缓冲区，不存在互斥问题，非消费者生产者问题
  * 并没有说把这个东西生产完之后放在哪里，只是不停地生产它，因此没有互斥关系只有同步关系

![](/img/11.png)

* 刚开始生产的，因为第一次可以直接进行，因此信号量为1，一开始需要条件的，信号量设为0

#### 互斥问题

![](/img/1bv.png)

![](/img/6b3b54.png)

* 只有全局变量才可能成为临界资源，局部变量只能在单一线程内访问，被单一线程看到
* 不是说几个临界资源，几个全局变量就设置几组互斥关系的
* 也不是说几个进程就设置几组互斥关系的

![](/img/6w2b254.png)

* 并不是信号量设置的越少并发度越高，也不是信号量越多并发度越高，只有正确地设置信号量才能保证并发度

![](/img/7m7m.png)

##### 互斥问题——读者写者

![](/img/89p.png)

* 遇见分支了，我们就要引入辅助变量count来帮助我们解决问题

###### 有读者和写者两个并发进程

![](/img/xn5nn.png)

###### 有读者和写者两组并发进程

![](/img/hrerr.png)

* 如果这样写，会导致实际上读者和读者之间也是互斥访问的

![](/img/v24313b.png)

![](/img/41431.png)

* 蓝色是P操作，红色是V操作，读者有两条路，因此出现了**分支**，必引出**辅助变量**，需要额外设置信号量

```c++
//写者
writer(){
    p(ww);//实现写者之间的互斥
        p(rw);
    		写文件
        v(rw);
    v(ww);
}
//读者
reader(){
    
    if(count==0){
        p(rw);
        
    }
    else{
        read;
    }
}
```

* 读者优先

![](/img/dnmmm.png)

* 读写公平

![](/img/8m7,.png)

* 因为W关卡的本质是设置一个公平排队逻辑，让每次只有一个读者或者一个写者进入排队队列，因此当这个读者或者写者排完队进入这个文件以后，就要对排队逻辑进行一个V操作

![](/img/7m8m87m.png)

![](/img/34vvb31.png)

#### 互斥问题——哲学家吃饭

![](/img/6b53bb.png)

#### 同步互斥综合问题

![](/img/v34bb4b.png)

![](/img/1231v.png)

![](/img/54b2.png)

![](/img/45v.png)

![](/img/87mm7m.png)

* 环形缓冲区：有序缓冲区，能够通过合理的设置，可以在不使用信号量的情况下，天然地保证生产者和消费者不会访问到同一个缓冲区
* 普通缓冲区：无序缓冲区，因为无论是生产者还是消费者都需要互斥访问这个缓冲区

![](/img/5m5m5m5m.png)

![](/img/5mth.png)

![](/img/542b4v2v.png)

![](/img/56v45v2v.png)

![](/img/653b5b3b.png)

## 内存管理

![](/img/erhhhhhhhh.png)

* 一般考请求分页，请求分页可能结合一级页表也可能结合二级页表
* 如果考基本分页则一般考二级页表
* 核心是地址转换
* 页表：把虚拟地址（逻辑地址）映射为物理地址
  * 无论是指令还是数据都是存储在内存里面的，无论是数据还是指令，在进程内部都是用虚拟地址来表示

### 进程的内存示意图

![](/img/yubvd.png)

![](/img/utmjnhgbfvd.png)

* 用户程序不可以访问PCB
* 编译、汇编的时候生成机器指令
  * 编译：将高级语言源程序一次性翻译成目标程序
  * 解释：将源程序的一条语句翻译成对应的机器目标代码，并立即执行，然后翻译下一条源程序语句并执行，直至所有原程序语句全部被翻译并执行完，并不会生成目标程序
  * 汇编：把汇编语言翻译为机器语言程序
* 库函数本质上也是指令序列，会被这个系统当中的所有程序所共享，会被映射到共享库的存储映射区
  * 这些函数对应的指令序列在物理上只有一份，只是多个进程都会把这一份物理指令序列映射到自己的虚拟地址空间当中，相当于页面共享
* 操作系统内核区也是被所有进程所共享的
  * 操作系统内核区的数据物理上也只有一份，为所有的进程所共享
  * 实现方法：把这些进程更高地址的1GB映射到同样的一片物理页框中即可

### 存储系统图

![](/img/IMG_4586.jpg)

* 左边是虚拟地址空间，中间是物理地址空间，右边是磁盘
* 由于7号页在磁盘不在内存，因此访问7号页面会缺页，需要把7号页调入主存

![](/img/IMG_4587.jpg)

![](/img/05940.jpg)

* 假设现在CPU要写的某一个变量的虚拟地址是0003 996H，现在要去查一级页表，一级页表存储在虚拟地址空间的操作系统内核区（属于内核数据结构）

* CPU是怎么去找到当前执行的进程页表存储在什么位置？

  * PCB进程控制块记载了当前进程的页表始址

* 操作系统怎么找到当前进程的PCB

  * 通过进程号PID，数据结构PCB，PID是数组下标，假设操作系统最多可以支持100个进程并发运行，可以定义一个struct pcb a[100]，每个进程的PID就可以作为这个数组的数组下标，因此，根据进程的PID，我去查找这个PCB数组的某一个元素，比如PID=3，那么我们去找a[3]

* 定义一个指针指向当前页表的页表始址，在内核区的某个虚拟地址

* 每一个进程在被调度上处理机的时候，操作系统会根据被调度的进程的PID，去找它的PCB，然后从PCB里面得知页表始址（虚拟地址），然后转化为物理地址，然后把该始址存储到CPU的寄存器里面（页表始址寄存器）

  * 如何把页表始址的虚拟地址转化为物理地址？
    * 所有的进程都是共享操作系统内核区的，所以所有的进程操作系统内核区的映射关系都是一样的。
    * 因为任意一个进程的页表都是存储在操作系统内核区的，而操作系统内核区是被所有进程共享的。
    * 因此，只要我知道了这个进程的页表起始地址，那么操作系统不管是任何一个进程，都可以根据每个进程的页表起始地址去转换成映射到我操作系统内核区的物理地址。

* 查页表的过程：

  * 根据页表始址寄存器所指明的地址去内存中，在某一个页框中找到页表
    * 页表是由页表项组成的，页表项有很多个，页表项在页表当中连续存储，本质是struct结构体，页表项存储有效位，页面在外存中的地址，脏位，页框号（VA→PA页框），页表本质是页表项的数组
    * eg：游戏存档：本质上就是把内存里面脏位=1的那些数据，当存储这些数据的页面被淘汰，被置换到外存，或者主动手动点存档的时候，脏了的页面需要协会到外存

* 二级页表的情况下，PCB会保存顶级页表的起始地址，放到顶级页表（页目录表）始址寄存器当中

* 注意虚拟页号划分，有几级页表虚拟页号就分成几段，然后最高地址是一级页表，依次升级

* 如果查到某一个页表项的有效位为0，说明没有调入主存，出发缺页异常（内中断，指令触发），接下来操作系统会进入到内核态，然后执行缺页异常的处理程序，然后会根据该页表项所写的数据在外存中的存储位置，从磁盘块中调进来。

  * 调进来之后，修改有效位，对应内存页框号更新

  * 异常处理程序执行结束之后会再次执行指令，就不会发生缺页，正常进行虚拟地址转化为物理地址

    * 缺页异常（内中断，指令触发），比如说我执行int a=3，可能涉及到一个mov [虚拟内存地址]，3的指令，然后在转换的过程中，发现有效位为0，也就是这条指令引发了缺页异常

    * 引发之后会转为处理异常的处理程序，操作系统陷入内核态，转入缺页异常的处理程序，然后执行一系列上面的事情

      * 由于虚拟地址空间通常比物理内存大，因此无法一次性将所有虚拟地址空间中的页面都加载到物理内存中。操作系统会根据需求动态地将需要的页面加载到内存，而其他不常用的页面会被暂时置换到磁盘。这个过程叫做**缺页处理**

        * 而页表里面的页表项存储的是虚拟地址空间里面的页表的信息， 所以页表里面不可能每一个页表项的有效位都为1（因为物理内存容纳不下所有的页都调入）

          * 由于物理内存有限，虚拟地址空间可能会比物理内存大，所以会有一些数据暂时存放在**磁盘**（外存）中，只有当数据被访问时，操作系统会通过**缺页中断**将需要的数据从磁盘调入内存。
          * 而且这还是一个进程的情况，多个进程的情况下每个进程实际上物理空间的冲突和缺页会更加频繁

        * **虚拟地址空间**是为每个进程提供的独立的地址空间，它在物理内存中并不直接对应具体的内存位置，而是通过操作系统的内存管理单元（MMU）进行映射，也就是操作系统负责形成虚拟地址和物理地址的映射关系并且形成页表

          * 操作系统根据一定逻辑形成虚拟地址和物理地址的映射关系并且形成页表，至于这里面的映射逻辑已经超出了408考试的范围，我们不用在意，只知道有一个东西即操作系统形成这个映射关系，导致物理内存容纳不下虚拟内存的所有东西，但是虚拟内存的东西在页表中有记录，哪些要放入虚拟内存，虚拟内存有那些东西都是操作系统负责，在磁盘中又能找到就行了

          * 所以，你只需要知道：

            1. **操作系统会管理虚拟内存和物理内存的映射**，并且通过**页表**来记录哪些虚拟地址对应物理地址。
            2. 如果物理内存不足，操作系统会**将不常用的数据交换到磁盘**，并且需要时从磁盘读取数据回到内存。

            不需要过多关注具体的映射逻辑细节，考试中大多会让你理解虚拟内存的概念和内存管理的基本原理即可。


![](/img/IMG_4588.jpg)

* 快表没有命中但是慢表命中以后，会把命中的慢表中的一些信息复制到TLB当中进行更新
  * 也就是说访问一个页面第一次没有命中，但是第二次访问同一个页面的时候快表肯定能命中
    * 命中：有效位为1且有匹配的页号
  * 当查TLB没有命中，查慢表发现缺页异常的时候，却也处理程序把一个页面从外存中调入内存的时候，除了修改内存中的慢表之外，还会修改快表，因此当缺页处理之后，再次执行指令的时候TLB命中（除非题目说不修改TLB）
* 缺页处理还可能涉及页面置换（页框不够），被换出的页面需要检查脏位，如果脏位为1，则操作系统会把对应页框的数据写回磁盘对应的区域（写磁盘）。然后空出来的原页框，就会被新调入的覆盖（读磁盘）
  * 因为原页面被置换出去，原页表的页表项有效位要改为0，后面可以不改
  * 换入的页的页表项有效位变成1，脏位变为0，页框号更新，对应置换算法的标记更新
  * 页面置换算法属于缺页异常处理程序的子功能
  * TLB那边也得相应发生改变

![](/img/IMG_4589.jpg)

* 上图为两个进程共享某些页面
* 每个进程的虚拟地址空间都是不一样的，但是有一些数据（比如操作系统内核区和共享库的存储映射区）是共享的
  * 操作系统内核区的数据是独一份，只有操作系统内核代码可以去访问
    * 用户态下想访问会被阻止
* 如何实现共享？
  * 页表映射到同一个页框号，比如说进程A的页表中，页目录FFH存储的是操作系统内核的数据，进程B的页表中，页目录FFH存储的也是操作系统内核的数据，然后对应的二级页表中的页表项也相等，这样当他们访问相同虚拟地址的时候，访问的都是同一段数据
  * 当所有进程都共享独一份的操作系统内核区数据（只要让所有进程的某一块页表项都映射到物理地址空间的同一块地方就可以了）
  * 当然，因为二者的数据完全一致，所以完全可以让二者共享同一份二级页表（原来是两个页表但是映射到同一块区域，现在是另一个进程直接指向另一个进程的页表某块）
  * 但是共享库的内存映射区不能这么干，因为二者数据不完全一致，引用的库函数不完全相同，所以有两份页表
* p1和p2进程实现进程间通信的方式
  * 共享内存
    * 要进行系统调用，告诉操作系统哪个页面作为共享内存来交换数据，比如p1说4号页面，p2说六号页面，然后操作系统就会把p1的四号页所指向的页框和p2的六号页所指向的页框映射到同一个位置（比如都是FEEH物理地址）
      * 此时当p1进程往四号页面读写的时候实际上是在读写FEEH，当p2进程往六号页面读写的时候，实际上是在读写FEEH
      * p1写p2读，这样实际上就实现了进程之间的通信
    
  * 信箱通信
    
    ![](/img/082059.jpg)
    
    ![](/img/083056.jpg)
    
    * p1进程通过系统调用，先给操作系统写一段数据，然后操作系统再把这一段数据交给p2进程
      * P1进程对操作系统发出系统调用，表示要用信箱通信，跟p2进程完成进程间通信。并且指明要写的数据是什么位置
      * 操作系统收到系统调用之后，从用户态变为内核态
      * 之后操作系统根据系统调用号（异常号）找到中断向量表，找到该系统调用所对应的函数入口（指令的起始位置），PC指向该系统调用指令第一条指令的起始位置，然后就可以开始执行系统调用的这个处理程序
        * 因为此时CPU已经变成内核态了，所以PC要去访问这条指令或者说要去访问操作系统内核区的时候，是可以被允许的
      * 操作系统的系统调用处理程序会根据传递过来的参数去访问用户区，找到p1进程准备好的数据，然后先复制到**操作系统内核区**某一个位置，当p2进程通过系统调用，对操作系统发出要从信箱中取多少数据的指令，接下来操作系统会把那段数据从操作系统的内核区复制给p2进程指定的其用户区的位置
        * 因为所有进程共享独一无二的一片内核区，因此p2进程也能找到p1进程准备好的放在内核区的数据

* 进程的驻留集大小就是给某一进程分配了几个页框，比如说某个进程的页表有三个页表项也就是3个页，但是实际上物理空间只分配了2个页框，那么其页表中有效位最多有2个为1的。
* 局部淘汰：只从给进程本身分配的页框当中选择一个淘汰出去
  * 全局淘汰：可能从其他进程的页框当中选择一个淘汰出去
* 页表始址寄存器里面保存的是物理地址
* 进程切换开销：从一个进程切换到另一个进程的时候，意味着TLB里面的所有数据，所有缓存的数据都得作废，Cache里面的数据也要作废
  * 同一进程不同线程的切换，TLB和Cache数据副本不会作废，所以切换代价比进程切换小
* 数组在虚拟地址空间中的地址连续，在物理地址空间里面不一定连续

### 总结

* 操作系统创建一个新进程的时候，就会给这个进程分配虚拟地址空间，而每一个进程的这个虚拟地址空间，里面包含各个页面，这些页面会被映射到物理内存的各个位置
* 有一些页面是在外存当中还没有调入内存，所以我们需要有一个页表，用页表去表示出这个虚拟页面和物理页框之间的映射关系
* 如果访问到一个暂时没有调入内存的页面，那么这样的页面，在页表项中，有效位是0，操作系统会通过缺页异常的处理，去外存当中把这个页面的数据调入内存，并且更新页表项。如果有TLB，更新慢表项数据的同时，也会把这个新调入的页面所对应的页表项的副本数据复制一份到TLB当中，这样的话，再次访问同一个页面，就可以直接TLB命中。
* 操作系统给一个进程分配的页框是有限的，那么当页框不够用的时候，就要通过页面置换算法把页框置换出去
* 两个进程共享操作系统的内核区，只要把两个进程虚拟地址的高地址部分映射到同一片物理页框里面即可
* 共享内存，本质是就是操作系统修改两个进程的页表，让两个进程的页面（虚拟地址空间）映射到同一个页框（物理地址空间），让两个进程在同一个页框当中进行数据的读写

