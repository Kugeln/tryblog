---
title: 计算机组成原理
date: 2024-04-15 13:57:06
tags: 408专业课	
sticky: 141
categories: 408
banner_img: /img/1920x1080 (7).jpg
index_img: /img/1920x1080 (7).jpg
math: true
---


## 第一章 计算机系统概述

### 1.1计算机发展历程

* 低电平表示二进制0
* 高电平表示二进制1
* 金属针脚用来接受和发送电信号二进制数，每个二进制数位称为1bit
* 计算机性能的好坏取决于软硬件功能的总和
* IH
* 摩尔定律：集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，整体性能也将提升一倍

### 1.2计算机硬件的基本组成

![](/img/145732.jpg)

#### 早期冯诺依曼机的结构

![](/img/144503.jpg)

##### 特点

* 采用存储程序的工作方式
  * 将指令以二进制代码的形式事先输入计算机的主储存器（内存），然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束
  * 得以实现自动化地执行代码
* 计算机由五大部件组成
  * 运算器
  * 控制器
  * 存储器
  * I/O设备
* 指令和数据以同等地位存于存储器，可按地址寻访
  * CPU区分指令和数据的依据是二者访问阶段的不同
* 指令和数据用二进制表示
* 指令由操作码（操作类型）和地址码（操作数据的地址）组成
* **以运算器为中心**
  * 输入/输出设备与存储器之间的数据传送通过运算器完成
    * 导致数据计算效率的降低

#### 现代计算机的结构

![](/img/145236.jpg)

![](/img/145449.jpg)

##### 特点

* **以存储器为中心**
* CPU=运算器+控制器
* 指令存放于控制器当中，由控制器来解析并且发出相应的控制信号
* 注：辅存主要指机械硬盘固态硬盘等，不属于主机内容而属于I/O设备，例如我们手机里的APP平时储存在辅存里面，只有使用的时候才会把辅存里边的app相关的程序数据代码读到主存里边

### 1.3各个硬件的工作原理

![](/img/163027.jpg)

#### 主存储器

##### 基本组成

* 存储体

  * 用于存放数据，由一系列的存储元件构成，用于存放零和一

  * `数据在存储体内按地址存储`

    ![](/img/151037.jpg)

    * 存储单元：每个存储单元存放一串二进制代码
    * 存储字：存储单元中二进制代码的组合
    * 存储字长：存储单元中二进制代码的位数
    * 存储元：即存储二进制的电子元件，每个存储元可存1bit（电容存储）

* 寄存器

  * 注：现在的计算机通常把MAR、MDR也集成在CPU内
  * MAR（存储地址寄存器）
    * MAR位数反映了存储单元的个数（最多支持多少个）
  * MDR（存储数据寄存器）
    * MDR位数=存储字长（bits）=每个存储单元的大小
  * 读取

  ![](/img/150346.jpg)

  * 写入

  ![](/img/150449.jpg)

#### 运算器

用于实现算术运算（加减乘除）、逻辑运算（与或非）

![](/img/151924.jpg)

##### 基本组成

* ACC：累加器，用于存放操作数或者运算结果
* MQ：乘商寄存器，在乘、除运算时，用于存放操作数或者运算结果
* X：通用的操作数寄存器，用于存放操作数
* `ALU：算数逻辑单元，通过复杂的电路实现算数运算、逻辑运算，上面为数据储存结构`

#### 控制器

![](/img/60316.jpg)

##### 基本组成

* `CU：控制单元，分析指令，给出控制信号`
* IR：指令寄存器，存放当前执行的指令
* PC：程序计数器，存放下一条指令地址，有自动加1的功能

* 完成一条指令的流程：
  * 取指令 PC
  * 分析指令 IR
  * 执行指令 CU

#### 计算机的工作过程

* 过程演示

![](/img/155208.jpg)

![](/img/155801.jpg)

![](/img/161851.jpg)

![](/img/162123.jpg)

![](/img/162450.jpg)

![](/img/162559.jpg)

* PC→MAR→（取出要执行的指令放到）MDR→IR→CU→MAR→MDR→寄存器

* 总结

![](/img/162909.jpg)

### 1.4计算机系统的多级层级结构

![](/img/171555.jpg)

#### 计算机系统的层次结构

![](/img/171039.jpg)

![](/img/171511.jpg)

### 1.5计算机的性能指标

![](/img/194628.jpg)

#### 存储器的性能指标

![](/img/172819.jpg)

* 存储器的容量

  * 总容量=存储单元个数*存储字长

    ​            =存储单元个数*存储字长/8

#### CPU的性能指标

* CPU主频：CPU内数字脉冲信号震荡的频率，表示的是每秒钟会有多少个数字脉冲，即会出多少个时钟周期

  * 如10Hz可能是每秒钟有10个脉冲信号

  ![](/img/191603.jpg)

  ![](/img/093500.jpg)

$$
CPU时钟周期=\frac{1}{主频}
$$

$$
CPU执行时间（整个程序的耗时）=\frac{CPU时钟周期数}{主频}=CPU时钟周期数*时钟周期
$$

$$
CPU执行时间=\frac{指令条数*CPI}{主频}=CPI*指令条数*时钟周期
$$


$$
CPI=\frac{CPU时间*时钟频率}{指令条数}=\frac{CPU时钟周期数}{指令条数}
$$


$$
CPI=\sum^n_{i=1}(CPI_i*F_i)=\frac{CPU时钟周期数}{指令条数}
$$

$$
总时钟周期数=\sum^n_{i=1}(CPI_i*C_i)
$$

$$
IPS（每秒执行多少条指令）=\frac{主频}{平均CPI}=\frac{指令条数}{执行时间（秒）}
$$

* 平均CPI=∑各指令CPIx指令混合比
* 同一套指令集意味着指令总数相同

注：

* 容量是2^k
* 带宽是10^k

#### 系统整体的性能指标

* 数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）

* 吞吐量：指系统在单位时间内处理请求的数量
  * 它取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。（了解即可）
* 响应时间：指从用户向计算机发送一个请求，到系统对该请求做出相应并获得它所需要的结果的等待时间
  * 通常包括CPU时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I/O操作、操作系统开销等时间）（简单了解即可）

#### 系统整体的性能指标（动态测试）

* 基准程序（跑分软件）是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其他计算机性能进行比较

#### 提高计算机性能的主要途径

* 提高时钟频率（流水线）
* 优化处理其中数据通路的结构以降低CPI（单周期/多周期/流水线）
* 采用编译优化措施来减少指令条数或降低指令复杂度（指令系统）

## 第二章 数据的表示和运算

* 数值数据和非数值数据

  * 数值数据是指能在数轴上找到点的数据
    * 定点数、浮点数
  * 非数值数据是指字母、汉字等
    * char，string

* 数值数据表示的三要素

  * 进位计数值
  * 定、浮点表示
  * 如何用二进制编码
  * 要确定一个数值数据的值必须先确定这三个要素

* 整数都采用补码来表示

  * 但浮点数的尾数用原码定点小数表示

* 补码特性：模运算

  * 在一个模运算系统中，一个数与它除以模以后的余数等价
  * 一个负数的补码等于模减去该负数的绝对值
  * 一个正数的补码等于模加上它本身即等于原码
    * 任何一个数用n位1来减相当于各位取反，末位+1

  ![](/img/73942.jpg)

  * 对于某一确定的模，某数减去小于模的另一个数，总可以用该数加上另一个数符数的补码来替代

* 2的16次方之内要牢记

* 变形（模4）补码：双符号，用于存放可溢出的中间结果

* 无符号数0扩展，带符号整数符号扩展

* 无符号数和带符号数运算一般转化为无符号数

* 因为原码是对称的，所以尾数的表示范围关于原点对称

### 2.1数制与编码

#### 2.1.1 进位计数制

![](/img/194427.jpg)

##### r进制计数法

![](/img/192649.jpg)

![](/img/193026.jpg)

##### 二进制与八进制、十六进制互相转换

* 二到八

![](/img/193146.jpg)

* 二到十六

![](/img/193224.jpg)

* 八到二

![](/img/193324.jpg)

* 十六到二

![](/img/193400.jpg)

##### 十进制转化为任意进制

* 整数部分

![](/img/193825.jpg)

* 小数部分

![](/img/194015.jpg)

* 拼凑法转化为二进制

![](/img/194120.jpg)

#### 2.1.2 BCD（用二进制编码的十进制数）码

![](/img/202034.jpg)

* 四个二进制位表示一个十进制位

![](/img/195755.jpg)

* 8421码映射关系（有权码）

![](/img/195910.jpg)

![](/img/201051.jpg)

![](/img/201326.jpg)

![](/img/201339.jpg)

![](/img/201531.jpg)

某一位加出来>9或者有进位的时候要加6矫正

结果<=9的时候不需要矫正

最高位有进位时，发生溢出

* 余3码（无权码）

![](/img/01731.jpg)

* 2421码（有权码）

0-4的首位一定是0，5-9的首位一定是1

![](/img/201940.jpg)

#### 2.1.3 无符号整数的表示和运算

![](/img/203330.jpg)

![](/img/202247.jpg)

##### 无符号整数的表示

![](/img/202618.jpg)

##### 无符号整数的加法运算

![](/img/202806.jpg)

##### 无符号整数的减法运算

![](/img/203011.jpg)

![](/img/203228.jpg)

#### 2.1.4 带符号整数的表示和运算 原反补

![](/img/210101.jpg)

![](/img/203430.jpg)

![](/img/203630.jpg)

* x补码的本质是x+2^n

##### 原码表示(Sign and magnitude)

![](/img/203927.jpg)

![](/img/204046.jpg)

##### 原码→反码→补码的转换（机算）

![](/img/204256.jpg)

##### 原码、补码快速转换技巧（手算）

![](/img/204650.jpg)

##### 补码的加法运算

![](/img/205003.jpg)

![](/img/205325.jpg)

* 注：由于补码数值不能解读为位权，因此真值需要转换为原码再去找真值

##### 补码的减法运算

* 机算

![](/img/205603.jpg)

* 手算
  * 找到第一个1，然后1的左边的所有位数包括符号位在内取反，右边保持不变

##### 对比：无符号整数的减法运算

* 无论是带符号整数还是无符号整数的减法，都是被减数不变，减数全部位按位取反、末位+1，减法变加法
* 计算机内部，所有带符号整数的加减法都要先转化为补码（当然C语言的带符号整数都是用补码来表示的）

![](/img/205857.jpg)

#### 2.1.5 原反补码的特性对比

![](/img/210300.jpg)

##### 各种码的基本特性总结

![](/img/233057.jpg)

* 对于负数，数值部分越小，其绝对值越大，即负的越多

#### 2.1.6 移码

![](/img/232157.jpg)

![](/img/232345.jpg)

![](/img/233024.jpg)

![](/img/233200.jpg)

* 移码：补码的基础上将符号位取反。注意：移码只能用于表示整数。

#### 2.1.7 定点小数

![](/img/233350.jpg)

![](/img/233506.jpg)

* 定点小数的符号位后面常常用“.”隔开，而定点整数的符号位后面常常用“，”隔开

##### 定点小数原/反/补码的转换

![](/img/220352.jpg)

##### 定点小数的加/减运算

![](/img/220502.jpg)

##### 定点小数vs定点整数

![](/img/220732.jpg)

![](/img/221006.jpg)

##### 小数补码的加法运算

![](/img/221322.jpg)

##### 小数补码的减法运算

![](/img/221432.jpg)

### 2.2 运算方法和运算电路

#### 2.2.0 奇偶校验码

##### 校验原理简介

![](/img/223201.jpg)

![](/img/223333.jpg)

##### 奇偶校验码

![](/img/223555.jpg)

* 奇偶校验码的缺点：只能发现奇数个位发生传输错误，不能发现偶数个位发生传输错误

偶校验码的硬件实现

 ![](/img/224356.jpg)

##### 码距与检错、纠错能力的关系（当d<=4）

* 不用背

![](/img/004101.jpg)

#### 2.2.1 电路的基本原理、加法器设计

![](/img/13636.jpg)

##### 算术逻辑单元（ALU）

![](/img/dsacs.png)

![](/img/225001.jpg)

* 控制信号是由控制单元cu发出的

![](/img/230645.jpg)

* M用来表示做的是逻辑运算还是算术运算，1是逻辑运算，0是算术运算
  * S0-S3可以用来指明此次要进行的是哪一种算术运算或者哪一种逻辑运算
  * 此处有4个bit，可以对应16种状态，因此该芯片可以支持16种算术运算和16种逻辑运算

![](/img/eeeeessadfsd.png)

* 求补码：
  * 把一个原码送到ALU的某一个输入端，同时给出求补码的控制信号，输出端这个地方就可以得到这个原码所对应的补码
* 直送
  * 不对这个数据进行任何处理，怎么进就怎么出
* 原理

![](/img/dddddsaffdsadf.png)

###### 看懂ALU图示

![](/img/xbafga.png)

* 机器字长的真面目就是ALU算术逻辑单元里面可以支持同时输入多少个比特的信息
* 寄存器的位数和ALU一般保持一致，也即一般寄存器的位数就是机器字长
* 其余输入和输出信号一般是为了和其他芯片进行串联而设计的

##### 最基本的逻辑运算

* 一个比特的逻辑运算
* 关于数据的输入和输出，我们都是用电信号来表示的，也就是高低电平

![](/img/21002.jpg)

* 与门

![](/img/231008.jpg)

* 或门

因为只要有一个1结果就是1，即>=1

![](/img/231213.jpg)

* 非门

![](/img/231334.jpg)

* 优先级：与>或

![](/img/231709.jpg)

##### 复合逻辑

![](/img/232133.jpg)

* 异或门可用与、或、非组合实现
  * 异或的天然逻辑：加法、奇偶校验

![](/img/232213.jpg)

* 同或门

![](/img/111409.jpg)

##### 异或运算的妙用

![](/img/dddddddd.png)

##### 门电路的变形画法

![](/img/sacdfsdadf.png)

##### 逻辑运算的优先级、常见公式

![](/img/asdaaaaa.png)

##### 逻辑门电路基础总结

![](/img/vdddd.png)

##### 用门电路求偶校验位

![](/img/111756.jpg)

##### 一位全加器

![](/img/112850.jpg)

* nbit的加法可以拆解为n个1bit的加法

##### nbit加法器

![](/img/ddddsadfdsafdsfa.png)

##### 串行加法器

![](/img/113045.jpg)

##### 并行加法器

* 串行进位的并行加法器

![](/img/113432.jpg)

这种加法器的运算速度很大程度上取决于每一位进位的产生速度

* 进位信息是串行产生的，计算速度取决于进位产生和传递的速度，位数越多，运算速度越慢
* 注：电信号到达稳态需要一定时间，因此进位产生速度会有延迟
* 串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的

##### 三态门

![](/img/jhfgssfd.png)

![](/img/ydhtgsrfaed.png)

![](/img/asdvewa.png)

#### 2.2.2 并行进位加法器

![](/img/113432.jpg)

##### 更快产生进位

![](/img/·114835.jpg)

##### 并行加法器的优化

![](/img/202337.jpg)

![](/img/021135.jpg)

![](/img/021241.jpg)

![](/img/021403.jpg)

![](/img/021435.jpg)

* 注：目前计算机不需要芯片级联，一个CPU芯片中有多个处理器核，一个核中有多个ALU

#### 2.2.3 补码加减运算器

##### 加法器原理

![](/img/203123.jpg)

##### 补码加/减法运算方法

![](/img/203439.jpg)

![](/img/212939.jpg)

![](/img/213351.jpg)

* 有符号整数和无符号整数的加减法虽然共用一套电路，但是判断是否溢出的方式不同

#### 2.2.4.1 加减运算和溢出判断

![](/img/223535.jpg)

##### 原码的加减运算

![](/img/213734.jpg)

* 主要用于浮点数尾数运算
* 符号位和数值部分分开处理
* 仅对数值部分进行加减运算，符号位起判断和控制作用
  * 加法：同号求和，异号求差
  * 减法：异号求和，同号求差

##### 补码的加减运算

* -B的补码是B的右数第一个1的左边所有位全部取反

![](/img/215939.jpg)

##### 移码的加减运算

![](/img/023635.jpg)

![](/img/023756.jpg)

* 补码和移码的关系：符号位取反、数值位相同

##### 溢出判断

核心逻辑：两个同号的数相加，最终得到了一个异号的结果

![](/img/20158.jpg)

* 方法一：采用一位符号位
  * 左边判断是否负+负得正，右边判断是否正+正得负，两个结果只要有一个溢出即答案得1，最后就是存在溢出现象，所以用或运算或起来

![](/img/221225.jpg)

* 方法二：采用一位符号位，根据数据位进位情况判断溢出

  ![](/img/222028.jpg)

  * 上溢

  ![ ](/img/221519.jpg)

  * 下溢

  ![](/img/21733.jpg)

  * 只要发生了溢出，符号位的进位和最高数值位的进位肯定不一样

* 方法三：采用双符号位

![](/img/222145.jpg)

![](/img/222549.jpg)

补码在进行运算之前会复制一个符号位，接下来会让两个符号位同时进行运算

* 补码乘法中高32位非全0或者全1为溢出

##### 符号扩展

![](/img/223457.jpg)

* 正整数：
  * 符号位和数值位中间补0
* 负整数：
  * 原码：符号位和数值位中间补0
  * 反码：符号位和数值位中间补1
  * 补码：符号位和数值位中间补1
* 正小数：
  * 最后一位后面补0
* 负小数
  * 原码：最后一位后面补0
  * 反码：最后一位后面补1
  * 补码：最后一位后面补0

#### 2.2.4.2 标志位的生成

![](/img/224508.jpg)

![](/img/225358.jpg)

![](/img/dagcxzbd.png)

* 注：
  * OF: overflow flag 
  * SF: sign flag
  * ZF: zero flag
  * CF: carry flag（进位、借位标志）



* OF的标志位仅在有符号数的加减运算中有意义，即如果进行的是无符号数的加减运算，即便OF=1也并不能说明无符号数发生了溢出 
* 如果减法的CF结果为1，说明产生了借位，也说明被减数比减数要小，意味着最终运算的结果一定是错误的，发生了溢出
* 有符号数的溢出看OF，无符号数的溢出看CF，都是1为溢出

#### 2.2.5 定点数的移位运算

![](/img/000933.jpg)

![](/img/230137.jpg)

![](/img/232510.jpg)

##### 原码的算术移位

![](/img/231159.jpg)

* 算数右移

![](/img/230702.jpg)

* 算数左移

![](/img/231134.jpg)

* 注：参考C++中的位运算，X>>k等于X/ 2^k，X<<k等于X* 2^k

##### 反码的算术移位

![](/img/231342.jpg)

##### 补码的算术移位

![](/img/232326.jpg)

##### 算术移位的应用举例 

![](/img/235441.jpg)

##### 逻辑移位

![](/img/235520.jpg)

##### 逻辑移位的应用举例

![](/img/000035.jpg)

##### 循环移位

![](/img/000828.jpg)

* 循环补位，移出去的补到最后一位或者最前一位
* 带进位位的循环移位，相当于把进位位加入队列
* 循环移位很适合把数据的高字节和低字节进行一个调换

#### 2.2.6.1 原码的乘法运算

##### 手算乘法（十进制）

![](/img/002135.jpg)

##### 手算乘法（二进制）

![](/img/002417.jpg)

##### 原码一位乘法

![](/img/002834.jpg)

![](/img/003021.jpg)

![](/img/003104.jpg)

![](/img/003223.jpg)

![](/img/003331.jpg)

![](/img/003424.jpg)

![](/img/003517.jpg)

##### 原码一位乘法（手算模拟）

*  由于补码乘法用的是双符号位，所以原码的乘法也可以用双符号位以便统一

![](/img/003727.jpg)

* 自己答题时最好还是写出真值所对应的源码机器数

#### 2.2.6.2 补码的乘法运算

![](/img/010422.jpg)

##### 补码一位乘法

![](/img/005238.jpg)

* 辅助位就是把MQ寄存器的容量多拓展了一位，用新拓展的一位来存储的
  * MQ中的最低位指的是当前参与乘法运算的那一位
  * 原码往ACC、X和MQ里面存绝对值，而补码是直接把符号位也一并存进去了
  * 被乘数和乘积高位采用的是双符号位补码，而乘数、乘积地位采用的是单符号补码

![](/img/005750.jpg)

##### 补码一位乘法（手算模拟）

![](/img/010309.jpg)

#### 2.2.7.1 原码的除法运算

##### 手算除法（十进制）

![](/img/135750.jpg)

##### 手算除法（二进制）

![](/img/140051.jpg)

##### 原码除法：恢复余数法

![](/img/140417.jpg)

![](/img/140525.jpg)

![](/img/140604.jpg)

![](/img/140745.jpg)

![](/img/140836.jpg)

![](/img/140927.jpg)

![](/img/140951.jpg)

![](/img/141020.jpg)

![](/img/141044.jpg)

![](/img/141148.jpg)

##### 原码除法：恢复余数法（手算）

* 写出①除数和②被除数的绝对值，以及③除数的绝对值的补码和④绝对值负数的补码

![](/img/141612.jpg)

![](/img/141724.jpg)

##### 原码除法：加减交替法（不恢复余数法）

![](/img/142632.jpg)

![](/img/142849.jpg)

* 在定点小数的除法运算中，我们会规定被除数一定要小于除数，因为如果大于，则商会>1，而定点小数无法表示大于1的范围，因此当第一步的商是1，说明被除数比除法更大，硬件电路检测出以后会直接停止这些除法的运算

#### 2.2.7.2 补码的除法运算

* 两个n位补码整数除法运算，被除数需要进行符号扩展，若被除数为2n位，除数为n位，则被除数无需扩展
* 余数变号不够减，不变号够减

##### 补码除法：加减交替法

![](/img/143631.jpg)

##### 除法运算总结回顾

![](/img/143758.jpg)

#### 2.2.8 C语言类型转换

* 无符号数和有符号数
* 长整数变短整数
* 短整数变长整数

![](/img/144322.jpg)

#### 2.2.9 数据的存储和排列

##### 大小端存储

* 大端存储就是把更高有效字节存储到更低地址的部分，最低有效字节存放到了最高地址部分
* 小端存储就是在低地址部分存储最低有效字节，在高地址部分存储最高有效字节
  * 小端方式便于机器处理类似于高精度运算中数字用数组倒存

![](/img/145009.jpg) 

##### 边界对齐

* 注：字节是基本单位，一字节等于8bit，字长是运算的基本单位，即以此能处理多少个字节，多少位就是多少个bit，处理的字节数等于bit/8，半字就是字长的一半
* 字长是数据通路的宽度，字是处理事务的固定长度的二进制数位组，是信息传送的基本单位
* 给出访问的字的地址的时候，如何转化为与之对应的字节地址：
  * 字地址逻辑左移两位
  * 半字地址逻辑左移一位

![](/img/145826.jpg)

![](/img/145934.jpg)

### 2.3 浮点数的表示与运算

* 数据在数轴上是稀疏、不均匀的，数字越大，间隔越大精度越低

![](/img/234308.jpg)

#### 2.3.1 浮点数的表示

![](/img/155945.jpg)

* 定点数可以表示的数字范围有限，但我们不能无限制地增加数据的长度

##### 从科学计数法理解浮点数

* 阶符为正，小数点右移，阶符为负，小数点左移
  * 阶码的数值部分意味着要移多少位 
* 尾数越短，表示的数字精度就越低

##### 浮点数的表示

* 定点数之所以称为定点数是因为小数点的位置固定不变，而浮点数就是小数点的位置是会浮动的

![](/img/153255.jpg)

* 阶码反应浮点数的表示范围及小数点的实际位置

![](/img/153501.jpg)

* 尾数M的数值部分的位数n反应浮点数的精度
* 尾数给出了一个小数，阶码指明了小数点要向前/后移动几位

![](/img/154034.jpg)

![](/img/154149.jpg)

##### 浮点数尾数的规格化

![](/img/154551.jpg)

* 左规：通过算术左移来把浮点数进行规格化

![](/img/155019.jpg)

##### 规格化浮点数的特点

![](/img/155633.jpg)
![](/img/155912.jpg)

#### 2.3.2 IEEE 754

![](/img/164232.jpg)

##### 移码回顾

![](/img/160319.jpg)

![](/img/160746.jpg)

##### IEEE 754标准

* 在实际计算的时候，可以先把移码看成是无符号数，转换成十进制再减掉偏移量

![](/img/161904.jpg)

![](/img/162018.jpg)

![](/img/63217.jpg)

![](/img/63211.jpg)

* 十六进制一位数字对应4个bit

![](/img/163442.jpg)

![](/img/163653.jpg)

![](/img/164111.jpg)

![](/img/234017.jpg)

#### 2.3.3 浮点数的运算

![](/img/172137.jpg)  

##### 浮点数的加减运算

* 通常是阶数更小的向阶数更大的对齐

![](/img/64748.jpg)

 ![](/img/165355.jpg)

 ![](/img/165843.jpg)

##### 舍入

![](/img/165955.jpg)

![](/img/171742.jpg)

##### 强制类型转换

* 64位机器里面long向double转换可能产生精度丢失

![](/img/172107.jpg)

#### 逻辑数据的编码表示

* 用一位表示，例如真1假0
* N位二进制数可以表示N个逻辑数据，或者一个位串
* 位串：用来表示若干个状态位或者控制位（OS中使用较多）

![](/img/001356.jpg)

#### C语言程序中涉及的运算

* 如何从16位采样数据y中提取高位字节，并使低字节为0？
  * 使用掩码y&0xFF00

* C语言中不区分逻辑移位还是算术移位，由x的类型决定，有符号整数是算术移位，无符号数是逻辑移位

![](/img/014902.jpg)

## 第三章 存储系统

### 3.1 存储系统基本概念

![](/img/1139.jpg)

##### 存储器的层次化结构

![](/img/004248.jpg)

##### 存储器的分类

![](/img/004634.jpg)

![](/img/005554.jpg)

![](/img/010119.jpg)

![](/img/10244.jpg)

![](/img/010419.jpg)

##### 存储器的性能指标

* 存储容量：MAR*MDR
* 容量是bit

![](/img/010904.jpg)

### 3.2 主存储器

#### 3.2.1主存储器的基本组成

![](/img/102706.jpg)

* bios的本质是ROM，而ROM和RAM共同组成了主存，ROM+RAM才是完整的贮存，如果一条指令来自开机的时候，开机的引导程序是在BIOS ROM芯片里面的，但是访问ROM的本质仍然是访问主存，所以开机的指令也是在主存当中的

##### 基本的半导体元件及原理

![](/img/95943.jpg)

* 读出二进制的原理
  * 接通mos管，如果电容里面保存了电荷，电荷流出，检测到电荷流出，判断保存的是1，没有保存电荷，没有电荷流出，检测不到电荷流出，判断保存的是0

![](/img/95359.jpg)

* 写入二进制的原理
  * 保存二进制的1
    * 在导线的另一端和mos管加高电压，电容存储电荷

![](/img/095622.jpg)

##### 存储器芯片的基本原理

* 每个地址会对应译码器的一条输出线

![](/img/100136.jpg)

![](/img/00332.jpg)

* 存储矩阵：一个个存储元
* 译码驱动电路：译码器+驱动器（保证译码器输出的电信号稳定可靠）
* 读写电路：红绿线+控制电路
* 地址信息：CPU通过地址线传过来
* 片选线：确定芯片某种情况下是否可用
* 金属引脚：接收地址信号或者数据信号、片选信号、读写信号
* 每根地址线对应一个金属引脚，数据线有多少根就有多少个金属引脚
  * 片选线也对应一个引脚
  * 读写控制线至少对应一个金属引脚

![](/img/101346.jpg)

* n条地址线
  * 2^n个存储单元
  * 总容量=存储单元个数*存储字长
  * n*n位的存储芯片，第一个n表示多少个存储单元，第二个表示存储字长

![](/img/101626.jpg)

##### 寻址

![](/img/102642.jpg)

#### 3.2.2 SRAM和DRAM

![](/img/103230.jpg)

![](/img/113043.jpg)

##### dram芯片

![](/img/10505.jpg)

##### 栅极电容vs双稳态触发器

![](/img/111217.jpg)

* 栅极电容
  * 1：电容内存储了电荷
  * 0：电容内未存储电荷

![](/img/11013.jpg)

* 双稳态触发器

  * 写入二进制0，左边加低电平，右边加高电平

* 区别

  * 栅极电容：读写速度更慢，每个存储元制造成本更低，集成度高，功耗低
    * 电容内的电荷只能维持2ms，即便不断电，2ms后信息也会消失，因此2ms之内比须刷新一次（给电容充电）

  ![](/img/111454.jpg)

  * 双稳态触发器：读写速度更快，每个存储元制造成本更高，集成度低，功耗大
    * 只要不断电，触发器的状态就不会改变

  ![](/img/11541.jpg)

##### dram vs sram

 ![](/img/111809.jpg)

##### dram的刷新

![](/img/112820.jpg)

* 每个译码器只需要处理一半的地址信息 

![](/img/112236.jpg)

![](/img/12335.jpg)

![](/img/112447.jpg)

##### dram的地址线复用技术

![](/img/112936.jpg)

#### 3.2.3 只读存储器ROM

![](/img/140721.jpg)

##### 了解各种rom

* 两块体积都相同的芯片，工艺水平相同，闪存芯片上的存储元的数量，要比ram芯片上存储元的数量更多，也就是保存更多的二进制比特位

![](/img/13549.jpg)

##### 计算机内的重要rom

![](/img/113813.jpg)

![](/img/113930.jpg)

#### 3.2.4 双端口RAM和多模块存储器

![](/img/140547.jpg)

##### 存取周期

![](/img/114321.jpg)

##### 双端口ram

![](/img/114607.jpg)

##### 多体并行存储器

* 每个体相互独立

![](/img/115126.jpg)

![](/img/120223.jpg)

* 高位交叉编址
  * 用地址更高的几个比特位来区分我们想要访问的是哪一个存储体
* 低位交叉编址
  * 用地址更低的几个比特位来区分我们想要访问的是哪一个存储体

* 应该取几个体？
  * 给定一个地址x，如何确定它属于第几个存储体
    * x mod n

![](/img/35229.jpg)

##### 多模块存储器

![](/img/35608.jpg)

![](/img/135747.jpg)

### 3.3 主存储器与CPU的链接

![](/img/195041.jpg)

##### 单块存储芯片与CPU的链接

![](/img/00332.jpg)

* 扩展主存字数：字扩展
* 数据总线宽度>存储字长：位扩展
* 现在的计算机mar、mdr通常集成在CPU内部存储芯片内只需一个普通的寄存器（暂存输入、输出数据）

![](/img/143726.jpg)

##### 存储芯片的输入输出信号

![](/img/44212.jpg)

##### 增加主存的存储字长-位扩展

![](/img/144756.jpg)

![](/img/145142.jpg)

##### 增加主存的存储字数-字扩展

![](/img/194708.jpg)

* 没有完全发挥cpu的寻址能力
* 线选法

![](/img/193028.jpg)

* 译码器片选法
  * 1-2译码器：输入一位地址信息，有可能呈现出2的1次放两种不同的状态

![](/img/94343.jpg)

![](/img/194539.jpg)

##### 主存容量扩展-字位同时扩展

![](/img/194940.jpg)

##### 译码器

![](/img/195225.jpg)

![](/img/195315.jpg)

![](/img/195936.jpg)

![](/img/200005.jpg)

![](/img/200357.jpg)

* MREQ：主存储器请求

### 3.4 外部存储器

#### 3.4.1 磁盘存储器

![](/img/211236.jpg)

##### 外存储器

![](/img/01737.jpg)

* 读写以1bit为单位
* 读写两个动作不可以同时进行

##### 磁盘存储器

![](/img/202126.jpg)

![](/img/202534.jpg)

![](/img/203504.jpg)

* 格式化容量比非格式化容量要小

![](/img/204954.jpg)

![](/img/205448.jpg)

![](/img/205543.jpg)

* 寻道时间一般是平均时间
  * 旋转时间可以取转半圈所需要的时间（如果没有明确给出时间），根据转速求出转半圈所需要的时间，也可以算出来转一个扇区所需要的时间

* 磁盘上每一个扇区所能存储的二进制数据都是相同的，外侧和内侧扇区虽然看起来磁道长度不一样，但是存储的bit数量相同
  * 意味着越靠近内测的磁道位密度越大

![](/img/205856.jpg)

* 盘面和磁头一一对应，每个盘面编号，根据盘面号知道激活哪个磁头

![](/img/210628.jpg)

##### 磁盘阵列

![](/img/210751.jpg)

![](/img/210852.jpg)

![](/img/211100.jpg)

![](/img/211210.jpg)

* 越往后的方案，冗余信息的占比会越少，可靠性和安全性会逐步增加

#### 3.4.2 固态硬盘SSD

![](/img/212853.jpg)

##### 固态硬盘的结构

* 逻辑地址经闪存翻译层的翻译之后，会把逻辑地址映射到某个物理地址，地址变换的工作

* 块大小：16KB-512KB
* 页大小：512B-4KB（读写以页为单位）
* 固态硬盘的一个页相当于磁盘的一个扇区
* 固态硬盘的一个块相当于磁盘的一个磁道
* 读多写少的块被迁移到更老的块中，更新的块中承担写操作更多的任务

![](/img/14112.jpg)

![](/img/214215.jpg)

### 3.5 高速缓冲存储器

#### 3.5.1 Cache的基本概念和原理

##### 存储系统存在的问题

![](/img/14325.jpg)

##### cache工作原理

![](/img/214432.jpg)

![](/img/14554.jpg)

![](/img/220410.jpg)

##### 局部性原理

![](/img/220727.jpg)

##### 性能分析

![](/img/221032.jpg)

![](/img/24406.jpg)

##### 有待解决的问题

![](/img/224513.jpg)

![](/img/224720.jpg)

![](/img/224940.jpg)

![](/img/225022.jpg)

#### 3.5.2 Cache和主存的映射方式

![](/img/231830.jpg)

![](/img/225307.jpg)

![](/img/225439.jpg)

##### 全相联映射（随意放）

![](/img/225738.jpg)

![](/img/225929.jpg)

##### 直接映射（只能放固定位置）

![](/img/230122.jpg)

![](/img/230247.jpg)

![](/img/230322.jpg)

* 块内地址=log2（cache容量/每块的容量）
* 主存块号标记=log2（主存容量/cache容量）

##### 组相联映射（可放到特定分组）

![](/img/231801.jpg)

#### 3.5.3 Cache替换算法

![](/img/233919.jpg)

![](/img/231958.jpg)

##### 随机算法（RAND)

![](/img/232155.jpg)

##### 先进先出算法（FIFO）

![](/img/232402.jpg)

##### 近期最少使用算法（LRU）

![](/img/232553.jpg)

![](/img/232721.jpg)

![](/img/232949.jpg)

![](/img/233135.jpg)

##### 最不经常使用算法（LFU）

![](/img/233316.jpg)

![](/img/233509.jpg)

![](/img/33840.jpg)

#### 3.5.5 Cache写策略

![](/img/000548.jpg)

##### 写命中

###### 写回法

![](/img/234426.jpg)

###### 全写法

![](/img/35316.jpg)

![](/img/235443.jpg)

![](/img/235521.jpg)

##### 写不命中

###### 写分配法

![](/img/235851.jpg)

###### 非写分配法

![](/img/00205.jpg)

##### 多级Cache

![](/img/000352.jpg)

### 3.6 存储器

#### 3.6.1 页式存储器

![](/img/10117.jpg)

![](/img/001742.jpg)

![](/img/002204.jpg)

##### 虚地址vs实地址

![](/img/104737.jpg)

##### 页表：逻辑页号→主存块号

![](/img/104954.jpg)

##### 地址变换过程

* CPU会把指令里边指明的逻辑地址拆分为逻辑页号和页内地址

![](/img/105531.jpg)

##### 地址变换过程（增加TLB）

* cache里面存储的，是我们某一些主存块的数据的一个副本，是一整块一整块调进去
  * 快表里面存储的是慢表的某一些列表项的副本

![](/img/110029.jpg)  

#### 3.6.2 虚拟存储器 

##### 页式虚拟存储器·

![](/img/110926.jpg)

![](/img/111023.jpg)

##### 存储器的层次化结构

![](/img/11139.jpg)

##### 段式虚拟存储器

![](/img/111336.jpg)

![](/img/111510.jpg)

##### 段页式虚拟存储器

![](/img/11557.jpg)

##### 各种地址

* 注：直接映射中，标记+行号=主存地址
  * 全相联映射中，标记+块内地址=主存地址
  * 组相联映射中，标记+Cache组号+块内地址=主存地址
    * 标记+Cache组号=主存块号

| Cache和主存直接映射     | 标记（主存中块的编号） | Cache行号 | 块内地址 |
| ----------------------- | ---------------------- | --------- | -------- |
| Cache和主存的全相联映射 | 标记（主存块号）       | 块内地址  |          |
| Cache和主存的组相联映射 | 标记                   | Cache组号 | 块内地址 |
| 逻辑地址                | 页号                   | 页内地址  |          |
| 物理地址                | 块号                   | 块内地址  |          |

* cache组号＝主存地址/块大小 % cache组数

* cache组号＝主存块号 % cache组数
* cache组数＝cache总容量/cache块大小/n
* cache行的总位数=有效位+可能存在的脏位+标记位+数据位
* 主存位大小=cache位大小
* cache的总容量包括存储容量和标记阵列容量（有效位、标记位、一致性维护位和替换算法控制位）

## 第四章 指令系统

### 4.1 指令系统

#### 4.1.1 指令格式

* 有的指令不需要地址码（停机）

![](/img/154539.jpg)

##### 指令的定义

![](/img/111510.jpg)

##### 指令格式

![](/img/234908.jpg)

##### 零地址指令

* 只需要操作码不需要地址码
* 操作数固定地隐含在某一个特定的位置，可能出现零地址指令

![](/img/235205.jpg)

##### 一地址指令

![](/img/235439.jpg)

##### 二、三地址指令

* 二地址指令
  * 括号内的是操作数的来源，箭头指向的是运算完成后结果存放的地方 ，一般默认存放在A1指向的地址

![](/img/141844.jpg)

* 三地址指令
  * 会给出最终的结果存放的地址

![](/img/141931.jpg)

##### 四地址指令

![](/img/142044.jpg)

![](/img/142940.jpg)

* 指令总长度固定不变，地址码的数量越多，单个地址码的位数就越少，寻址能力就越差 

##### 指令-按地址码数目分类

![](/img/43458.jpg)

##### 指令-按指令长度分类

* 机器字长通常和CPU有关，存储字长一般和主存有关，二者固定不变

 ![](/img/145301.jpg)

![](/img/145315.jpg)

##### 指令-按操作码长度分类

![](/img/154147.jpg)

* 定长指令字结构+可变长操作码
  * 指令的总长度固定不变，但是操作码的位数可以改变

##### 指令-按操作类型分类

 ![](/img/54408.jpg)

#### 4.1.2 扩展操作码指令格式

![](/img/154713.jpg)

指令=地址码+操作码

##### 扩展操作码

![](/img/223102.jpg)

![](/img/225012.jpg)

![](/img/225626.jpg)

* 所有的二地址指令开头一定为1111
* 所有的一地址指令开头一定为1111 1111
* CPU在取得指令的时候，一定是直接读入16位，根据开头的这几位是否为全一，CPU就可以判断这是一条三地址指令还是二地址指令
  * 开头四位全1，后四位不全为1，二地址指令
* 操作码越短，这个操作码的指令译码和分析的时间可以减短 ，电路设计起来更简单

###### 举例

![](/img/005809.jpg)

![](/img/005951.jpg)

![](/img/010539.jpg)

* 多地址在上层，少地址在下层
* 因为只需要12条2地址指令，所以范围是0000-1011，因此当开头两位为11的时候，超出了范围，所以一地址指令的开头为11
* CPU一次性读入16个bit，然后先检查前4位，如果前4个bit不是全1的状态，说明是3地址指令，然后CPU会按照三地址指令的规则执行指令
  * 如果前4个bit全为1，检查后两位，如果后两位不全为1，说明是一条二地址指令，CPU会按照二地址指令的规则执行指令
  * 如果前6位bit全为1，cpu会继续检测后面的五位是不是全1，如果不是，说明是1地址指令，然后CPU根据前12位执行相应的二地址指令 

##### 指令操作码

![](/img/010628.jpg)

### 4.2 指令的寻址方式

#### 4.2.1 指令寻址

![](/img/60135.jpg)

![](/img/023752.jpg)

![](/img/025305.jpg)

![](/img/55143.jpg)

![](/img/055539.jpg)

![](/img/060022.jpg)

 ![](/img/060103.jpg)

#### 4.2.2 数据寻址

![](/img/062042.jpg)

![](/img/060449.jpg)

![](/img/060559.jpg)
![](/img/060640.jpg)

##### 直接寻址

![](/img/060919.jpg)

##### 间接寻址

![](/img/227.jpg)

* A表示的是地址，（A）表示的是这个地址所指向的储存单元里边的数据

![](/img/061305.jpg)

![](/img/061402.jpg)

![](/img/061515.jpg)

##### 寄存器寻址

![](/img/061650.jpg)

##### 寄存器间接寻址

![](/img/061808.jpg)

##### 隐含寻址

 ![](/img/061850.jpg)

##### 立即寻址

![](/img/062014.jpg)

#### 4.2.3 数据寻址之偏移寻址



![](/img/062204.jpg)

![](/img/062251.jpg)

![](/img/64933.jpg)

##### 基址寻址

![](/img/2554.jpg)

![](/img/062741.jpg)

* 便于程序浮动：
  * 当这个程序在主存当中的位置发生改变之后，操作系统只需要修改BR这些寄存器里的内容

![](/img/062907.jpg)

![](/img/63001.jpg)

![](/img/063046.jpg)

##### 变址寻址

![](/img/063150.jpg)

![](/img/063331.jpg)

![](/img/063614.jpg)

![](/img/063659.jpg)

![](/img/063747.jpg)

![](/img/063943.jpg)

![](/img/064318.jpg)

 ![](/img/064637.jpg)

![](/img/822.jpg)

* 基址寻址所说的浮动指的是整段程序在内存里的浮动，相对寻址所说的浮动是指一段代码在程序内部的浮动

##### 硬件如何实现数的比较

 ![](/img/065121.jpg)

![](/img/065240.jpg)

#### 4.2.4 数据寻址之堆栈寻址

![](/img/70536.jpg)

![](/img/073638.jpg)

* 硬堆栈因为实在寄存器里，因此不需要访存，而软堆栈是划分出主存的一块区域作为堆栈，因此需要访存

![](/img/074212.jpg)

![](/img/4447.jpg)

### 4.3 程序的机器级代码表示

* 考试要求：x86汇编语言，若考察其他汇编语言题目会详细注释
* 题目给出某段简单程序的C语言、汇编语言、机器语言表示，能结合C语言看懂汇编语言的关键语句（看懂常见指令、选择结构、循环结构、函数调用） 
* 汇编语言、机器语言一一对应，一条汇编语言指令对应一条机器语言指令，要能结合汇编语言分析机器语言指令的格式、寻址方式
* 不会考：将C语言人工翻译为汇编语言或者机器语言

#### 4.3.1 高级语言与机器级代码之间的对应

* 汇编语言和机器语言表示的代码就是机器级代码

![](/img/1832.jpg)

##### x86汇编语言指令基础

intel x86架构cpu

起源：代号为8086的CPU

![](/img/95522.jpg)

![](/img/195729.jpg)

* 中括号：内存地址，前面指明此次要读写的数据是多少bit（长度），末尾的h是16进制的意思

##### x86架构cpu的寄存器

* X86内，E开头的寄存器长度都是32bit
* mov eax，ebx相当于寄存器寻址

![](/img/200037.jpg)

![](/img/200210.jpg)

![](/img/0747.jpg)

* EBP指向栈底
* ESP指向栈顶

![](/img/01138.jpg)

![](/img/201320.jpg)

* 考试中中括号内不是主存地址而是寄存器地址，则采用的是寄存器间接寻址方式，寄存器指向的贮存地址的内容位复制内容

![](/img/201422.jpg)

![](/img/201611.jpg)

![](/img/201653.jpg)

#### 4.3.2 常用的x86汇编指令

![](/img/202108.jpg)

##### 常见的算术运算指令

* 算术运算完的结果会放回到d所指的位置，因此d只有可能来自寄存器或者主存，不可能是常量

![](/img/205837.jpg)

* 除法中，s是除数，被除数会被提前放到edx和eax两个寄存器当中，左后商存入eax，余数存入edx（隐含寻址）
  * 在进行除法运算之前，需要把被除数进行位扩展，更高的32位存放在edx，更低的32位存放在eax

![](/img/22804.jpg)

![](/img/222937.jpg)

* x86汇编语言不允许两个操作数都同时来自于主存，主要为了保证指令不要太多次访存，以免影响指令速度

##### 常见的逻辑运算指令

* 目的操作数不能是常数，最后存放在目的操作数所指向的地址中

![](/img/223258.jpg)

![](/img/223334.jpg)

##### 其他指令

![](/img/3410.jpg)



#### 4.3.3 AT&T格式和Intel格式

##### AT&T格式 vs Intel 格式

![](/img/223456.jpg)

![](/img/223751.jpg)

* 基址+变址*比例因子能够找到我们想要找的数组元素，而一个数组元素里边可能会包含很多变量，到底访问哪一个变量或者哪个字节通过偏移量指明

![](/img/104.jpg)

#### 4.3.4 选择语句的机器级表示

##### 程序中的选择语句（分支结构）

* IP寄存器就是PC（程序计数器）

![](/img/224314.jpg)

![](/img/224349.jpg)

##### 无条件转移指令——jump

![](/img/224420.jpg)

![](/img/224516.jpg)

* 汇编语言里面的“：”相当于一个标号，标记了一个位置

![](/img/30708.jpg)

![](/img/230932.jpg)

##### 条件转移指令——jxxx

![](/img/231132.jpg)

![](/img/231219.jpg)

##### 示例：选择语句的机器级表示

![](/img/231537.jpg)

![](/img/231608.jpg)

![](/img/232054.jpg)

![](/img/3232147.jpg)

![](/img/2204.jpg)

![](/img/232548.jpg)

##### 扩展：cmp指令的底层原理

![](/img/232759.jpg)

![](/img/32929.jpg)

#### 4.3.5 循环语句的机器级表示

##### 用条件转移指令实现循环

![](/img/233053.jpg)

![](/img/000049.jpg)

![](/img/000239.jpg)

##### 用loop指令实现循环

![](/img/000841.jpg)

![](/img/00934.jpg)

* 注：ecx作为循环计数器，不可以用其他寄存器替代

* 理论上，能用loop指令实现的功能一定能用条件转移指令实现，使用loop指令可能会使代码更清晰简洁

![](/img/001351.jpg)

* loopnz和loopz比较的是最近一次进行的运算的结果

#### 4.3.6 函数调用的机器级表示

![](/img/53449.jpg)

![](/img/153538.jpg)

![](/img/153613.jpg)

![](/img/153652.jpg)

##### 高级语言的函数调用

![](/img/001836.jpg)

* return之后会删除函数的栈帧
* 程序运行的时候，系统会为它分配一片内存区域，叫做函数调用栈

![](/img/003130.jpg)

![](/img/03155.jpg)

##### x86汇编语言的函数调用

* x86汇编语言中通常用“函数名 ：”来表示接下来的这些指令是函数内容

##### call、ret指令

![](/img/011146.jpg)

![](/img/115751.jpg)

![](/img/14115837.jpg)

![](/img/5909.jpg)

![](/img/115947.jpg)

##### 总结：函数调用的机器级表示

![](/img/120328.jpg)

![](/img/35052.jpg)

![](/img/145231.jpg)

![](/img/145444.jpg)

![](/img/35141.jpg)

![](/img/5211.jpg)

##### 函数调用栈在内存中的位置

* 高地址的1gb属于操作系统内核区，低地址的这3gb可以由用户进程使用

![](/img/120712.jpg)

##### 标记栈帧范围：EBP、ESP寄存器

![](/img/15.jpg)

![](/img/22346.jpg)

![](/img/123038.jpg)

![](/img/123140.jpg)

![](/img/124058.jpg)

![](/img/124203.jpg)

![](/img/124238.jpg)

##### 访问栈帧数据：mov顶部

![](/img/4124439.jpg)

![](/img/124502.jpg)

##### 总结：如何访问栈帧

![](/img/130127.jpg)

##### 函数调用时切换栈帧的方式

![](/img/132713.jpg)

![](/img/133419.jpg)

![](/img/132900.jpg)

![](/img/133341.jpg)

![](/img/dsaveweww.png)

* enter
  * push ebp  把ebp的地址信息压栈保存到栈顶的位置
  * mov ebp，esp 把esp寄存器里面的值复制到ebp，即让ebp指向esp当前所指的位置
    * 图中add函数的栈帧底部存储的是caller函数的基地址
* 当函数执行结束，要返回之前，总能在当前函数的栈帧底部找到上一层函数的基地址，这样就可以恢复ebp寄存器的值
* leave
  * mov esp，ebp，把ebp的值赋值给esp，让esp和ebp指向同一个位置，即当前栈帧的底部
  * pop ebp，让esp所指元素出栈并且写入ebp，即让ebp指向上一层函数栈帧基址，然后esp+4指向IP旧值
* 每一个函数的栈帧底部一定是存储了它上一层函数的基地址
* enter指令是零地址指令，指令后面不需要跟任何的操作数
  * enter= push ebp + move ebp，esp
* ret函数的作用是从函数的栈帧顶部找到IP寄存器旧值，并且取出这个值写入IP寄存器，也就是让程序的执行流回到call指令的后面这条指令继续往后执行

##### 函数返回时，切换栈帧的方法

![](/img/134326.jpg)

* mov esp，ebp

![](/img/134545.jpg)

* pop ebp

  * esp+4往上挪一位，栈顶元素的值会被复制到ebp，让ebp的值等于上一层函数的栈帧基址

    * 之后可能再pop ip，将esp所指的指令存入ip寄存器，然后esp彻底指向上一层函数栈的栈顶

    * 在某年真题中出现了cmp ebp，esp的语句，这句诗在move esp，ebp之前进行栈平衡检查的，正常情况下esp应该比ebp高4个字节（esp=ebp-4），如果esp=ebp，意味着栈帧释放过度（如多pop了数据），可能引发崩溃，此为认为添加的安全校验，非CPU比须步骤

    * leave =mov esp，ebp + pop ebp

      return = pop ip

![](/img/34824.jpg)

![](/img/134900.jpg)

![](/img/134940.jpg)

##### 一个栈帧内可能包含的内容

* 图中caller函数的栈帧最底部是p函数的栈帧基址
* 图中caller函数的栈帧最顶部是当前函数的返回地址
* 题目中出现[ebp-4] [ebp-8]，里面存储的肯定是函数内部定义的最后一个变量和倒数第二个变量

![](/img/135935.jpg)

* 如果看到[ebp+8]和[ebp+12]则该地址对应的一定是当前执行的函数的参数列表中调用的第一个和第二个参数
* 只有当前正在运行的函数不受栈帧大小的限制，但是只要该函数需要再调用下一层函数，则栈帧大小必须是16字节的整数倍

![](/img/40415.jpg)

![](/img/140505.jpg)

* 传递调用参数的方法：
  * 在call指令发起函数调用之前，需要把调用的参数写入到当前这个函数的栈帧顶部区域

![](/img/45401.jpg)

##### 汇编代码实战

* ebp和esp指明了当前执行的caller函数的范围
* mov指令不支持两个操作数都来自主存
* 局部变量初始化

![](/img/143611.jpg)

* 若干个调用函数

![](/img/143636.jpg)

* ip返回地址

![](/img/3808.jpg)

* 压入上一层栈帧基址

![](/img/143935.jpg)

* 访问参数

![](/img/44034.jpg)

* 相加

![](/img/144112.jpg)

* 返回
  * return指令是让从esp从ip（返回地址）回到上一层函数的esp

![](/img/144215.jpg)

![](/img/144328.jpg)

![](/img/144459.jpg)

![](/img/144906.jpg)

![](/img/144953.jpg)

* 函数调用返回的时候，只需要有一个返回值，因此返回值通常存到eax中，因此当返回上一层函数的时候，只需要去eax寄存器中取这个值就可以获得函数结果了

### 4.4 CISC和RISC

* CISC：复杂指令集的计算机系统
* RISC：精简指令集的计算机系统

![](/img/54007.jpg)

* 微程序：CPU对外提供的某些复杂的指令功能，在内部是用某些更简单的功能组合来实现复杂的指令

![](/img/55043.jpg)

![](/img/155118.jpg)

* 组合逻辑控制方式效率更高，微程序控制方式效率较低

## 第五章 中央处理器

### 5.1 CPU的功能和基本结构

![](/img/003837.jpg)

##### CPU的功能

![](/img/220504.jpg)

##### 运算器和控制器的功能

![](/img/222536.jpg)

##### 运算器的基本结构

![](/img/4434.jpg)

* 专用数据通路

![](/img/224738.jpg)

* CPU内部单总线方式

![](/img/002854.jpg)

![](/img/003005.jpg)

##### 控制器的基本结构

![](/img/003536.jpg)

地址码输出到内部总线，操作码送到操作单元CU

加E代表和外部的数据总线的关系

##### CPU的基本结构

![](/img/003735.jpg)

![](/img/003751.jpg)

![](/img/003802.jpg)

### 5.2 指令周期的数据流

![](/img/141046.jpg)

##### 指令周期     

![](/img/004149.jpg) 

![](/img/0047213634.jpg)

* CLK：时钟脉冲，一个方波就是一个时钟周期
  * 例：3.0GHz的主频意思是说这个CPU每秒钟可以发出3.0G次的时钟周期，会有3.0G个节拍
* 取指令需要靠一些微操作

![](/img/24810.jpg)

* 机器周期指的是我们完成了某一步，某一个完整的子工作所需要的时间，这就是一个机器周期，一个机器周期需要由多个时钟周期组成。
* 如果说完成所有子工作所需要的时钟周期都是相同的，意味着所有的机器周期的长度也是相同的，这种CPU就是定长机器周期的CPU
* 不同的指令执行所需要的时间，也就是指令周期的长度有可能是不一样的
* CPU时钟周期（时钟周期）→（组成）机器周期（CPU周期）→（组成）指令周期

![](/img/34901.jpg)

* 空指令再整个指令周期只做了取指令和分析指令两件事情，这条指令的指令周期只包含了一个机器周期
* 对于采用间接寻址的指令来说，当我们取出这条指令，分析指令之后，还需要把指令当中包含的这个形式地址翻译成最终的有效地址，具体的做法就是根据这个地址，先去进行一次访存，先读出储存当中存放的这个地址信息，这个地址信息才是我们最终7要访问的操作数的存放地址。间址周期就是从形式地址得到有效地址的一段时间，这段时间内也需要进行访存。

##### 指令周期流程

![](/img/135112.jpg)

##### 指令周期的数据流-取指周期

![](/img/135420.jpg)

* M（MAR）的意思是主存当中MAR所指向的数据

![](/img/135609.jpg)

![](/img/135904.jpg)

##### 指令周期的数据流-执行周期

![](/img/135940.jpg)

##### 指令周期的数据流-中断周期

![](/img/140428.jpg)

##### 指令执行方案

* 采用单指令周期，意味着对于任何一条指令，它的指令周期都会延长为和最慢的那条指令相同，可能造成时间浪费，但是好处是当设计指令执行的控制电路的时候，只需要根据节拍数就能确定一条指令的执行是否结束，可以使得控制电路设计起来更方便一些

![](/img/140938.jpg)

### 5.3 数据通路的功能和基本结构

#### 5.3.1 数据通路-单总线结构

![](/img/030252.jpg)

##### 指令周期的数据流

* 在指令执行的整个过程当中，数据的流动也逃不过这三种
  * 寄存器与寄存器之间 
  * 寄存器与主存之间
  * 寄存器与ALU之间

![](/img/175251.jpg)

##### 数据通路

![](/img/175352.jpg)

* 图中采用的是CPU内部单总线方式，即所有的这些寄存器之间交换数据，都是通过一个CPU的内部总线来完成的，在同一时刻只允许两个部件之间进行数据交换，他们对总线的使用是独占式的，当这两个部件之间进行数据交换的时候，就不允许另外两个部件之间进行数据交换
* 输入输出信号都是由控制器CU发出的

##### 数据通路-CPU内部单总线方式

* Bus就是总线
* 在描述数据流动的同时需要标明哪些控制信号是有效的
* (PC)表示取出PC的内容
* 每个微操作的执行至少需要一个时钟周期，每一个时钟周期内，CU都会发出一组相应的控制信号，来完成其中的某一个微操作，到下一个时钟周期,CU又发出第二个控制信号来完成第二个微操作

###### 寄存器之间的数据传送

![](/img/005125.jpg)

###### 主存与CPU之间的数据传送

![](/img/021700.jpg)

* PC指明了我们要读取的指令存放在什么地址
  * 最开始把PC的内容放到MAR当中
  * 地址信息准备完成之后，应该撤销刚才的那两个控制信号，让总线空闲
  * 接下来由于要对主存进行读操作，因此CU需要对主存发出读信号，这个信号的发出是通过控制总线来进行的（图中并没有画出控制总线）
  * 现在主存已经知道要进行的是读操作，应该读的地址是存放在MAR当中，通过地址总线传送给主存
  * 主存根据MAR所指示的这个地址，读出相应的数据，然后把这个数据放到MDR当中，这个数据的传送时通过数据总线
    * MDR与主存之间的数据通路，MAR与主存之间的数据通路，会用专门的一个控制信号来进行控制
* 关键在于，我们必须指明我们要操作的主存地址是什么样
  * 另外答题的时候也不能忘记，CU需要向这个主存发送一个读或写的控制信号

###### 执行算数或逻辑运算（寄存器到寄存器）

![](/img/024052.jpg)

* 参与加法运算的其中一个操作数已经被存放在ACC里面了，另一个操作数会由这条加法指令，直接指明这个操作数的存放地址，存放在主存里的什么位置。
  * 首先需要根据指令的地址码部分，来读取出参与加法运算的另一个操作数，具体的做法就是把这条指令的地址码部分，通过内部总线传送到MAR当中（由于此前IR的数据是从MDR传送到IR当中，因此也可以从MDR输出后输入到MAR当中）
  * CU向主存发出读的控制信号
  * 主存收到地址信息，同时又收到了读信号，把相应的存储单元里的数据，通过外部的数据总线送到MDR当中
  * 已经取出加法的操作数，需要把它放到暂存寄存器Y当中（因为内部总线同一时刻只能传送一个输入信号，因此只能把其中一个操作数放到暂存寄存器当中，另一个操作数已经存放在ACC当中）
  * 让ACC累加寄存器的输出这个通路接通，让ALU的这个输入通路让它接通，ACC里的数通过内部总线传送给ALU
  * ALU执行加法操作，运算的结果会被输出到暂存寄存器当中

* ALU的两个输入信号必须同时有效，而CPU的内部总线同一时刻只能传送一个输入信号，因此不得不把其中的一个操作数先放到暂存寄存器Y当中，暂存寄存器与ALU之间有一个专用的数据通路，他们之间的数据传送不会占用内部总线，接下来另一个操作数的传送就可以通过内部总线来完成
  * 如果采用单总线的结构，在执行算数或者逻辑运算的时候，必须把其中的一个操作数放到暂存寄存器当中
  * 如果采用爽内部总线或者多个内部总线，可以不设置这个暂存寄存器，可以通过其他内部总线传送到ALU当中
* 单总线的设计方式可以使硬件的设计成本更低，多总线的设计方式成本更高，但是又可以使得数据的传输更有效率
  * 考试中通常遇到的还是单总线的情况

##### CPU内部单总线方式-例题

![](/img/25331.jpg)

* 没有打括号说明操作数直接存放在R1这个寄存器当中的，而左边这个目的操作数R0的外面打了一个括号，说明我们需要进行一次简介寻址
  * 即R0存放的是这个操作数在主存当中的存储地址
* 因为是加法指令，最终的运算结果又会被放回到目的操作数的位置
* 取指周期

![](/img/025631.jpg)

* 双重括号意味着寄存器间接寻址

* 间址周期

![](/img/25825.jpg)

* 执行周期

![](/img/030136.jpg)

#### 5.3.2 数据通路-专用通路结构

![](/img/44646.jpg)

##### 专用数据通路方式

![](/img/42107.jpg)

##### 专用数据通路方式-取指周期

![](/img/142340.jpg)

* 如果题目中没有给出IR到CU的控制信号的具体名字，就不用写

##### 专用数据通路方式-例题

* 和主存直接相连的寄存器只有MAR和MDR两个，MAR里面存储的数据只有可能是单向地传送给主存，而MDR和主存可能读或者写，应该是有可能进行双向的交互

![](/img/143221.jpg)

![](/img/43247.jpg)

![](/img/43450.jpg)

* ALU不是寄存器，这个部件没有数据存储的功能

![](/img/144207.jpg)

![](/img/144345.jpg)

* X是一个值而不是寄存器，所以外面不用打括号

![](/img/144508.jpg)

![](/img/03129.jpg)

### 5.4 控制器的功能和工作原理

#### 5.4.1 硬布线控制器的设计

* 每个时钟周期又可以称为一个节拍，控制单元CU会在每一个节拍内发出一个微命令用来完成对应的微操作，微命令就是与微操作对应的控制信号
* 如果两个微操作的执行不会相互冲突，不会相互制约，可以把多个微操作安排在一起，即同时发出多条微指令，让CU在一个节拍内能完成更多的事情

![](/img/230124.jpg)

##### 硬布线控制器

![](/img/233258.jpg)

* 定长机器周期下，每一个机器周期所包含的节拍数都是相等的 

![](/img/233325.jpg)

##### 硬布线控制器的设计

* 考试不考具体的设计

![](/img/233941.jpg)

![](/img/01502.jpg)

![](/img/003103.jpg)

##### 分析每个阶段的微操作序列

![](/img/234515.jpg)

##### 安排微操作时序的原则

![](/img/234634.jpg)

* 取指周期

![](/img/234847.jpg)

* 间址周期

![](/img/234921.jpg)

* 执行周期

![](/img/235104.jpg)

![](/img/235201.jpg)

![](/img/000249.jpg)

##### 组合逻辑设计

![](/img/00329.jpg)

* 取指阶段的操作时间表

![](/img/000510.jpg)

* 间址阶段的操作时间表

![](/img/000629.jpg)

* 执行周期的操作时间表

![](/img/000754.jpg)

##### 微操作信号综合

![](/img/001012.jpg)

##### 画出逻辑图

![](/img/001106.jpg)

#### 5.4.2 微程序控制器的基本原理

![](/img/013112.jpg)

##### 微程序控制器的设计思路

* 微操作强调的是我们要做什么，而微命令强调我们要完成这个微操作需要发出哪一个控制信号

* 微指令序列也是存储在控制器内部的一个特殊的存储器当中的，每一条微指令都会对应一个存储的地址

![](/img/003945.jpg)

##### 微程序控制器的基本结构

* 每一种机器指令会对应一段微程序
  * 一个微程序会由一系列微指令序列组成
    * 这些微指令序列在这个控制存储器里面里边会顺序的存放
  * ROM的读取速度非常快，且是一种非易失性的存储芯片，即CPU断电之后，这个ROM芯片当中存储的这些微程序是不会丢失的
* 主存里面存储了一些指令序列（机器指令序列），CPU每次要从主存当中读出一条机器指令，为了指明这条机器指令的存放位置，CPU内部会有一个MAR（地址寄存器）
  * CMAR类似于PC和MAR的集合体
  * MAR给出的地址信息需要通过一个译码器的处理，才可以选中主存的某一个存储单元；
    * 对于CU内部的CMAR来说，同样需要把这个地址信息送给一个地址译码器，通过地址译码器把地址转换成CM当中对应的存储单元的一个存取的控制信号

![](/img/005641.jpg)

* 微地址形成部件：外部的一条机器指令被取到IR当中，不同的机器指令所对应的微指令序列，即所对应的微程序不一样，因此需要根据该机器指令的操作码来确定其所对应的微程序的起始地址
  * 功能：根据机器指令的操作码来确定这个机器指令对应的微指令序列的一个首地址
* 当CPU取到一条指令之后，执行指令的过程：
  * 首先把指令的操作码送给微地址形成部件，用来确定这条指令所对应的微指令序列的一个起始地址
  * 再根据顺序逻辑的标志信息来确定接下来我们要执行的这条微指令的存放地址，把微指令地址放到CMAR当中
  * 经过地址译码器的译码之后，就可以选中CMAR所指向的那条微指令
  * 取出这条微指令放到CMDR当中
    * 一条微指令需要包含两个部分的信息：
      * 描述这条微指令所对应的控制信号
      * 用来描述接下来要执行的微指令的一个地址（下地址）
  * 硬件电路根据这个微指令的控制码部分，向CPU内部和系统总线发出某些控制信号
  * 执行完微指令之后，把下地址的信息送给顺序逻辑，顺序逻辑结合上某些机器标志的信息，再来决定下一条应该执行的微指令的存放地址，然后再把下一条微指令的地址送给CMAR

![](/img/011155.jpg)

##### 微程序控制器的工作原理

![](/img/011718.jpg)

* 控制存储器CM里面存储的微指令序列，通常来说，取指周期、间址周期、中断周期所对应的这个微程序段只会有一份，让所有指令共享
  * 只有执行周期所对应的这个微程序，每一个机器指令都是不一样的

![](/img/12516.jpg)

* 如果没有间址周期的处理方式：
  * 指令的地址码部分，会有一些标志位来指明地址码采用直接寻址还是间接寻址，寻址特征位可以送给顺序逻辑
  * 如果顺序逻辑发现这个指令的地址码并不需要间接寻址，那么虽然刚才这条微指令送过来的下地址信息是3，但是经过顺序逻辑的处理，可以知道接下来要执行的不是间址周期的指令，而应该直接跳到这条指令所对应的执行周期对应的微指令序列
  * 根据这条指令的操作码，然后再通过微地址形成部件的处理之后，微地址形成部件会告诉顺序逻辑，现在执行的这条指令，执行周期所对应的微指令序列的首地址，然后把首地址的地址信息放到CMAR当中，指明接下来要执行的是13这条微指令
  * 因此经过这个取指周期之后，会直接跳到13来执行

![](/img/012717.jpg)

![](/img/12827.jpg)

![](/img/12945.jpg)

#### 5.4.3 微指令的设计

![](/img/145225.jpg)

![](/img/142606.jpg)

##### 微指令的格式

![](/img/142834.jpg)

![](/img/42850.jpg)

##### 微指令的编码方式

###### 直接编码方式

![](/img/143009.jpg)

![](/img/143644.jpg)

* 当执行这条微指令，即把这条微指令放到CMDR当中的时候，只需要把第一位连接的线连接到PCout和MARin当中即可，最后面一位也通过一根导线接到系统的控制总线，控制总先给主存发出读信号

###### 字段直接编码方式

![](/img/43947.jpg)

![](/img/144022.jpg)

![](/img/144440.jpg)

###### 字段间接编码方式

![](/img/44622.jpg)

##### 微指令的地址形成方式

* 测试网络值得就是顺序控制内部的一些处理的电路

![](/img/4900.jpg)

![](/img/44933.jpg)

###### 例题-断定方式

![](/img/145159.jpg)

#### 5.4.4 微程序控制单元的设计

![](/img/151514.jpg)

* 把可以并行的微操作安排在同一个节拍内进行
* 除了最后一条微指令之外，每条微指令结束之后都需要进行一次地址操作

* 微操作个数决定操作控制字段的位数，微指令总数确定顺序控制字段位数，二者加起来确定微指令字长

![](/img/151811.jpg)

![](/img/151834.jpg)

![](/img/150552.jpg)

* 区别在于最后一步
  * 对于硬布线控制器来说，把指令的操作码部分直接送给ID（指令译码器），然后指令译码器ID会发出与这个操作码相对应的那一根线的选通信号 
  * 对于微程序控制器来说，要把指令操作码送给微地址形成部件 ，然后由微地址形成部件来指明这条指令在接下来的执行周期所对应的微程序的起始地址

![](/img/0658.jpg)

![](/img/150813.jpg)

* PPT中的

![](/img/150921.jpg)

* 王道书中的

![](/img/151044.jpg)

##### 微程序设计分类

![](/img/152019.jpg)

##### 硬布线与微程序的比较

![](/img/152146.jpg)

##### 微程序控制器回顾

![](/img/152308.jpg)

![](/img/152336.jpg)

### 5.6 指令流水线   

#### 5.6.1 指令流水线的基本概念

![](/img/4203746.jpg)

##### 指令流水的定义

![](/img/185314.jpg)

![](/img/185523.jpg)

![](/img/185615.jpg)

![](/img/191909.jpg)

##### 流水线的表示方法

![](/img/192634.jpg)

![](/img/sss192649.jpg)

##### 流水线的性能指标

* 对于指令流水线来说，大多数情况下吞吐率指的就是单位之间内可以完成的指令的数量
* 每一个阶段理论上是对应一个机器周期，而一个机器周期有可能包含多个时钟周期

![](/img/201649.jpg)

![](/img/201947.jpg)

* 装入时间指的是第一条指令从取指一直到结束所需要的时间
* 排空时间指的是最后一条指令从运行到结束所需要的时间

![](/img/02149.jpg)

* 设备空闲的时间并不会随着n的增大而增大

![](/img/02426.jpg)

#### 5.6.2 指令流水线的影响因素和分类

![](/img/4946.jpg)

##### 机器周期的设置

* 五个阶段

  * IF（instruction fetch）取指阶段
    * 根据pc所指向的位置，去instructioncache里面找出当前要执行的指令，并且把取出的指令放在这个功能段的锁存器里面

  * ID（instruction decode）指令译码阶段
    * 除了完成指令译码的工作之外，还会完成取数的操作，把这条指令需要的操作数从通用寄存器中取出放到锁存器中
    * 在risk精简指令集的系统下，运算的操作数一定是直接来自于通用寄存器的，不可能直接来自于主存，如果来自主存也要先放到通用寄存器，再从通用寄存器中取出
  * EX（execute）执行阶段
    * ALU处理前面取出的两个操作数
  * M（memory）缓存阶段
    * 如果数据没有在cache中命中的话，要去访问主存，则可能出现断流的现象     
  * WB（write back）写回阶段
  * 五段式的指令流水线是MIPS架构所提出来的指令流水线，MIPS是世界上第一个精简指令集的指令系统
  * 有的指令可能会跳过其中的某些阶段，然而为了方便指令流水线的安排，即便有的指令在实际运行的时候不需要某个阶段的处理，所有的指令也都会被安排为这样的五个机器周期，在MIPS架构下，所有的指令一定都是五个机器周期。

![](/img/210922.jpg)

* 对MIPS架构来说，或者说精简指令集系统，我们通常都会规定每一条指令所包含的机器周期数相同，并且每一个机器周期的长度也相同，以便安排流水线

![](/img/211443.jpg)

##### 影响流水线的因素

![](/img/232012.jpg)

###### 结构相关-资源冲突

![](/img/222535.jpg)

![](/img/222836.jpg)

* 资源的重复配置
  * 把指令和数据分别放到不同的cache/存储体当中，取指阶段和保存阶段所需要的数据分别是指令和其他数据，采用这种方式可以解决资源冲突的互斥问题

###### 数据相关-数据冲突

![](/img/23030.jpg)

![](/img/223123.jpg)

![](/img/23206.jpg)

* 数据旁路技术就是直接把运算的结果接入到另一个指令的输入端

![](/img/223340.jpg)

![](/img/1225.jpg)

###### 控制相关-控制冲突

![](/img/31346.jpg)

![](/img/31944.jpg)

##### 流水线的分类

![](/img/232220.jpg)

![](/img/232307.jpg)

![](/img/232353.jpg)

![](/img/33712.jpg)

##### 流水线的多发技术

###### 超标量技术 （空分复用技术）

![](/img/04233848.jpg)

![](/img/3950.jpg)

###### 超流水技术 （时分复用技术）

![](/img/4658.jpg)

###### 超长指令字

![](/img/234852.jpg)

#### 5.6.3 五段式指令流水线

![](/img/015309.jpg)

##### 运算类指令的执行过程

* RISC精简指令集系统的运算结果一定是存回某一个寄存器而不可能直接存回主存，因此对于精简指令集的系统来说，在第五个阶段就是访存的阶段，运算类指令是不需要做任何事情的，不需要把结果写回主存
  * 在保存的阶段什么都不用做，但是时间必须消耗，因为为了流水线的安排，所有的指令都统一地经历五个阶段，即便某个阶段不需要做事情

![](/img/64904.jpg)

##### LOAD指令（取数指令）的执行过程

![](/img/5249.jpg)

* 第三阶段会把偏移量和基址进行相加并把结果（有效地址）放到EX阶段的锁存器当中
* 第四阶段根据刚才得到的有效地址，从cache当中取出想要的数据并放入锁存器
* 第五阶段将刚才得到的数放回到目标寄存器里面

![](/img/165351.jpg)

##### STORE指令的执行过程

* 取从右到左，存从左到右（取左存右）

![](/img/165712.jpg)

##### 条件转移指令的执行过程

* 此处的偏移量通常是指明要往前或者往后偏移多少条指令
  * 从下一条指令的地址开始偏移（因为取出指令之后PC自动+1）
* 偏移量是个立即数
* 此处的ALU用于运算判断条件是否成立
* 写回阶段通常来说都是修改通用寄存器里的这些值

![](/img/70225.jpg)

* 对于条件转移指令来说，写回阶段通常什么都不用做

![](/img/170346.jpg)

##### 无条件转移指令的执行过程

* 无条件转移指令的偏移量通常用补码表示

![](/img/170638.jpg)

##### 例题

![](/img/171113.jpg)

![](/img/71150.jpg)



### 5.7 多处理器的基本概念

* 只要求掌握各种各样的基本概念，只会出选择题，不可能考大题

#### 5.7.1 多处理器系统的基本概念

* 相同颜色的知识点很容易在选择题当中变成错误选项进行考察

#### 5.7.1 多处理器系统的基本概念

![](/img/173033.jpg)

![](/img/193222.jpg)

##### SISD

![](/img/73707.jpg)

* 单指令流的意思就是这个CPU同一时间段内只能处理一个指令序列
* 单数据流的意思是说每一条指令他只能处理1-2个数据
* 这个单核处理器在一个时间段内只能处理一个进程或者一个线程的这个指令序列，各个进程的指令序列只能并发地执行，不能并行地执行

![](/img/73845.jpg)

* 不是数据级并行技术
  * 只能处理1-2个数据，不可能并行地处理很多很多个数据

##### SIMD

* 每一时刻同样的只能执行一条指令，但是这一条指令的执行，可以同时处理很多歌具有相同特征的数据

![](/img/174137.jpg)

![](/img/174240.jpg)

##### MISD

![](/img/174331.jpg)

##### MIMD——共享存储多处理器系统（SMP）

* 线程级并行
  * 每一个核可以运行各自的线程，多个线程可以并行地执行
* 线程级以上并行——进程级并行
  * 每一个核分别处理一个进程

![](/img/192510.jpg)

![](/img/92611.jpg)

###### 多处理器系统

![](/img/192809.jpg)

###### 多计算机系统

![](/img/93021.jpg)

![](/img/94235.jpg)

##### 向量处理机

* 运算部件可以直接运算向量，寄存器可以直接存取向量，操作对象以向量为单位

![](/img/193945.jpg)

![](/img/194124.jpg)

#### 5.7.2 硬件多线程的基本概念

* 只要求掌握基本概念，一定只考选择题

##### 三硬件多线程

![](/img/94430.jpg)

![](/img/5194741.jpg)

![](/img/195003.jpg)

## 第六章 总线

### 6.1 总线概述

#### 6.1.1 总线概述

![](/img/095636.jpg)

![](/img/110644.jpg)

##### 总线简图

![](/img/095404.jpg)

##### 总线的物理实现

* 一个数据总线内部可能包含多根信号线，一个bit对应一根数据线

![](/img/95250.jpg)

##### 总线的定义和特点

![](/img/104134.jpg)

##### 总线的特性

![](/img/04316.jpg)

##### 总线的分类

![](/img/104344.jpg)

##### 串行总线与并行总线

* 串行一次传送一位数据
  * 抗干扰能力强，在长距离传输的时候数据不容易发生跳变
* 并行一次传输多个数据
  * 把多根信号线并行地布在一起的时候，这些信号线在传递信号的过程当中，由于他们之间的距离比较近，因此有可能会造成信息的干扰，导致数据跳变

![](/img/7104510.jpg)

![](/img/04821.jpg)

![](/img/143459.jpg)

##### 按总线功能的分类

![](/img/05442.jpg)

##### 系统总线

![](/img/104958.jpg)

![](/img/5055.jpg)

* 对于单根信号线来说，信号的传输方向是单向的

![](/img/105351.jpg)

##### 系统总线的结构

###### 单总线结构

![](/img/105615.jpg)

![](/img/05721.jpg)

* CPU和主存的传输速度快，但是外设的传输速度慢，因此虽然能够支持很快的速度传输，但使用快速的系统总线来让慢速的设备传送数据的时候，快速的性能是被浪费的

###### 双总线结构

* 通道类似于一个阉割版的小CPU，是用来控制外部设备的，外部设备通过通道和CPU进行交互

![](/img/110022.jpg)

###### 三总线结构

* 三个总线同一时刻只能有一个总线在工作

![](/img/110353.jpg)

###### 四总线结构

![](/img/110527.jpg)

#### 6.1.2 总线的性能指标

![](/img/113713.jpg)

![](/img/142910.jpg)

![](/img/143608.jpg)

![](/img/143634.jpg)

###### 总线的传输周期

![](/img/112904.jpg)

* 一个总线周期就是指要利用总线来传输一组数据所需要的时间

###### 总线的时钟周期

![](/img/113318.jpg)

![](/img/113515.jpg)

##### 总线性能指标——带宽（例题）

* 数据线和地址复用：数据线和地址线共用（分时使用）

![](/img/143151.jpg)

![](/img/143329.jpg)

![](/img/143400.jpg)

##### 总线的性能指标总结

![](/img/143803.jpg)

### 6.2 总线事务和定时

![](/img/53438.jpg)

##### 总线传输的四个阶段

* 寻址寻的是想要读或者写的设备是哪一个

![](/img/150031.jpg)

##### 同步定时方式-读命令

* 图中低电平有效    

![](/img/151819.jpg)

![](/img/151945.jpg)

##### 异步定时方式

![](/img\152127.jpg)

* 半互锁方式中，请求信号受到回答信号的制约，而回答信号不受到请求信号的制约

![](/img/52408.jpg)

![](/img\152728.jpg)

##### 半同步通信

![](/img/153019.jpg)

* 当从设备跟不上节奏的时候，就会通过控制线路给这个总线的控制器进行一个反馈，让总线控制器等自己几个节拍
* 可以动态地调整每一个传输周期内包含的时钟节拍数，能够支持速度差异比较大的主设备和总设备之间进行数据的交互

##### 分离式通信

![](/img/153346.jpg)

* 充分利用从设备准备数据的这段时间，这段时间把总线的使用权分配给其他设备来使用，从而让总线的数据传输效率变得更高

## 第七章 输入/输出系统

### 7.1 I/O系统基本概念

#### 7.1.1 输入输出系统和IO控制方式

![](/img/170653.jpg)

##### 现代计算机的结构

![](/img/153946.jpg)

![](/img/163119.jpg)

##### I/O控制方式简介

* 控制寄存器
  * 对外部设备的具体控制，比如要让他做什么动作
* 地址总线可以指明要读的是哪个设备以及输入的数据存放在哪个寄存器

![](/img/163923.jpg)

![](/img/65223.jpg)

![](/img/170026.jpg)

##### DMA控制方式

![](/img/65445.jpg)

![](/img/65833.jpg)

![](/img/165949.jpg)

* 如果此时某个程序需要进行数据的读写，那么CPU会通过I/O指令向DMA控制器指明此次要读或者写的数据存放在哪，应该转存到什么位置，应该转存多大的数据，发出I/O指令之后，CPU就可以转头去做其他的事情
* I/O设备准备好的数据会先存到DMA控制器当中，每准备好一个字的内容，DMA就会发出一个DMA请求，接下来DMA会占用一个存取周期，往主存的对应位置写入一个字的数据
* 程序中断方式每传一个字都要启动一次中断服务程序，而DMA方式每传一个字只需要占用一个存取周期

##### 通道控制方式

![](/img/70151.jpg)

![](/img/0303.jpg)

##### I/O系统基本组成

![](/img/134231459.jpg)

![](/img/170603.jpg)

#### 7.1.2 外部设备

* 大部分内容简要了解即可，尤其是涉及到技术的部分

![](/img/170749.jpg)

![](/img/73309.jpg)

##### 输入设备

![](/img/170900.jpg)

![](/img/170936.jpg)

##### 输出设备

###### 显示器

* 显存当中存放的是接下来要在这个显示器上面播放的这一帧的图像的信息，用来刷新显示其图像用的
  * 一帧的大小为显存的理论最小值

* 帧频：每秒钟需要刷新多少帧

![](/img/71510.jpg)

![](/img/171903.jpg)

![](/img/171924.jpg)

![](/img/172026.jpg)

![](/img/172110.jpg)

![](/img/172213.jpg)

* 仅供参考，技术在进步

###### 打印机

* 击打式打印机：打印发票的针式打印机

![](/img/73103.jpg)

![](/img/173152.jpg)

##### 显示器-阴极射线管（CRT）显示器

![](/img/172345.jpg)

* 先把字符的ASCII码写入显存里面，显存里面的字符会以电信号的方式发送给字符发生器
  * 在这个字符发生器内部，除了控制电路之外，也会有一个rom用来存放每一个ASCII码，它所对应的一个字形码
  * 根据字符的ASCII码以及CRT的控制信息，选中某一个字符的字形码所存储的ROM存储单元
  * 把字符信息送到输出缓冲寄存器中，显示字符
* 显存ASCII码，字符发生器ROM存放的是一个个MxN bit的信息

![](/img/172602.jpg)

![](/img/172930.jpg)

* 图形显示器一般用于工程的控制以及显示股票的涨跌

#### 7.2 IO接口

![](/img/8145048.jpg)

##### I/O接口的作用

![](/img/42641.jpg)

##### I/O接口

* 目前不少系统总线也用串行传输方式

![](/img/42910.jpg)

![](/img/945.jpg)

##### I/O接口的工作原理

![](/img/3131.jpg)

![](/img/143256.jpg)

![](/img/143355.jpg)

##### 接口与端口

![](/img/143517.jpg)

##### 统一编制vs独立编制

###### 统一编制

![](/img/43646.jpg)

* 复杂指令集系统有时候也采用统一编制

###### 独立编制

* in是指从某一个制定的IO端口读入一个数据到CPU的寄存器当中，out的作用是把CPU的某一个寄存器里的内容写入到制定的IO端口当中
* 执行的是IO指令，根据地址信息去找IO端口，不是IO指令就去访存

![](/img/143931.jpg)

##### I/O端口及其编制

![](/img/4030.jpg)

![](/img/44920.jpg)

##### I/O接口的类型

![](/img/145004.jpg)

![](/img/145031.jpg)

#### 7.3.1 程序查询方式

![](/img/145135.jpg)

![](/img/5728.jpg)

##### I/O方式简介

![](/img/200154.jpg)

##### 程序查询方式

![](/img/152134.jpg)

* 发出打印的命令，放到I/O端口当中

![](/img/152500.jpg)

* I/O控制逻辑电路根据CPU发过来的打印的命令信号，给打印机通过控制线发出相应的控制信号
  * 打印机受到命令之后开始启动，启动的准备工作完成之后通过状态线给I/O接口一个反馈
  * I/O接口发现这个打印机启动操作已经完成，I/O控制逻辑电路会把打印机就绪的状态信息存到状态寄存器当中
    * 对于CPU来说，如果采用的是程序查询方式，意味着当这个CPU通过刚才的out指令发出这个打印的请求之后，CPU会一直通过数据线轮巡检查这个状态寄存器是否变成了已经就绪的状态
      * 轮巡检查是通过in输入的I/O指令，CPU可以不断的执行输入in这个I/O指令，从I/O端口取数到CPU寄存器当中，就可以取得状态寄存器里面的值，然后CPU再来检查里面的值是否已经ready

![](/img/162501.jpg)

* CPU轮巡检查到打印机已经就绪，CPU接下来给打印机输入第一个字符的信息，控制线说明此次要进行写操作，地址线指明了操作端口，数据线传入字符信息

![](/img/162755.jpg)

* I/O控制逻辑把这个字符的信息通过线通过数据线输出给打印机，同时发出相应的控制信号
* 当打印机在打印字符的时候，处于忙碌的状态，直到打印工作完成，通过状态线反馈已经完成的信号，状态寄存器从忙碌改为ready，CPU轮巡检查到打印机已经不再是忙而是就绪的状态

![](/img/162946.jpg)

* CPU冲入第二个字符的信息，接下来I/O控制逻辑再把b通过这个线路给输出到打印机

![](/img/163124.jpg)

* 当CPU第三次检测到这个打印机的打印输出动作完成之后，判断出打印工作已经完成，CPU给打印机发出一个停机的指令（需要驱动程序）
  * 在I/O控制逻辑的控制下，停机信号被传送给打印机，打印机的工作停止

##### 程序查询方式流程图

![](/img/3405.jpg)

* 预置传送参数就是设置一个计数器，用来记录还剩多少个字符没有传送好
* 慢速的I/O设备如果采用定时查询的方式，对整体CPU的性能没有多大影响，但对于一些快速的I/O设备来说，采用程序查询方式可能会大量占用CPU的查询时间
* 定时查询：隔一段时间查询一次I/O是否完成
* 独占查询：cpu会用所有的时间等待I/O的完成

##### 程序查询方式-例题

* 不考虑处理时间是指CPU和这个I/O接口之间数据的输入或者输出这些时间可以不计，只计算这个CPU每一次查询所需要的时间
* 从磁盘里读入的数据首先会被放到一个数据缓冲寄存器当中，每次会往里面放32个bit，有一个状态寄存器用来反映这次的32bit是否已经输入完成，如果输入完成，cpu就可以从中直接取走32bit的信息

![](/img/165359.jpg)

![](/img/65535.jpg)

#### 7.3.2 中断的作用和原理

##### 中断的基本概念

![](/img/170234.jpg)

![](/img/170321.jpg)

* 中断隐指令：把CPU的指令执行流转移到正确的一个中断服务程序（修改PC的值，让PC只想中断服务程序的第一条指令）
  * 关中断状态信息会被记录在PSW当中

##### 中断请求的分类

* 关中断状态的作用就是可以辅助实现某一些原子操作
  * 这一系列的操作要么就一点都不做，要么就一气呵成地全部完成
    * 如果希望一口气完不完成，那么在执行第一条指令之前，可以插入一个关中断指令，执行完以后再植入一个开中断指令

![](/img/170701.jpg)

##### 中断请求标记

* 每一个触发器能够记录一个二进制的0或者1，当某一个I/O设备所对应的触发器的这一个bit=1的时候，意味着此时有来自这个I/O设备的中断请求需要被处理
  * 当CPU检测到中断请求信号之后，只需要看中断请求标记寄存器里面哪些bit=1，就知道接下来要处理的中断是哪些

![](/img/171753.jpg)

##### 中断判优-实现

![](/img/192319.jpg)

* 一般不会考硬件排队器的实现电路

![](/img/03227.jpg)

* 软件实现中断判优慢于硬件实现，因此现实中通常都是用硬件排队器来实现中断的判优

##### 中断判优-优先级设置

![](/img/203312.jpg)

##### 中断处理过程

![](/img/203603.jpg)

##### 中断处理过程-中断隐指令

* 保存断点：保存原PC的值
  * 操作系统会有一个内核堆栈区，把PC的值放到内核堆栈里
    * 把PC的值放到内核堆栈（主存内的某一片区域）的栈顶

![](/img/204020.jpg)

###### 中断处理过程-硬件向量法

* 给每一个中断请求信号编号，与这些中断请求信号所对应的主存单元里面保存了一个jump无条件转移指令，这个无条件转移指令指明了当前这个中断请求所对应的中断服务程序的入口地址
* 指向中断服务程序起始地址的地址信息称为中断向量
* 中断向量地址形成部件：根据某一个中断请求信号，得到与这个中断请求信号相对应的中断向量的保存地址
* 向量地址指向中断向量的存储地址，中断向量指向中断服务程序的起始地址
  * 中断向量相当于函数的指针，向量地址是指针的指针

![](/img/210340.jpg)

![](/img\210447.jpg)

##### 中断处理过程-中断服务程序

![](/img/211546.jpg)

##### 总结：中断处理过程

* 由于都是用硬件实现，关中断和将程序断点压进栈可以同时实现

![](/img/211854.jpg)

![](/img/211947.jpg)

#### 7.3.3 多重中断

![](/img/12112.jpg)

##### 单重中断与多重中断

![](/img/001315.jpg)

##### 中断屏蔽技术

![](/img/001244.jpg)

* 屏蔽字：中断屏蔽字
  * 指明接下来哪些中断指令应该被忽视，解决中断请求信号的优先级的问题

![](/img/001455.jpg)

* 硬件电路一般不会考

###### 例题

![](/img/02335.jpg)

![](/img/002442.jpg)

##### 中断系统小结

![](/img/002536.jpg)

#### 7.3.4 程序中断方式

![](/img/003212323.jpg)

![](/img/010348.jpg)

##### 例题

![](/img/003810.jpg)

* ①算出时钟周期，把所有的时间换算成时钟周期数

![](/img/003957.jpg)

* 注：此处的完成这一任务时间算不算返回程序都可以

#### 7.3.5 DMA方式

##### DMA控制器

* DMA控制器通常是用来控制某一些块设备，就是以块为单位进行读写的设备

![](/img/12423.jpg)

![](/img/012444.jpg)

![](/img/012729.jpg)

* 注：是一整块完成之后，向CPU报告DMA操作的结束

![](/img/013421.jpg)

* DMA控制器和主存的数据交换是通过系统总线进行的，当DMA控制器正在通过系统总线传送这个数据的过程当中，CPU如果也想使用系统总线，也想访问主存，需要暂停等待，直到DMA的数据传送结束之后，才会把数据总线的使用权让回给CPU

##### DMA传送过程

* 预处理阶段
  * CPU向DMA控制器指明接下来要读或者写的数据应该存放在主存当中的什么位置，主存的读写指针寄存器叫AR，用于指明设备的读写地址，寄存器英文缩写叫DAR，除此之外还要知名要传送多少个数据，这个寄存器的缩写叫WC。
* 数据传送过程：
  * DMA控制数据传送的过程,CPU继续执行之前的程序
  * 如果要输入一个数据，设备首先把数据冲入到数据缓冲寄存器内，同时向DMA触发器发出一个高电平信号变为1，当控制逻辑检测到DMA请求，一个字的传送已经完成之后，会向CPU申请总线的控制权，如果说系统总线可以让给DMA使用,CPU会给DMA一个反馈信号。
  * DMA获得总线的控制权以后，就可以通过控制线、地址线、数据线给主存发出读或者写的命令，同时把数据缓冲寄存器里面的数据打到数据线上，然后把主存的地址信息打到地址线上，这样就完成了一个字的数据传输
  * 数据传送完以后，需要让这个主存的地址自动的后移，同时也需要修改这个长度计数器
  * 传输完多个字以后，这个长度计数器会发生溢出，然后这个溢出信号会传送给中断机构，中断机构检测到溢出信号之后，会向CPU发出中断请求
  * CPU对DMA的中断信号进行处理
* 注意：DMA请求和DMA中断请求是两个东西，发生DMA请求的时候，意味着我们要和主存传送一个字的数据；而发生DMA中断请求的时候，意味着一整块的数据传输已经完成了
* 后处理阶段：
  * CPU收到中断请求就会进行后处理，运行相应的中断服务程序，然后做DMA结束处理

![](/img/014522.jpg)

![](/img/014608.jpg)

##### DMA方式的特点

* 采用三总线结构的情况下，如果不是双端口的主存，同一时刻只能支持一个访问请求，要在CPU和DMA的访问请求中进行选择

![](/img/014726.jpg)

##### DMA传送方式

![](/img/015037.jpg)

* DMA与CPU交替访存的情况下，对于主存的利用率也不太好

##### DMA方式与中断方式

![](/img/015148.jpg)

![](/img/015258.jpg)





































































## 薄弱点

* 溢出判断和标志位判断
  * 两个数加减乘除的溢出判断：转为真值进行运算看有没有超出表示范围
* 补码减法运算电路，无符号数和有符号数的减法

* 浮点数的表示和运算

* 地址，字节和进制
  * 两个16进制数占一个字节，即一个地址空间，一个地址空间等于一个字节
  * 1B=1地址=2个16进制数=8个bit
  * 一个16进制数占4个bit
* 规格化浮点数
  * 补码和原码尾数的规格化表示
* 浮点数舍入溢出

* 溢出判断总结
  * 补码定点加减法的溢出判断：
    * 一位符号位，操作数符号相同，结果和操作数符号不相同，表示溢出
    * 双符号位：00,11不溢出，01正溢出，10负溢出
    * 数值位进位：最高位进位和次高位进位相同无溢出，不同溢出
  * 无符号数溢出的判断：
    * CF=sub异或Cout
  * 乘法的溢出判断：
    * 乘积高位不全为0或者全为1
  * 除法的溢出判断：
    * 商为1
  * 浮点数的溢出判断：
    * 阶码上溢

