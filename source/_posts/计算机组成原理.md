---
title: 计算机组成原理
date: 2024-04-15 13:57:06
tags: 408专业课	
sticky: 141
categories: 408
banner_img: /img/1920x1080 (7).jpg
index_img: /img/1920x1080 (7).jpg
math: true
---

## 第一章 计算机系统概述

### 1.1计算机发展历程

* 低电平表示二进制0
* 高电平表示二进制1
* 金属针脚用来接受和发送电信号二进制数，每个二进制数位称为1bit
* 计算机性能的好坏取决于软硬件功能的总和
* IH
* 摩尔定律：集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，整体性能也将提升一倍

### 1.2计算机硬件的基本组成

![](/img/145732.jpg)

#### 早期冯诺依曼机的结构

![](/img/144503.jpg)

##### 特点

* 采用存储程序的工作方式
  * 将指令以二进制代码的形式事先输入计算机的主储存器（内存），然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束
  * 得以实现自动化地执行代码
* 计算机由五大部件组成
  * 运算器
  * 控制器
  * 存储器
  * I/O设备
* 指令和数据以同等地位存于存储器，可按地址寻访
  * CPU区分指令和数据的依据是二者访问阶段的不同
* 指令和数据用二进制表示
* 指令由操作码（操作类型）和地址码（操作数据的地址）组成
* 以运算器为中心
  * 输入/输出设备与存储器之间的数据传送通过运算器完成
    * 导致数据计算效率的降低

#### 现代计算机的结构

![](/img/145236.jpg)

![](/img/145449.jpg)

##### 特点

* 以存储器为中心
* CPU=运算器+控制器
* 指令存放于控制器当中，由控制器来解析并且发出相应的控制信号
* 注：辅存主要指机械硬盘固态硬盘等，不属于主机内容而属于I/O设备，例如我们手机里的APP平时储存在辅存里面，只有使用的时候才会把辅存里边的app相关的程序数据代码读到主存里边

### 1.3各个硬件的工作原理

![](/img/163027.jpg)

#### 主存储器

##### 基本组成

* 存储体

  * 用于存放数据，由一系列的存储元件构成，用于存放零和一

  * `数据在存储体内按地址存储`

    ![](/img/151037.jpg)

    * 存储单元：每个存储单元存放一串二进制代码
    * 存储字：存储单元中二进制代码的组合
    * 存储字长：存储单元中二进制代码的位数
    * 存储元：即存储二进制的电子元件，每个存储元可存1bit（电容存储）

* 寄存器

  * 注：现在的计算机通常把MAR、MDR也集成在CPU内
  * MAR（存储地址寄存器）
    * MAR位数反映了存储单元的个数（最多支持多少个）
  * MDR（存储数据寄存器）
    * MDR位数=存储字长（bits）=每个存储单元的大小
  * 读取

  ![](/img/150346.jpg)

  * 写入

  ![](/img/150449.jpg)

#### 运算器

用于实现算术运算（加减乘除）、逻辑运算（与或非）

![](/img/151924.jpg)

##### 基本组成

* ACC：累加器，用于存放操作数或者运算结果
* MQ：乘商寄存器，在乘、除运算时，用于存放操作数或者运算结果
* X：通用的操作数寄存器，用于存放操作数
* `ALU：算数逻辑单元，通过复杂的电路实现算数运算、逻辑运算，上面为数据储存结构`

#### 控制器

##### 基本组成

* `CU：控制单元，分析指令，给出控制信号`
* IR：指令寄存器，存放当前执行的指令
* PC：程序计数器，存放下一条指令地址，有自动加1的功能

* 完成一条指令的流程：
  * 取指令 PC
  * 分析指令 IR
  * 执行指令 CU

#### 计算机的工作过程

* 过程演示

![](/img/155208.jpg)

![](/img/155801.jpg)

![](/img/161851.jpg)

![](/img/162123.jpg)

![](/img/162450.jpg)

![](/img/162559.jpg)

* 总结

![](/img/162909.jpg)

### 1.4计算机系统的多级层级结构

![](/img/171555.jpg)

#### 计算机系统的层次结构

![](/img/171039.jpg)

![](/img/171511.jpg)

### 1.5计算机的性能指标

![](/img/194628.jpg)

#### 存储器的性能指标

![](/img/172819.jpg)

* 存储器的容量

  * 总容量=存储单元个数*存储字长

    ​            =存储单元个数*存储字长/8

#### CPU的性能指标

* CPU主频：CPU内数字脉冲信号震荡的频率，表示的是每秒钟会有多少个数字脉冲，即会出多少个时钟周期

  * 如10Hz可能是每秒钟有10个脉冲信号

  ![](/img/191603.jpg)
  
  ![](/img/093500.jpg)

$$
CPU时钟周期=\frac{1}{主频}
$$

$$
CPU执行时间（整个程序的耗时）=\frac{CPU时钟周期数}{主频}=CPU时钟周期数*时钟周期
$$

$$
CPU执行时间=\frac{指令条数*CPI}{主频}=CPI*指令条数*时钟周期
$$


$$
CPI=\frac{CPU时间*时钟频率}{指令条数}=\frac{CPU时钟周期数}{指令条数}
$$


$$
CPI=\sum^n_{i=1}(CPI_i*F_i)=\frac{CPU时钟周期数}{指令条数}
$$

$$
总时钟周期数=\sum^n_{i=1}(CPI_i*C_i)
$$

$$
IPS（每秒执行多少条指令）=\frac{主频}{平均CPI}=\frac{指令条数}{执行时间（秒）}
$$

* 平均CPI=∑各指令CPIx指令混合比
* 同一套指令集意味着指令总数相同

注：

* 容量是2^k
* 带宽是10^k

#### 系统整体的性能指标

* 数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）

* 吞吐量：指系统在单位时间内处理请求的数量
  * 它取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。（了解即可）
* 响应时间：指从用户向计算机发送一个请求，到系统对该请求做出相应并获得它所需要的结果的等待时间
  * 通常包括CPU时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I/O操作、操作系统开销等时间）（简单了解即可）

#### 系统整体的性能指标（动态测试）

* 基准程序（跑分软件）是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其他计算机性能进行比较

#### 提高计算机性能的主要途径

* 提高时钟频率（流水线）
* 优化处理其中数据通路的结构以降低CPI（单周期/多周期/流水线）
* 采用编译优化措施来减少指令条数或降低指令复杂度（指令系统）

## 第二章 数据的表示和运算

* 数值数据和非数值数据

  * 数值数据是指能在数轴上找到点的数据
    * 定点数、浮点数
  * 非数值数据是指字母、汉字等
    * char，string

* 数值数据表示的三要素

  * 进位计数值
  * 定、浮点表示
  * 如何用二进制编码
  * 要确定一个数值数据的值必须先确定这三个要素

* 整数都采用补码来表示

  * 但浮点数的尾数用原码定点小数表示

* 补码特性：模运算

  * 在一个模运算系统中，一个数与它除以模以后的余数等价
  * 一个负数的补码等于模减去该负数的绝对值
  * 一个正数的补码等于模加上它本身即等于原码
    * 任何一个数用n位1来减相当于各位取反，末位+1

  ![](/img/73942.jpg)

  * 对于某一确定的模，某数减去小于模的另一个数，总可以用该数加上另一个数符数的补码来替代

* 2的16次方之内要牢记

* 变形（模4）补码：双符号，用于存放可溢出的中间结果

* 无符号数0扩展，带符号整数符号扩展

* 无符号数和带符号数运算一般转化为无符号数

* 因为原码是对称的，所以尾数的表示范围关于原点对称

### 2.1数制与编码

#### 2.1.1 进位计数制

![](/img/194427.jpg)

##### r进制计数法

![](/img/192649.jpg)

![](/img/193026.jpg)

##### 二进制与八进制、十六进制互相转换

* 二到八

![](/img/193146.jpg)

* 二到十六

![](/img/193224.jpg)

* 八到二

![](/img/193324.jpg)

* 十六到二

![](/img/193400.jpg)

##### 十进制转化为任意进制

* 整数部分

![](/img/193825.jpg)

* 小数部分

![](/img/194015.jpg)

* 拼凑法转化为二进制

![](/img/194120.jpg)

#### 2.1.2 BCD（用二进制编码的十进制数）码

![](/img/202034.jpg)

* 四个二进制位表示一个十进制位

![](/img/195755.jpg)

* 8421码映射关系（有权码）

![](/img/195910.jpg)

![](/img/201051.jpg)

![](/img/201326.jpg)

![](/img/201339.jpg)

![](/img/201531.jpg)

某一位加出来>9或者有进位的时候要加6矫正

结果<=9的时候不需要矫正

最高位有进位时，发生溢出

* 余3码（无权码）

![](/img/01731.jpg)

* 2421码（有权码）

0-4的首位一定是0，5-9的首位一定是1

![](/img/201940.jpg)

#### 2.1.3 无符号整数的表示和运算

![](/img/203330.jpg)

![](/img/202247.jpg)

##### 无符号整数的表示

![](/img/202618.jpg)

##### 无符号整数的加法运算

![](/img/202806.jpg)

##### 无符号整数的减法运算

![](/img/203011.jpg)

![](/img/203228.jpg)

#### 2.1.4 带符号整数的表示和运算 原反补

![](/img/210101.jpg)

![](/img/203430.jpg)

![](/img/203630.jpg)

##### 原码表示(Sign and magnitude)

![](/img/203927.jpg)

![](/img/204046.jpg)

##### 原码→反码→补码的转换（机算）

![](/img/204256.jpg)

##### 原码、补码快速转换技巧（手算）

![](/img/204650.jpg)

##### 补码的加法运算

![](/img/205003.jpg)

![](/img/205325.jpg)

* 注：由于补码数值不能解读为位权，因此真值需要转换为原码再去找真值

##### 补码的减法运算

* 机算

![](/img/205603.jpg)

* 手算
  * 找到第一个1，然后1的左边的所有位数包括符号位在内取反，右边保持不变

##### 对比：无符号整数的减法运算

* 无论是带符号整数还是无符号整数的减法，都是被减数不变，减数全部位按位取反、末位+1，减法变加法
* 计算机内部，所有带符号整数的加减法都要先转化为补码（当然C语言的带符号整数都是用补码来表示的）

![](/img/205857.jpg)

#### 2.1.5 原反补码的特性对比

![](/img/210300.jpg)

##### 各种码的基本特性总结

![](/img/233057.jpg)

* 对于负数，数值部分越小，其绝对值越大，即负的越多

#### 2.1.6 移码

![](/img/232157.jpg)

![](/img/232345.jpg)

![](/img/233024.jpg)

![](/img/233200.jpg)

* 移码：补码的基础上将符号位取反。注意：移码只能用于表示整数。

#### 2.1.7 定点小数

![](/img/233350.jpg)

![](/img/233506.jpg)

* 定点小数的符号位后面常常用“.”隔开，而定点整数的符号位后面常常用“，”隔开

##### 定点小数原/反/补码的转换

![](/img/220352.jpg)

##### 定点小数的加/减运算

![](/img/220502.jpg)

##### 定点小数vs定点整数

![](/img/220732.jpg)

![](/img/221006.jpg)

##### 小数补码的加法运算

![](/img/221322.jpg)

##### 小数补码的减法运算

![](/img/221432.jpg)

### 2.2 运算方法和运算电路

#### 2.2.0 奇偶校验码

##### 校验原理简介

![](/img/223201.jpg)

![](/img/223333.jpg)

##### 奇偶校验码

![](/img/223555.jpg)

* 奇偶校验码的缺点：只能发现奇数个位发生传输错误，不能发现偶数个位发生传输错误

偶校验码的硬件实现

 ![](/img/224356.jpg)

##### 码距与检错、纠错能力的关系（当d<=4）

* 不用背

![](/img/004101.jpg)

#### 2.2.1 电路的基本原理、加法器设计

![](/img/13636.jpg)

##### 算术逻辑单元（ALU）

![](/img/225001.jpg)

* 控制信号是由控制单元cu发出的

![](/img/230645.jpg)

* M用来表示做的是逻辑运算还是算术运算，1是逻辑运算，0是算术运算
  * S0-S3可以用来指明此次要进行的是哪一种算术运算或者哪一种逻辑运算
  * 此处有4个bit，可以对应16种状态，因此该芯片可以支持16种算术运算和16种逻辑运算
* 机器字长的真面目就是ALU算术逻辑单元里面可以支持同时输入多少个比特的信息
* 寄存器的位数和ALU一般保持一致，也即一般寄存器的位数就是机器字长
* 其余输入和输出信号一般是为了和其他芯片进行串联而设计的

##### 最基本的逻辑运算

* 一个比特的逻辑运算
* 关于数据的输入和输出，我们都是用电信号来表示的，也就是高低电平

![](/img/21002.jpg)

* 与门

![](/img/231008.jpg)

* 或门

因为只要有一个1结果就是1，即>=1

![](/img/231213.jpg)

* 非门

![](/img/231334.jpg)

* 优先级：与>或

![](/img/231709.jpg)

##### 复合逻辑

![](/img/232133.jpg)

* 异或门可用与、或、非组合实现
  * 异或的天然逻辑：加法、奇偶校验

![](/img/232213.jpg)

* 同或门

![](/img/111409.jpg)

##### 用门电路求偶校验位

![](/img/111756.jpg)

##### 一位全加器

![](/img/112850.jpg)

##### 串行加法器

![](/img/ 113045.jpg)

##### 并行加法器

* 串行进位的并行加法器

![](/img/113432.jpg)

这种加法器的运算速度很大程度上取决于每一位进位的产生速度

#### 2.2.2 并行进位加法器

![](/img/113432.jpg)

##### 更快产生进位

![](/img/·114835.jpg)

##### 并行加法器的优化

![](/img/202337.jpg)

![](/img/021135.jpg)

![](/img/021241.jpg)

![](/img/021403.jpg)

![](/img/021435.jpg)

* 注：目前计算机不需要芯片级联，一个CPU芯片中有多个处理器核，一个核中有多个ALU

#### 2.2.3 补码加减运算器

##### 加法器原理

![](/img/203123.jpg)

##### 补码加/减法运算方法

![](/img/203439.jpg)

![](/img/212939.jpg)

![](/img/213351.jpg)

* 有符号整数和无符号整数的加减法虽然共用一套电路，但是判断是否溢出的方式不同

#### 2.2.4.1 加减运算和溢出判断

![](/img/223535.jpg)

##### 原码的加减运算

![](/img/213734.jpg)

* 主要用于浮点数尾数运算
* 符号位和数值部分分开处理
* 仅对数值部分进行加减运算，符号位起判断和控制作用
  * 加法：同号求和，异号求差
  * 减法：异号求和，同号求差

##### 补码的加减运算

* -B的补码是B的右数第一个1的左边所有位全部取反

![](/img/215939.jpg)

##### 移码的加减运算

![](/img/023635.jpg)

![](/img/023756.jpg)

* 补码和移码的关系：符号位取反、数值位相同

##### 溢出判断

核心逻辑：两个同号的数相加，最终得到了一个异号的结果

![](/img/20158.jpg)

* 方法一：采用一位符号位
  * 左边判断是否负+负得正，右边判断是否正+正得负，两个结果只要有一个溢出即答案得1，最后就是存在溢出现象，所以用或运算或起来

![](/img/221225.jpg)

* 方法二：采用一位符号位，根据数据位进位情况判断溢出

  ![](/img/222028.jpg)

  * 上溢

  ![ ](/img/221519.jpg)

  * 下溢

  ![](/img/21733.jpg)

  * 只要发生了溢出，符号位的进位和最高数值位的进位肯定不一样

* 方法三：采用双符号位

![](/img/222145.jpg)

![](/img/222549.jpg)

补码在进行运算之前会复制一个符号位，接下来会让两个符号位同时进行运算

* 补码乘法中高32位非全0或者全1为溢出

##### 符号扩展

![](/img/223457.jpg)

* 正整数：
  * 符号位和数值位中间补0
* 负整数：
  * 原码：符号位和数值位中间补0
  * 反码：符号位和数值位中间补1
  * 补码：符号位和数值位中间补1
* 正小数：
  * 最后一位后面补0
* 负小数
  * 原码：最后一位后面补0
  * 反码：最后一位后面补1
  * 补码：最后一位后面补0

#### 2.2.4.2 标志位的生成

![](/img/224508.jpg)

![](/img/225358.jpg)

* 注：
  * OF: overflow flag 
  * SF: sign flag
  * ZF: zero flag
  * CF: carry flag（进位、借位标志）



* OF的标志位仅在有符号数的加减运算中有意义，即如果进行的是无符号数的加减运算，即便OF=1也并不能说明无符号数发生了溢出 
* 如果减法的CF结果为1，说明产生了借位，也说明被减数比减数要小，意味着最终运算的结果一定是错误的，发生了溢出
* 有符号数的溢出看OF，无符号数的溢出看CF，都是1为溢出

#### 2.2.5 定点数的移位运算

![](/img/000933.jpg)

![](/img/230137.jpg)

![](/img/232510.jpg)

##### 原码的算术移位

![](/img/231159.jpg)

* 算数右移

![](/img/230702.jpg)

* 算数左移

![](/img/231134.jpg)

* 注：参考C++中的位运算，X>>k等于X/ 2^k，X<<k等于X* 2^k

##### 反码的算术移位

![](/img/231342.jpg)

##### 补码的算术移位

![](/img/232326.jpg)

##### 算术移位的应用举例 

![](/img/235441.jpg)

##### 逻辑移位

![](/img/235520.jpg)

##### 逻辑移位的应用举例

![](/img/000035.jpg)

##### 循环移位

![](/img/000828.jpg)

* 循环补位，移出去的补到最后一位或者最前一位
* 带进位位的循环移位，相当于把进位位加入队列
* 循环移位很适合把数据的高字节和低字节进行一个调换

#### 2.2.6.1 原码的乘法运算

##### 手算乘法（十进制）

![](/img/002135.jpg)

##### 手算乘法（二进制）

![](/img/002417.jpg)

##### 原码一位乘法

![](/img/002834.jpg)

![](/img/003021.jpg)

![](/img/003104.jpg)

![](/img/003223.jpg)

![](/img/003331.jpg)

![](/img/003424.jpg)

![](/img/003517.jpg)

##### 原码一位乘法（手算模拟）

*  由于补码乘法用的是双符号位，所以原码的乘法也可以用双符号位以便统一

![](/img/003727.jpg)

* 自己答题时最好还是写出真值所对应的源码机器数

#### 2.2.6.2 补码的乘法运算

![](/img/010422.jpg)

##### 补码一位乘法

![](F:\try\home\themes\fluid\source\img\005238.jpg)

* 辅助位就是把MQ寄存器的容量多拓展了一位，用新拓展的一位来存储的
  * MQ中的最低位指的是当前参与乘法运算的那一位
  * 原码往ACC、X和MQ里面存绝对值，而补码是直接把符号位也一并存进去了
  * 被乘数和乘积高位采用的是双符号位补码，而乘数、乘积地位采用的是单符号补码

![](/img/005750.jpg)

##### 补码一位乘法（手算模拟）

![](/img/010309.jpg)

#### 2.2.7.1 原码的除法运算

##### 手算除法（十进制）

![](/img/135750.jpg)

##### 手算除法（二进制）

![](/img/140051.jpg)

##### 原码除法：恢复余数法

![](/img/140417.jpg)

![](/img/140525.jpg)

![](/img/140604.jpg)

![](/img/140745.jpg)

![](/img/140836.jpg)

![](/img/140927.jpg)

![](/img/140951.jpg)

![](/img/141020.jpg)

![](/img/141044.jpg)

![](/img/141148.jpg)

##### 原码除法：恢复余数法（手算）

* 写出①除数和②被除数的绝对值，以及③除数的绝对值的补码和④绝对值负数的补码

![](/img/141612.jpg)

![](/img/141724.jpg)

##### 原码除法：加减交替法（不恢复余数法）

![](/img/142632.jpg)

![](/img/142849.jpg)

* 在定点小数的除法运算中，我们会规定被除数一定要小于除数，因为如果大于，则商会>1，而定点小数无法表示大于1的范围，因此当第一步的商是1，说明被除数比除法更大，硬件电路检测出以后会直接停止这些除法的运算

#### 2.2.7.2 补码的除法运算

* 两个n位补码整数除法运算，被除数需要进行符号扩展，若被除数为2n位，除数为n位，则被除数无需扩展
* 余数变号不够减，不变号够减

##### 补码除法：加减交替法

![](/img/143631.jpg)

##### 除法运算总结回顾

![](/img/143758.jpg)

#### 2.2.8 C语言类型转换

* 无符号数和有符号数
* 长整数变短整数
* 短整数变长整数

![](/img/144322.jpg)

#### 2.2.9 数据的存储和排列

##### 大小端存储

* 大端存储就是把更高有效字节存储到更低地址的部分，最低有效字节存放到了最高地址部分
* 小端存储就是在低地址部分存储最低有效字节，在高地址部分存储最高有效字节
  * 小端方式便于机器处理类似于高精度运算中数字用数组倒存

![](/img/145009.jpg) 

##### 边界对齐

* 注：字节是基本单位，一字节等于8bit，字长是运算的基本单位，即以此能处理多少个字节，多少位就是多少个bit，处理的字节数等于bit/8，半字就是字长的一半
* 字长是数据通路的宽度，字是处理事务的固定长度的二进制数位组，是信息传送的基本单位
* 给出访问的字的地址的时候，如何转化为与之对应的字节地址：
  * 字地址逻辑左移两位
  * 半字地址逻辑左移一位

![](/img/145826.jpg)

![](/img/145934.jpg)

### 2.3 浮点数的表示与运算

* 数据在数轴上是稀疏、不均匀的，数字越大，间隔越大精度越低

![](/img/234308.jpg)

#### 2.3.1 浮点数的表示

![](/img/155945.jpg)

* 定点数可以表示的数字范围有限，但我们不能无限制地增加数据的长度

##### 从科学计数法理解浮点数

* 阶符为正，小数点右移，阶符为负，小数点左移
  * 阶码的数值部分意味着要移多少位 
* 尾数越短，表示的数字精度就越低

##### 浮点数的表示

* 定点数之所以称为定点数是因为小数点的位置固定不变，而浮点数就是小数点的位置是会浮动的

![](/img/153255.jpg)

* 阶码反应浮点数的表示范围及小数点的实际位置

![](/img/153501.jpg)

* 尾数M的数值部分的位数n反应浮点数的精度
* 尾数给出了一个小数，阶码指明了小数点要向前/后移动几位

![](/img/154034.jpg)

![](/img/154149.jpg)

##### 浮点数尾数的规格化

![](/img/154551.jpg)

* 左规：通过算术左移来把浮点数进行规格化

![](/img/155019.jpg)

##### 规格化浮点数的特点

![](/img/155633.jpg)
![](/img/155912.jpg)

#### 2.3.2 IEEE 754

![](/img/164232.jpg)

##### 移码回顾

![](/img/160319.jpg)

![](/img/160746.jpg)

##### IEEE 754标准

* 在实际计算的时候，可以先把移码看成是无符号数，转换成十进制再减掉偏移量

![](/img/161904.jpg)

![](/img/162018.jpg)

![](/img/63217.jpg)

![](/img/63211.jpg)

* 十六进制一位数字对应4个bit

![](/img/163442.jpg)

![](/img/163653.jpg)

![](/img/164111.jpg)

![](/img/ 234017.jpg)

#### 2.3.3 浮点数的运算

![](/img/172137.jpg)  

##### 浮点数的加减运算

* 通常是阶数更小的向阶数更大的对齐

![](/img/64748.jpg)

 ![](/img/165355.jpg)

 ![](/img/165843.jpg)

##### 舍入

![](/img/165955.jpg)

![](/img/171742.jpg)

##### 强制类型转换

* 64位机器里面long向double转换可能产生精度丢失

![](/img/172107.jpg)

#### 逻辑数据的编码表示

* 用一位表示，例如真1假0
* N位二进制数可以表示N个逻辑数据，或者一个位串
* 位串：用来表示若干个状态位或者控制位（OS中使用较多）

![](/img/001356.jpg)

#### C语言程序中涉及的运算

* 如何从16位采样数据y中提取高位字节，并使低字节为0？
  * 使用掩码y&0xFF00

* C语言中不区分逻辑移位还是算术移位，由x的类型决定，有符号整数是算术移位，无符号数是逻辑移位

![](/img/014902.jpg)

## 第三章 存储系统

### 3.1 存储系统基本概念

![](/img/1139.jpg)

##### 存储器的层次化结构

![](/img/004248.jpg)

##### 存储器的分类

![](/img/004634.jpg)

![](/img/005554.jpg)

![](/img/010119.jpg)

![](/img/10244.jpg)

![](/img/010419.jpg)

##### 存储器的性能指标

* 存储容量：MAR*MDR
* 容量是bit

![](/img/010904.jpg)

### 3.2 主存储器

#### 3.2.1主存储器的基本组成

![](/img/102706.jpg)

##### 基本的半导体元件及原理

![](/img/95943.jpg)

* 读出二进制的原理
  * 接通mos管，如果电容里面保存了电荷，电荷流出，检测到电荷流出，判断保存的是1，没有保存电荷，没有电荷流出，检测不到电荷流出，判断保存的是0

![](/img/95359.jpg)

* 写入二进制的原理
  * 保存二进制的1
    * 在导线的另一端和mos管加高电压，电容存储电荷

![](/img/095622.jpg)

##### 存储器芯片的基本原理

* 每个地址会对应译码器的一条输出线

![](/img/100136.jpg)

![](/img/00332.jpg)

* 存储矩阵：一个个存储元
* 译码驱动电路：译码器+驱动器（保证译码器输出的电信号稳定可靠）
* 读写电路：红绿线+控制电路
* 地址信息：CPU通过地址线传过来
* 片选线：确定芯片某种情况下是否可用
* 金属引脚：接收地址信号或者数据信号、片选信号、读写信号
* 每根地址线对应一个金属引脚，数据线有多少根就有多少个金属引脚
  * 片选线也对应一个引脚
  * 读写控制线至少对应一个金属引脚

![](/img/101346.jpg)

* n条地址线
  * 2^n个存储单元
  * 总容量=存储单元个数*存储字长
  * n*n位的存储芯片，第一个n表示多少个存储单元，第二个表示存储字长

![](/img/101626.jpg)

##### 寻址

![](/img/102642.jpg)

#### 3.2.2 SRAM和DRAM

![](/img/103230.jpg)

![](/img/113043.jpg)

##### dram芯片

![](/img/10505.jpg)

##### 栅极电容vs双稳态触发器

![](/img/111217.jpg)

* 栅极电容
  * 1：电容内存储了电荷
  * 0：电容内未存储电荷

![](/img/11013.jpg)

* 双稳态触发器

  * 写入二进制0，左边加低电平，右边加高电平

* 区别

  * 栅极电容：读写速度更慢，每个存储元制造成本更低，集成度高，功耗低
    * 电容内的电荷只能维持2ms，即便不断电，2ms后信息也会消失，因此2ms之内比须刷新一次（给电容充电）

  ![](/img/111454.jpg)

  * 双稳态触发器：读写速度更快，每个存储元制造成本更高，集成度低，功耗大
    * 只要不断电，触发器的状态就不会改变

  ![](/img/11541.jpg)

##### dram vs sram

 ![](/img/111809.jpg)

##### dram的刷新

![](/img/ 112820.jpg)

* 每个译码器只需要处理一半的地址信息 

![](/img/112236.jpg)

![](/img/12335.jpg)

![](/img/112447.jpg)

##### dram的地址线复用技术

![](/img/112936.jpg)

#### 3.2.3 只读存储器ROM

![](/img/140721.jpg)

##### 了解各种rom

* 两块体积都相同的芯片，工艺水平相同，闪存芯片上的存储元的数量，要比ram芯片上存储元的数量更多，也就是保存更多的二进制比特位

![](/img/13549.jpg)

##### 计算机内的重要rom

![](/img/113813.jpg)

![](/img/113930.jpg)

#### 3.2.4 双端口RAM和多模块存储器

![](/img/140547.jpg)

##### 存取周期

![](/img/114321.jpg)

##### 双端口ram

![](/img/114607.jpg)

##### 多体并行存储器

* 每个体相互独立

![](/img/115126.jpg)

![](/img/120223.jpg)

* 高位交叉编址
  * 用地址更高的几个比特位来区分我们想要访问的是哪一个存储体
* 低位交叉编址
  * 用地址更低的几个比特位来区分我们想要访问的是哪一个存储体

* 应该取几个体？
  * 给定一个地址x，如何确定它属于第几个存储体
    * x mod n

![](/img/35229.jpg)

##### 多模块存储器

![](/img/35608.jpg)

![](/img/135747.jpg)

### 3.3 主存储器与CPU的链接

![](/img/195041.jpg)

##### 单块存储芯片与CPU的链接

![](/img/00332.jpg)

* 扩展主存字数：字扩展
* 数据总线宽度>存储字长：位扩展
* 现在的计算机mar、mdr通常集成在CPU内部存储芯片内只需一个普通的寄存器（暂存输入、输出数据）

![](/img/143726.jpg)

##### 存储芯片的输入输出信号

![](/img/44212.jpg)

##### 增加主存的存储字长-位扩展

![](/img/144756.jpg)

![](/img/145142.jpg)

##### 增加主存的存储字数-字扩展

![](/img/194708.jpg)

* 没有完全发挥cpu的寻址能力
* 线选法

![](/img/193028.jpg)

* 译码器片选法
  * 1-2译码器：输入一位地址信息，有可能呈现出2的1次放两种不同的状态

![](/img/94343.jpg)

![](/img/194539.jpg)

##### 主存容量扩展-字位同时扩展

![](/img/194940.jpg)

##### 译码器

![](/img/195225.jpg)

![](/img/195315.jpg)

![](/img/195936.jpg)

![](/img/200005.jpg)

![](/img/200357.jpg)

* MREQ：主存储器请求

### 3.4 外部存储器

#### 3.4.1 磁盘存储器

![](/img/211236.jpg)

##### 外存储器

![](/img/01737.jpg)

* 读写以1bit为单位
* 读写两个动作不可以同时进行

##### 磁盘存储器

![](F:\try\home\themes\fluid\source\img\202126.jpg)

![](/img/202534.jpg)

![](/img/203504.jpg)

* 格式化容量比非格式化容量要小

![](/img/204954.jpg)

![](/img/205448.jpg)

![](/img/205543.jpg)

* 寻道时间一般是平均时间
  * 旋转时间可以取转半圈所需要的时间（如果没有明确给出时间），根据转速求出转半圈所需要的时间，也可以算出来转一个扇区所需要的时间

* 磁盘上每一个扇区所能存储的二进制数据都是相同的，外侧和内侧扇区虽然看起来磁道长度不一样，但是存储的bit数量相同
  * 意味着越靠近内测的磁道位密度越大

![](/img/205856.jpg)

* 盘面和磁头一一对应，每个盘面编号，根据盘面号知道激活哪个磁头

![](/img/210628.jpg)

##### 磁盘阵列

![](/img/210751.jpg)

![](/img/210852.jpg)

![](/img/211100.jpg)

![](/img/211210.jpg)

* 越往后的方案，冗余信息的占比会越少，可靠性和安全性会逐步增加

#### 3.4.2 固态硬盘SSD

![](/img/212853.jpg)

##### 固态硬盘的结构

* 逻辑地址经闪存翻译层的翻译之后，会把逻辑地址映射到某个物理地址，地址变换的工作

* 块大小：16KB-512KB
* 页大小：512B-4KB（读写以页为单位）
* 固态硬盘的一个页相当于磁盘的一个扇区
* 固态硬盘的一个块相当于磁盘的一个磁道
* 读多写少的块被迁移到更老的块中，更新的块中承担写操作更多的任务

![](/img/14112.jpg)

![](/img/214215.jpg)

### 3.5 高速缓冲存储器

#### 3.5.1 Cache的基本概念和原理

##### 存储系统存在的问题

![](/img/14325.jpg)

##### cache工作原理

![](/img/214432.jpg)

![](/img/14554.jpg)

![](/img/220410.jpg)

##### 局部性原理

![](/img/220727.jpg)

##### 性能分析

![](/img/221032.jpg)

![](/img/24406.jpg)

##### 有待解决的问题

![](/img/224513.jpg)

![](/img/224720.jpg)

![](/img/224940.jpg)

![](/img/225022.jpg)

#### 3.5.2 Cache和主存的映射方式

![](/img/231830.jpg)

![](/img/225307.jpg)

![](/img/225439.jpg)

##### 全相联映射（随意放）

![](/img/225738.jpg)

![](/img/225929.jpg)

##### 直接映射（只能放固定位置）

![](/img/230122.jpg)

![](/img/230247.jpg)

![](/img/230322.jpg)

##### 组相联映射（可放到特定分组）

![](/img/231801.jpg)

#### 3.5.3 Cache替换算法

![](/img/233919.jpg)

![](/img/231958.jpg)

##### 随机算法（RAND)

![](/img/232155.jpg)

##### 先进先出算法（FIFO）

![](/img/232402.jpg)

##### 近期最少使用算法（LRU）

![](/img/232553.jpg)

![](/img/232721.jpg)

![](/img/232949.jpg)

![](/img/233135.jpg)

##### 最不经常使用算法（LFU）

![](/img/233316.jpg)

![](/img/233509.jpg)

![](/img/33840.jpg)

#### 3.5.5 Cache写策略

##### 写命中

###### 写回法

![](/img/234426.jpg)

### 3.6 存储器

#### 3.6.1 页式存储器

#### 3.6.2 虚拟存储器



































































































## 薄弱点

* 溢出判断和标志位判断
  * 两个数加减乘除的溢出判断：转为真值进行运算看有没有超出表示范围
* 补码减法运算电路，无符号数和有符号数的减法

* 浮点数的表示和运算

* 地址，字节和进制
  * 两个16进制数占一个字节，即一个地址空间，一个地址空间等于一个字节
  * 1B=1地址=2个16进制数=8个bit
  * 一个16进制数占4个bit
* 规格化浮点数
  * 补码和原码尾数的规格化表示
* 浮点数舍入溢出

* 溢出判断总结
  * 补码定点加减法的溢出判断：
    * 一位符号位，操作数符号相同，结果和操作数符号不相同，表示溢出
    * 双符号位：00,11不溢出，01正溢出，10负溢出
    * 数值位进位：最高位进位和次高位进位相同无溢出，不同溢出
  * 无符号数溢出的判断：
    * CF=sub异或Cout
  * 乘法的溢出判断：
    * 乘积高位不全为0或者全为1
  * 除法的溢出判断：
    * 商为1
  * 浮点数的溢出判断：
    * 阶码上溢

