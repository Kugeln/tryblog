---
title: 数据结构
date: 2024-07-14 17:04:20
tags: 408专业课
sticky: 142
categories: 408
banner_img: 1920x1080 (11).jpg
index_img: 1920x1080 (11).jpg
math: true
---

## 第一章 绪论

### 1.1 数据结构的基本概念

#### 1.1.1 数据结构的基本概念

##### 数据对象

* 数据项相当于struct里面的变量，数据元素相当于struct类型，数据对象是struct的数组，数据是所有数据的集合

![](/img/173532.jpg)

##### 数据结构

![](/img/173909.jpg)

#### 1.1.2 数据结构的三要素

![](/img/174218.jpg)

##### 逻辑结构

![](/img/174523.jpg)

##### 数据结构的三要素

![](/img/174908.jpg)

![](/img/80008.jpg)

##### 物理结构

![](/img/175639.jpg)

###### 顺序存储

![](/img/175107.jpg)

###### 链式存储

![](/img/175233.jpg)

###### 索引存储

![](/img/14175421.jpg)

###### 散列存储

![](/img/175555.jpg)

##### 数据类型

![](/img/180228.jpg)

![](/img/80554.jpg)

#### 1.2.1 算法的基本概念

![](/img/201210.jpg)

##### 算法的特性

###### 有穷性

![](/img/181853.jpg)

###### 确定性

![](/img/195745.jpg)

##### 可行性

![](/img/195833.jpg)

#### 1.2.2 算法的时间复杂度

![](/img/04442.jpg)

![](/img/105940.jpg)

![](/img/10037.jpg)

![](/img/233629.jpg)

![](/img/234311.jpg)

![](/img/231234328.jpg)

##### 练习

![](/img/233740.jpg)

![](/img/34254.jpg)

#### 1.2.3 算法的空间复杂度

![](/img/000635.jpg)

##### 程序运行时的内存需求

![](/img/235256.jpg)

![](/img/235409.jpg)

![](/img/235608.jpg)

![](/img/235652.jpg)

##### 函数递归调用带来的内存开销

![](/img/000053.jpg)

![](/img/000345.jpg)

![](/img/6000624.jpg)

## 第二章 线性表

* 逻辑结构是指数据之间的关系。如树、图、表。
* 物理结构是指数据的存放方式。如链式、顺序、复合。

### 2.1 线性表的定义和基本操作

![](/img/001250.jpg)

![](/img/023550.jpg)

##### 线性表的定义

![](/img/002125.jpg)

![](/img/003243.jpg)

##### 线性表的基本操作

![](/img/022538.jpg)

![](/img/023351.jpg)

![](/img/023415.jpg)

### 2.2 线性表的顺序表示

#### 2.2.1 顺序表的定义

* 顺序表：用顺序存储方式来实现的线性表

![](/img/094230.jpg)

![](/img/103726.jpg)

##### 顺序表的定义

![](/img/094416.jpg)

##### 顺序表的实现——静态分配

![](/img/094542.jpg)

![](/img/094839.jpg)

![](/img/094943.jpg)

* 函数内定义的数组是随机值，函数外的数组一定都是0（int main（）函数），即局部变量随机，全局变量都是0（原因是内存上面是栈存放指令，下面是堆负责存放数据，堆是虚拟的，用一块开一块内存，最开始标记为全部指向零，但栈是开多少就是多少，里面的值不会清空
  C++默认的栈空间是一M，不够大定义很大会报错，函数外面的变量会放在堆空间里面，没有长度限制只有内存限制

![](/img/095829.jpg)

* 一定要将length的初始值设为0

![](/img/095918.jpg)

##### 顺序表的实现——动态分配

![](/img/100042.jpg)

![](/img/100546.jpg)

![](/img/103601.jpg)

```c++
#include <iostream>
#include <cstring>//sizeof头文件
#include <stdlib.h>//malloc函数的头文件
using namespace std;
const int inisize 10;
const int N =100010;
//定义一个int类型的数据表
struct Selist{
    int *data;//指向顺序表中的第一个数据元素
    int maxsize;//顺序表的最大容量
    int length;//顺序表的当前长度
}selist[N];
//初始化顺序表
void ini(Sqlist &L){
    L.data=(int *)malloc(inisize *sizeof(int))//用malloc函数申请一片连续的内存空间,把malloc返回的指针转化为int类型
        L.length=0;
    L.maxsize=inisize;
}
//增加动态数组的长度
void addsize(Sqlist &L,int len){
    int *p=L.data;//定一个个指针指向data，记录顺序表的原起始地址
    L.data=(int *)malloc((L.maxsize+len)*sizeof(int));//扩展顺序表的起始地址，改变顺序表的长度
    for(int i = 0;i<L.length;i++){
        L.data[i]=p[i];//把原顺序表的数据整体移位，将数据复制到新区域
    }
    L.maxsize=L.maxsize+len;//顺序表的最大长度增加len
    free(p);//释放原来的内存空间
}
```

* 改变data前

![](/img/03226.jpg)

* 改变data后

![](/img/103325.jpg)

* 释放内存空间后

![](/img/03353.jpg)

* 由于p这个变量是一个局部域这个函数的变量，所以当这个函数执行结束以后，存储p这个变量的这些内存空间会被系统自动地回收

![](/img/103529.jpg)

##### 顺序表的实现

![](/img/103645.jpg)

#### 2.2.2.1 顺序表的插入删除

![](/img/111041.jpg)

##### 顺序表的基本操作——插入

![](/img/104027.jpg)

![](/img/04225.jpg)

![](/img/104849.jpg)

![](/img/04930.jpg)

![](/img/05012.jpg)

![](/img/105257.jpg)

```c++
#include <iostream>
#include <cstring>
#include <stdlib.h>
using namespace std;
const int maxsize=10;
const int inisize=10;
const int N =100010;
//定义顺序表
struct Sqlist{
    int data[maxsize];
    int length;
}sqlist[N];
void insert(Sqlist &L,int i,int e){//在顺序表L的位序i处插入元素e
    for(int j = L.length;j>=i;j--)//从后往前循环到i，因为i前面的元素不需要变动，只需要把i及其后面的元素往后移一位
        L.data[j]=L.data[j-1];//把i后面的元素移一位
    L.data[i-1]=e;//因为数组从0开始，所以位序=数组下标+1，在位置i处放入e
    L.length++;//总长度加1
}
//带合法性判断的顺序表插入
bool insert(Sqlist &L,int i , int e){
    if(i<1||i>L.length+1)
        return false;
    for(int j =L.length;j>=i;j--)
        L.data[j]=L.data[j-1];
    L.data[i-1]=e;
    L.length++;
    return true;
}
int main(){
  ini(L);
  insert(L,3,3);
    return 0;
}
```

##### 插入操作的时间复杂度

![](/img/105421.jpg)

##### 顺序表的基本操作——删除

​	![](/img/105449.jpg)

![](/img/105529.jpg)

![](/img/105652.jpg)

```c++
#include <iostream>
#include <cstring>
#include <stdlib.h>
#include <cstdio.h>
using namespace std;
const int N =10010;
const maxsize=10;
struct Sqlist{
    int data[maxsize];
    int length;
}sqlist[N];//声明一个静态顺序表
void ini(Sqlist &L){
    for(int i = 0;i<L.length;i++)
        L.data[i]=0;
}
bool delete(Sqlist &L,int i,int &e){
    if(i<1||i>L.length)
        return false;//判断位序i是否合法
    e=L.data[i-1];//用e记录被删除的元素
    for(int j = i;j<L.length;j++)
        L.data[j-1]=L.data[j];//将i后的元素前移
    L.length--;//线性表长度-1
    return true;
}
int main(){
   	ini(L);//初始化
    int e = -1;//用变量e把删除的元素”带回来“
    if(delete(L,3,e))
        printf("已删除第3个元素，删除元素值为%d\n",e);
    else
        printf("位序i不合法发，删除失败\n");
    return 0;
}
```

![](/img/110506.jpg)

![](/img/110631.jpg)

![](/img/110751.jpg)

![](/img/110812.jpg)

##### 删除操作的时间复杂度

![](/img/110957.jpg)

#### 2.2.2.2 顺序表的查找

![](/img/135934.jpg)

##### 顺序表的按位查找

![](/img/132817.jpg)

```c++
//静态顺序表的按位查找
#include <iostream>
#include <cstring>
#incldue <stdlib.h>
#include <cstdio>
using namespace std;
const int  N =10;
struct Sqlist{
    int length;
    lnt data;
}sqlist[N];
void init(Sqlist &L){
    for(int i=0;i<L.length;i++)
        L.data[i]=0;
}
int getnum(Sqlist L,int i ){
    return L.data[i-1];//位序和数组下标的关系
}
```

![](/img/133308.jpg)

![](/img/33336.jpg)

![](/img/133411.jpg)

```c++
//动态顺序表的按位查找
#include <iostream>
#include <cstring>
#incldue <stdlib.h>
using namespace std;
const int N =10;
struct Seqlist{
    int *data;
    int maxsize;
    int length;
}seqlist[N];
void init(Seqlist &L){
    L.data=(int *)malloc(N*sizeof(int));
    L.length =0;
    L.maxsize=N;
}
int getnum(Seqlist L,int i){
    return L.data[i-1];
}
```

##### 按位查找的时间复杂度

![](/img/133513.jpg)

##### 顺序表的按值查找

![](/img/134809.jpg)

![](/img/35012.jpg)

![](/img/135451.jpg)

```c++
//爆搜，最好不用，可以自己写二分
#include <iostream>
using namespace std;
const int N =10;
struct Seqlist{
    int *data;
    int maxsize;
    int length;
}seqlist[N];
void init(Seqlist &L){
    L.data=(int *)malloc(N*sizeof(int));
    	L.length=0;
    L.maxsize=N;
}
//爆搜
int loc(Seqlist L,int e){
    for(int i = 0;i<L.length;i++)
        if(L.data[i]==e)
            return i+1;
    return 0;
}
//二分查找
int binary(int l, int r,int x)//l=0,r=length-1;x为想要找的值
{
    while(l<r){
        int mid = l+r>>1;
        if(mid>=x) r = mid;
        else l = mid+1;
    }
    return l;
}
```

##### 结构类型的比较

![](/img/35149.jpg)

```c++
//在C++中可以重载小于号，比如：
struct Edge{
	int a,b,w; //边a,b,权重w
    bool operator<(const Edge &W)const{
        return w<W.w;
    }
}edges[M];
```

##### 按值查找的时间复杂度

![](/img/135602.jpg)

### 2.3 线性表的链式表示

#### 2.3.1 单链表的定义

![](/img/143535.jpg)

![](/img/140125.jpg)

![](/img/140125.jpg)

![](/img/140343.jpg)

##### 用代码定义一个单链表

![](/img/141344.jpg)

![](/img/141502.jpg)

![](/img/141744.jpg)

![](/img/141810.jpg)

```c++
struct Node{
    int val;
 	Node* next;
}*head;
//上面的代码定义可运行，没问题
int main(){
        Node* p = new Node();//定义一个新节点
        p->val = x;//p的值为x;
    	p->next = head;//头插法，p是新的头结点，所以原head是p的下一个节点;
    	head = p;//头结点变为p
		//遍历链表
    for(Node* p  =head;p;p=p->next)
        cout<<p->val<<' ';
    cout<<endl;
    return 0;
}
//yxc版

```

```c++

typedef struct Node{
    int data;
    struct Node* next;
}Node,*head;
Node* p=(Node* )malloc(sizeof(Node))
    //王道书版
```

##### 不带头结点的单链表

```c++
typedef struct Node{
    int data;
    struct Node *next;
}Node,*head;
//初始化一个空的单链表
bool init(head &L){
    L = NULL;//空表，暂时还没有任何节点
    return true;
}
void test(){
    head L;//声明一个指向单链表的指针
    init(L);//初始化一个空表
}
//判断单链表是否为空
bool empty(head L){
    if(L==NULL)
        return true;
    else 
        return false;
}
//判断单链表是否为空简洁版
bool empty(head l){
    return (L=NULL);
}
```

![](/img/1421234910.jpg)

##### 带头结点的单链表

```c++
struct Node{
    int val;
 	Node* next;
}*head;
//上面的代码定义可运行，没问题
int main(){
        Node* p = new Node();//定义一个新节点
        p->val = x;//p的值为x;
    	p->next = head;//头插法，p是新的头结点，所以原head是p的下一个节点;
    	head = p;//头结点变为p
		//遍历链表
    for(Node* p  =head;p;p=p->next)
        cout<<p->val<<' ';
    cout<<endl;
    return 0;
}
//yxc版
```

```c++
typedef struct Node{
	int val;
    Node* next;
}Node,*head;
//初始化一个单链表（带头结点）
bool init(head &L){
    L = (Node* )malloc(sizeof(Node));//分配一个头结点
    if(L==NULL)//内存不足，分配失败
        	return false;
    L->next = NULL;//头结点之后暂时还没有节点
    return true;
}
void test(){
    head L;//声明一个指向单链表的指针
    init(L);//初始化一个空表
}
//判断单链表是否为空（带头结点）
bool empty(head L){
    if(L->next ==NULL)
        return true;
    else 
        return false;
}
//王道书版
```

![](/img/143411.jpg)

##### 不带头结点 vs 带头结点

![](/img/143521.jpg)

#### 2.3.2.1 单链表的插入删除

![](/img/170535.jpg)

##### 关于简化图示的说明

![](/img/150317.jpg)

##### 按位序插入（带头结点）

![](/img/150422.jpg)

![](/img/150446.jpg)

```c++
struct Node{
    int val;
 	Node* next;
}*head;
//上面的代码定义可运行，没问题
int main(){
        Node* p = new Node();//定义一个新节点
        p->val = x;//p的值为x;
    	p->next = head;//头插法，p是新的头结点，所以原head是p的下一个节点;
    	head = p;//头结点变为p
		//遍历链表
    for(Node* p  =head;p;p=p->next)
        cout<<p->val<<' ';
    cout<<endl;
    return 0;
}
//yxc版
```

```c++
typedef struct Node{
	int val;
    Node* next;
}Node,*head;
//初始化一个单链表（带头结点）
bool init(head &L){
    L = (Node* )malloc(sizeof(Node));//分配一个头结点
    if(L==NULL)//内存不足，分配失败
        	return false;
    L->next = NULL;//头结点之后暂时还没有节点
    return true;
}
void test(){
    head L;//声明一个指向单链表的指针
    init(L);//初始化一个空表
}
//在第i个位置插入元素e（带头结点）
bool insert(head &L,int i ,int e){
    if(i<1)//i不合法
        return false;
    Node* p;//指针p指向当前扫描到的节点
    int j = 0;//当前p指向的是第几个节点
    p = L;//L指向头结点，头结点是第0个节点（不存数据）
    while(p!=NULL && j<i-1){//循环找到第i-1个节点
        p=p->next;
        j++;
    }
    if(p==NULL)//i值不合法
        return false;
    Node *s = (LNode *)malloc(sizeof(Node));//定义一个新节点，此即要插入的节点
    s->val=e;//新插入的节点的值为e
    s->next=p->next;//插入，把s指向头结点的下一个节点
    p->next = s;//s变为头结点的下一个节点，将节点s连到p之后
    return true;//插入成功
}
```

![](/img/151153.jpg)

![](/img/151228.jpg)

* 顺序颠倒会导致原头结点的下一个节点数据的丢失

![](/img/151337.jpg)

![](/img/151418.jpg)

![](/img/151530.jpg)

![](/img/151609.jpg)

![](/img/151631.jpg)

##### 按位序插入（不带头结点）

![](/img/51715.jpg)

```c++
typedef struct Node{
    int val;
    struct Node* next;
}Node,*head;
bool insert(head &L,int i ,int e){
    if(i<1)//位序的合法性判断
        return false;
    if(i==1){//插入第1个节点的操作与其他节点操作不同
        Node* s = (Node*)malloc(sizeof(Node));
        s->data=e;//赋值
        s->next=L;//s成为第一个节点，下一个节点是L
        L=s;//头指针指向新节点
        return true;
    }
    Node* p;//指针p指向当前扫描到的节点
    int j = 1;//当前p指向的是第几个节点
    p  = L;//p指向第1个节点（注意：不是头结点），准备从头开始bianli 
    while(p!=NULL&&j<i-1){//循环找到第i-1个节点
        p = p->next;//往下一个节点走
        j++;//当前扫描的节点
    }
    if(p=NULL)//i值不合法
        return false;
    Node* s= (Node*) malloc(sizeof(Node));//找到位置，准备插入，开辟一个新节点
    s->val = e;//要插入的值
    s->next = p->next;//插入
    p->next = s;
    return true;
}
```

![](/img/54434.jpg)

![](/img/154447.jpg)

![](/img/154531.jpg)

![](/img/154636.jpg)

##### 指定节点的后插操作

```c++
//后插操作：在p结点之后插入元素e
bool insertnext(Node *p,int e){
    if(p==NULL)
        return false;
    Node* s=(Node *)malloc(sizeof (Node));//申请节点空间
    if(s==NULL)//内存分配失败
        return false;
    s->data=e;//用节点s保存数据元素e
    s->next=p->next;//s指向p指向的节点
    p->next=s;//p指向s，在p和p的下一个节点中间插入s
    return true;
}
//定义一个节点类型
typedef struct Node{
    int data;
    struct Node* next;
}Node,*head;
```

![](/img/55046.jpg)

![](/img/55110.jpg)

![](/img/55124.jpg)

![](/img/155247.jpg)

![](/img/155400.jpg)

##### 指定节点的前插操作

![](/img/155511.jpg)

```c++
//前插操作：在p结点之前插入元素e
bool insertpri(Node* p,int e){
    if(p==NULL)//p是否合法
        return false;
    Node *s = (Node*)malloc(sizeof(Node));//分配新空间
    if(s==NULL)//内存分配失败
        return false;
    s->next=p->next;//s指向p指向的节点，即s指向p的下一个节点
    p->next=s;//p指向s
    s->data=p->data;//s保存p保存的值
    p->data=e;//p的值变为要存放的节点，即把p变成新节点
    //相当于本来要在p前面插入一个新节点，但实际上开了一个p节点的副本s节点相当于原p节点，p节点变为插在原p结点前的新节点
    return true;
}
```

![](/img/163847.jpg)

![](/img/163856.jpg)

![](/img/64017.jpg)

##### 按位序删除（带头结点）

![](/img/164544.jpg)

![](/img/164559.jpg)

![](/img/164622.jpg)

```c++
typedef struct Node{
	int data;
    struct Node* next;
}Node,*head;//定义节点类型
bool delete(head &L,int i ,int &e){
    if(i<1)//检测位序合法性
        return false;
    Node*p;//指针p指向当前扫描到的节点
    int j = 0;//当前p指向的是第几个节点
    p=L;//L指向头结点，头结点是第0个节点（不存数据）
    while(p!=NULL&&j<i-1){//循环找到第i-1个节点
        p=p->next;
      	j++;
    }
    if(p==NULL)//i值不合法
        return false;
    if(p->next == NULL)//第i-1个结点之后已无其他节点
        return false;
    Node* q = p->next;//令q指向被删除节点
    e=q->data;//用e返回元素的值
    p->next=q->next;//将*q节点从链中断开
    free(q);//释放节点的存储空间
    return true;//删除成功
}
```

![](/img/64917.jpg)

![](/img/165218.jpg)

![](/img/165233.jpg)

![](/img/165253.jpg)

![](/img/165339.jpg)

##### 指定节点的删除

![](/img/165407.jpg)

```c++
//删除指定节点p（把p变为p后面的一个节点，将原p从链中丢掉）
bool remove(Node* p){
    if(p==NULL)
        return false;
    Node* q=p->next;//q指向p的后继节点//q相当于一个tmp变量
    p->data=p->next->data//p存储原p后继节点的数据，和后继节点交换数据域
        p->next=q->next;//将原p节点从链中断开，p的下一个节点指向q的下一个节点，即p指向p后继节点的后继节点，将p变为自身的后继节点
    free(q);//释放后继节点的存储空间
    return true;
}
```

![](/img/170030.jpg)

![](/img/70049.jpg)

![](/img/170106.jpg)

![](/img/170217.jpg)

![](/img/70254.jpg)

![](/img/170327.jpg)

##### 封装的好处

![](/img/170559.jpg)

![](/img/171627.jpg)

![](/img/171706.jpg)

#### 2.3.2.2 单链表的查找

![](/img/170627.jpg)

##### 按位查找

```c++
//按位查找，返回第i个元素（带头结点）
typedef struct Node{
    int data;
    struct Node* next;
}Node,*head;//定义一个节点类型
Node* getnum(head L,int i){
    if(i<0)//判断i是否合法
        return NULL;
    Node* p;//指针p指向当前扫描到的节点
    int j = 0;//当前p指向的是第几个节点
    p = L;//L指向头结点，头结点是第0个节点（不存数据）
    while(p!=NULL && j<i){//循环找到第i个节点
        p=p->next;
        j++;
    }
    return p;
}
```

* i=0，直接返回头结点

![](/img/171239.jpg)

* 当i的值不合法，返回的是NULL

![](/img/171339.jpg)

![](/img/171400.jpg)

##### 按值查找

```c++
typedef struct Node{
    int data;
    struct Node* next;
}Node,*head;
//按值查找，找到数据域==e的节点
Node* find(head L,int e){
    Node* p = L->next;//L是头结点
    //从第一个节点开始查找数据域为e的节点
    while(p!=NULL&&p->data !=e)
        p=p->next;
    return p;//找到后返回该结点指针，否则返回NULL
}
```

```c++
//yxc版
struct Node{
	int val;
	Node*next;
}*head;
Node* find(int x){//要找的值是x，返回值=x的节点
    for(Node *p = head;p;p->next)
        if(p->val==x)
            return p;
}

```

* 可以找到的情况

![](/img/172359.jpg)

* 无法找到的情况，跳出循环，返回NULL

![](/img/172511.jpg)

##### 求表的长度

```c++
//王道版求表的长度
struct Node{
    int data;
    struct Node *next;
}Node,*head;
int length(head L){
    int len =0;
    Node*p = L;
    while(p->next !=NULL){
        p=p->next;
        len++;
    }
    return len;
}
```

```c++
//yxc版
struct Node{
    int val;
    Node *next;
}*head;
int getlength(){
    int len=0;
    for(Node *p = head;p;p->next)
        len++;
    return len;
}
```

![](/img/173232.jpg)

![](/img/173241.jpg)

#### 2.3.2.3 单链表的建立

![](/img/185647.jpg)

![](/img/192942.jpg)

##### 尾插法建立单链表

```c++
typedef struct Node{//定义单链表节点类型
    int data;//每个节点存放一个数据元素
    struct Node *next;//指针指向下一个节点
}Node,*head;
//初始化一个单链表（带头结点）
bool init(head &L){
    L =(Node*) malloc(sizeof(Node));
    if(L==NULL)//内存不足，分配失败
        return false;
    L->next = NULL;
    return true;
}
void test(){
    head L;//声明一个指向单链表的指针
    //初始化一个空表
    init(L);
    
}
```

![](/img/185947.jpg)

```c++
/*准备工作
typedef struct Node{
	int val;
    Node* next;
}Node,*head;
//初始化一个单链表（带头结点）
bool init(head &L){
    L = (Node* )malloc(sizeof(Node));//分配一个头结点
    if(L==NULL)//内存不足，分配失败
        	return false;
    L->next = NULL;//头结点之后暂时还没有节点
    return true;
}
void test(){
    head L;//声明一个指向单链表的指针
    init(L);//初始化一个空表
}
*/
//在第i个位置插入元素e（带头结点）
bool insert(head &L,int i ,int e){
    if(i<1)//i不合法
        return false;
    Node* p;//指针p指向当前扫描到的节点
    int j = 0;//当前p指向的是第几个节点
    p = L;//L指向头结点，头结点是第0个节点（不存数据）
    while(p!=NULL && j<i-1){//循环找到第i-1个节点
        p=p->next;
        j++;
    }
    if(p==NULL)//i值不合法
        return false;
    Node *s = (LNode *)malloc(sizeof(Node));//定义一个新节点，此即要插入的节点
    s->val=e;//新插入的节点的值为e
    s->next=p->next;//插入，把s指向头结点的下一个节点
    p->next = s;//s变为头结点的下一个节点，将节点s连到p之后
    return true;//插入成功
}
尾插法建立单链表：
    初始化单链表
    设置变量length记录链表长度
    while循环{
    每次取一个数据元素e
        insert(L,length+1,e)插到尾部;
    length++;
}
```

![](/img/190755.jpg)

![](/img/190849.jpg)

![](/img/191034.jpg)



```c++
/*准备工作
typedef struct Node{
	int val;
    Node* next;
}Node,*head;
//初始化一个单链表（带头结点）
bool init(head &L){
    L = (Node* )malloc(sizeof(Node));//分配一个头结点
    if(L==NULL)//内存不足，分配失败
        	return false;
    L->next = NULL;//头结点之后暂时还没有节点
    return true;
}
void test(){
    head L;//声明一个指向单链表的指针
    init(L);//初始化一个空表
}
*/
//后插法：
head listlist (list &L){//正向建立单链表
    int x;//设为int型
 L=(head)malloc(sizeof(Node));//建立头结点
    Node*s,*r=L;//r为表尾指针
    cin>>x;//输入节点的值
    while(x!=9999){//输入9999表示结束
s=(Node*)malloc(sizeof(Node));
        //s为新加入的节点
        s->data=x;//s保存新加入的节点的数据
        r->next =s;//s变为尾节点，原尾结点指向s
        r=s;//s成为新的尾结点
        cin>>x;//继续输入要加入的值
    }
    //表内数据输入完成
    r->next=NULL;//尾结点指针置空
    return L;//返回头结点
}
```

![](/img/192024.jpg)

![](/img/92042.jpg)

![](/img/192111.jpg)

![](/img/192115.jpg)

![](/img/192249.jpg)

##### 头插法建立单链表

![](/img/192321.jpg)

```c++
/*准备工作
typedef struct Node{
	int val;
    Node* next;
}Node,*head;
//初始化一个单链表（带头结点）
bool init(head &L){
    L = (Node* )malloc(sizeof(Node));//分配一个头结点
    if(L==NULL)//内存不足，分配失败
        	return false;
    L->next = NULL;//头结点之后暂时还没有节点
    return true;
}
void test(){
    head L;//声明一个指向单链表的指针
    init(L);//初始化一个空表
}
*/

head listlist(head &L){//逆向建立单链表
    Node* s;
    int x;
    L=(head)malloc(sizeof(Node));//创立头结点
    L->next=NULL;//初始为空链表
    cin>>x;//输入节点的值
    while(x!=9999){//输入9999表示结束
        s=(Node* )malloc(sizeof(Node));//创建新节点
        s->data=x;//s记录新节点的数值
        s->next=L->next;//s指向原头结点指向的节点
        L->next=s;//将新节点插入表中，L为头指针，s成为新的第一个节点
        cin>>x;
    }
    return L;
}
```

![](/img/192638.jpg)

![](/img/92814.jpg)

![](/img/92833.jpg)

#### 2.3.3 双链表

![](/img/201036.jpg)

##### 单链表 vs 双链表

![](/img/193101.jpg)

##### 双链表的初始化（带头结点）

![](/img/193533.jpg)

```c++
//双链表节点的定义：
typedef struct dnode{
    int data;
    struct dnode *prior,*next;
}dnode,*dlist;
//初始化双链表
bool init(dlist &L){
    L=(dnode*)malloc(sizeof(dnode));//分配一个头结点
    if(L==NULL)//内存不足，分配失败
	return false;
    L->prior=NULL;//头结点的prior永远指向NULL
    L->next = NULL;//头结点之后暂时还没有节点
    return true;
}
void testdlist(){
    //初始化双链表
    dlist L;
    init(L);
}
//判断双链表是否为空
bool empty(dlist L){
    if(L->next == NULL)
        return true;
    else 
        return false;
}

```

##### 双链表的插入

```c++
//在p结点之后插入s节点
bool insert(dnode *p,denode *s)
{
    s->next = p->next;//s指向p的右侧节点，将节点s插入到节点p之后
    p->next->prior=s;//p的右侧节点的左指向s
    s->prior=p;//s的左节点为p
    p->next=s;//p的右节点为s
}
```

![](/img/193853.jpg)

![](/img/193915.jpg)

![](/img/194033.jpg)

![](/img/194114.jpg)

![](/img/194144.jpg)

![](/img/194213.jpg)

* p节点没有后继节点的情况

```c++
//在p结点之后插入s节点
bool insertnext(dnode* p,denode* s){
    if(p==NULL ||s == NULL)//非法参数
	return false;
    s->next=p->next;
    if(p->next !=NULL)//如果p节点有后继节点
        p->next->prior=s;
    s->prior=p;
    p->next=s;
    return true;
}
```

![](/img/195812.jpg)

![](/img/195844.jpg)

![](/img/195907.jpg)

##### 双链表的删除

![](/img/200002.jpg)

![](/img/200017.jpg)

![](/img/200035.jpg)

![](/img/200043.jpg)

![](/img/200103.jpg)

```c++
//删除p节点的后继节点
bool deletenext(dnode *p){
    if(p==NULL)return false;
    dnode *q=p->next;//找到p的后继节点q
    if(q==NULL)return false;//p没有后继
    p->next=q->next;//p的右节点跳过q
    if(q->next!=NULL)//q节点不是最后一个节点
        q->next->prior=p;//q的下一个点的左节点变为p
    free(q);//释放节点空间
    return true;
}
//删掉整个链表
void destroy(dlist &L){
    //循环释放各个数据节点
    while(L->next !=NULL)
        deletenext(L);
    free(L);//释放头结点
    L=NULL;//头指针指向NULL
}
```

![](/img/200622.jpg)

##### 双链表的遍历

```c++
//后向遍历
while(p!=NULL){
    //对p节点做相应处理，如打印
    p=p->next;
}
//前向遍历
while(p!=NULL){
    //对节点p做相应处理
    p=p->prior;
}
//前向遍历（跳过头结点）
while(p->prior!=NULL){
    //对节点p做相应处理
    p=p->prior;
}
```

![](/img/201008.jpg)

#### 2.3.4 循环链表

![](/img/231621.jpg)

##### 循环单链表

```c++
typedef struct lnode{//定义单链表节点类型
int data;//每个节点存放一个数据元素
struct lnode *next;//指针指向下一个节点
}lnode,*head;
//初始化一个循环单链表
bool init(head &L){
    L=(lnode* )malloc(sizeof(lnode));//分配一个头结点
    if(L==NULL)//内存不足，分配失败
        return false;
    L->next=L;//头结点next指向头结点
    return true;
}
//判断循环单链表是否为空
bool empty(head L){
    if(L->next == L)
        return true;
    else 
        return false;
}
//判断节点p是否为循环单链表的表尾结点
bool istail(head L,lnode *p){
    if(p->next==L)
        return true;
    else 
        return false;
}
```

![](/img/223336.jpg)

![](/img/230345.jpg)

![](/img/230503.jpg)

##### 循环双链表

![](/img/230533.jpg)

```c++
typedef struct dnode{
    int data;
    struct dnode *prior,*next;
}dnode,*head;
//初始化空的循环双链表
bool init(head &L){
    L=(dnode*)malloc(sizeof(dnode));//分配一个头结点
    if(L==NULL)//内存不足，分配失败
        return false;
    L->prior=L;//头结点的pior指向头结点
    L->next =L;//头结点的next指向头结点
    return true;
}
void testdlist(){
    //初始化循环双链表
    head L;
    init(L);
}
//判断循环双链表是否为空
bool empty(head L){
    if(L->next ==L)
        return true;
    else 
        return false;
}
//判断节点p是否为循环双链表的表尾结点
bool istail(head L,dnode*p){
    if(p->next ==L)
        return true;
    else 
        return false;
}
```

![](/img/230929.jpg)

##### 双链表的插入

```c++
//在p结点之后插入s节点
bool insert(dnode *p,dnode* s){
	s->next = p->next;//将节点s插入到节点p后面
    p->next->prior=s;//p的右节点的左箭头指向s
    s->prior=p;//s的左箭头指向p
    p->next=s;//p的右箭头指向s
}
```

![](/img/231323.jpg)

##### 双链表的删除

```c++
//删除p的后继节点q
p->next=q->next;//p指向后继节点的右节点
q->next->prior=p;//p的后继节点的后继节点的左节点变为q
free(q);//释放q节点
```

![](/img/231517.jpg)

#### 2.3.5 静态链表

![](/img/215233.jpg)

##### 什么是静态链表

![](/img/024254.jpg)

##### 用代码定义一个静态链表

```c++
const int maxsize =10;//静态链表的最大长度
struct Node{//静态链表结构类型的定义
	int data;//存储数据元素
	int next;//下一个元素的数组下标
}node[maxsize];
void test(){
   Node a;//数组a作为静态链表
}
```

```c++
//yxc版
// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
int head, e[N], ne[N], idx;//e为节点的值，ne为指向的地址
//因为是从0开始的，所以第k的插入点的下标是k-1
// 初始化
void init()
{
    head = -1;
    idx = 0;
}

// 在链表头插入一个数a，即头插法
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;//idx即新插入的点的下标
}

//将x插入到下标是k的点的后面
void add(int k ,int x)
{
    e[idx] = x;
    ne[idx]=ne[k];
    ne[k]=idx++;
    
}

//将下标是k的点后面的点删掉
void remove(int k){
    ne[k]=ne[ne[k]];
}


// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}

//遍历单链表
for(int i = head;i!=-1;i=ne[i])
    	cout<<e[i]<<endl; 
```

![](/img/024517.jpg)

##### 简述基本操作的实现

* 初始化

![](/img/3214224.jpg)

* 查找（位序的节点）

![](/img/214026.jpg)

* 插入位序为i的节点

![](/img/214154.jpg)

* 删除某个节点

![](/img/214414.jpg)

```c++
#define maxsize 10//静态链表的最大长度
typedef struct{//静态链表结构类型的定义
    int data;//存储数据元素
    int next;//下一个元素的数组下标
}slist[maxsize];
```

```c++
//yxc,数组模拟单链表
// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
int head, e[N], ne[N], idx;//e为节点的值，ne为指向的地址
//因为是从0开始的，所以第k的插入点的下标是k-1
// 初始化
void init()
{
    head = -1;
    idx = 0;
}

// 在链表头插入一个数a，即头插法
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;//idx即新插入的点的下标
}

//将x插入到下标是k的点的后面
void add(int k ,int x)
{
    e[idx] = x;
    ne[idx]=ne[k];
    ne[k]=idx++;
    
}

//将下标是k的点后面的点删掉
void remove(int k){
    ne[k]=ne[ne[k]];
}


// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}

//遍历单链表
for(int i = head;i!=-1;i=ne[i])
    	cout<<e[i]<<endl; 
```

#### 2.3.6 顺序表和链表的比较

![](/img/221005.jpg)

##### 逻辑结构

![](/img/215630.jpg)

##### 存储结构

![](/img/215827.jpg)

##### 基本操作

![](/img/220442.jpg)

* 初始化（创建）

![](/img/220549.jpg)

* 销

![](/img/220704.jpg)

* 增删

![](/img/220821.jpg)

* 查找

![](/img/20856.jpg)

##### 用顺序表or链表

![](/img/220926.jpg)

## 第三章 栈、队列和数组

### 3.1 栈

#### 3.1.1 栈的基本概念

![](/img/30131.jpg)

##### 栈的定义

![](/img/221727.jpg)

![](/img/22002.jpg)

##### 线性表的基本操作

![](/img/222027.jpg)

##### 栈的基本操作

![](/img/222140.jpg)

##### 栈的常考题型 

![](/img/222343.jpg)

#### 3.1.2 栈的顺序存储实现

![](/img/230745.jpg)

![](/img/33428.jpg)

##### 顺序栈的定义

![](/img/231009.jpg)

![](/img/231042.jpg)

```c++
#define maxsize 10//定义栈中元素的最大个数
typedef struct{
    int data[maxsize]//静态数组存放栈中元素
    int top;//栈顶指针
}sqstack;
```

```c++
//yxc
// tt表示栈顶
int stk[N], tt = 0;//stk表示栈，tt表示栈顶下标

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空，如果 tt > 0，则表示不为空
if (tt > 0) not empty;
else empty;

//栈顶
stk[tt];
```

##### 初始化操作

![](/img/3231300.jpg)

```c++
#define maxsize 10//定义栈中元素的最大个数
typedef struct{
    int data[maxsize]//静态数组存放栈中元素
    int top;//栈顶指针
}sqstack;
//初始化栈
void init(sqstack &s){
    s.top=-1;//初始化栈顶指针
}
bool ifempty(sqstack s){
    if(s.top==-1)//栈空
        return true;
    else 
        return false;//不空
}
```

##### 进栈操作

```c++
#define maxsize 10//定义栈中元素的最大个数
typedef struct{
	int data[maxsize];//静态数组存放栈中元素
	int top;//栈顶指针
}sqstack;
//新元素入栈
bool push(sqstack &s,int x){
	if(s.top==maxsize-1)//栈满，报错
		return false;
        s.top = s.top+1;//指针先加1
        s.data[s.top]=x;//新元素入栈
        return true;
}
```

![](/img/231823.jpg)

![](/img/231849.jpg)

##### 出栈操作

```c++
#define maxsize  10//定义栈中元素的最大个数
typedef struct{
    int data[maxsize];//静态数组存放栈中元素
    int top;//栈顶指针
}sqstack;
//出栈操作
bool pop(sqstack &s,int &x){
    if(s.top==-1)//栈空，报错
        return false;
    x=s.data[s.top];//栈顶元素先出栈
    s.top=s.top-1;//指针再-1
    return true;
}
```

![](/img/3232423.jpg)

##### 读取栈顶元素操作

![](/img/232505.jpg)

```c++
#define maxsize  10//定义栈中元素的最大个数
typedef struct{
    int data[maxsize];//静态数组存放栈中元素
    int top;//栈顶指针
}sqstack;
//出栈操作
bool pop(sqstack &s,int &x){
    if(s.top==-1)//栈空，报错
        return false;
    x=s.data[s.top];//栈顶元素先出栈
    s.top=s.top-1;//指针再-1
    return true;
}
//读栈顶元素
bool gettop(sqstack s,int &x){
    if(s.top==-1)//栈空，报错
        return false;
    x=s.data[s.top];//x记录栈顶元素
    return true;
}
```

##### 另一种方式

```c++
#define maxsize 10//定义栈中元素的最大个数
typedef struct{
    int data[maxsize];//静态数组存放栈中元素
    int top;//栈顶指针
}sqstack;
//初始化栈
void init(sqstack &s){
    s.top=0;//初始化栈顶指针
}
//判断栈空
bool empty(sqstack s){
    if(s.top==0)//栈空
        return true;
    else //不空
        return false;
}
```

![](/img/232648.jpg)

![](/img/233118.jpg)

##### 共享栈

```c++
#define maxsize 10//定义栈中元素的最大个数
typedef struct{
    int data[maxsize];//静态数组存放栈中元素
    int top0;//0号栈栈顶指针
    int top1;//1号栈栈顶指针
}shstack;
//初始化栈
void init(shstack &s){
    s.top0=-1;//初始化栈顶指针
        s.top1=maxsize;
}
```

![](/img/233338.jpg)

#### 3.1.3 栈的链式存储实现

![](/img/234236.jpg)

##### 链栈的定义

```c++
typedef struct linknode{
    int data;//数据域
    struct linknode *next;//指针域
}*listack;//栈类型定义
```

![](/img/233451.jpg)

### 3.2 队列

#### 3.2.1 队列的基本概念

![](/img/234536.jpg)

##### 队列的定义

![](/img/234321.jpg)

![](/img/234356.jpg)

![](/img/234416.jpg)

##### 队列的基本操作

![](/img/34502.jpg)

#### 3.2.2 队列的顺序实现

![](/img/20524.jpg)

```c++
#define maxsize 10//定义队列中元素的最大个数
typedef struct {
    int data[maxsize];//用静态数组存放队列元素
    int front,rear;//队头指针和队尾指针
}sqqueue;
void testqueue(){
    sqqueue Q;//声明一个队列（顺序存储）
}
```

```c++
//yxc
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

//取出队尾
q[tt];

// 判断队列是否为空，如果 hh <= tt，则表示不为空
if (hh <= tt) not empty;
    else empty;
```

![](/img/234824.jpg)

##### 初始化操作

```c++
#define maxsize 10//定义队列中元素的最大个数
typedef struct {
    int data[maxsize];//用静态数组存放队列元素
    int front,rear;//队头指针和队尾指针
}sqqueue;
//初始化队列
void init(sqqueue &Q){
    //初始时，对头、队尾指针指向0
    Q.rear=Q.front=0;
}
//判断队列是否为空
bool empty(sqqueue Q){
    if(Q.rear==Q.front)//队空条件
        return true;
    else return false;
}
void testqueue(){
    sqqueue Q;//声明一个队列（顺序存储）
}
```

![](/img/234948.jpg)

##### 入队操作

```c++
#define maxsize 10//定义队列中元素的最大个数
typedef struct {
    int data[maxsize];//用静态数组存放队列元素
    int front,rear;//队头指针和队尾指针
}sqqueue;
//入队
bool inq(sqqueue &Q,int x){
    if(队列已满)
        return false;//队满则报错
    Q.data[Q.rear]=x;//将新元素x插入队尾
    Q.rear=Q.rear+1;//队尾指针后移
    return true;
}
```

![](/img/001257.jpg)

![](/img/001327.jpg)

![](/img/012301351.jpg)

![](/img/001420.jpg)

![](/img/001510.jpg)

![](/img/001729.jpg)

##### 循环队列

![](/img/01810.jpg)

![](/img/01833.jpg)

![](/img/002018.jpg)

##### 循环队列——入队操作

```c++
//判断队列是否为空
bool empty(sqq Q){
    if(Q.rear==Q.front)//队空条件
        return true;
    else 
        return false;
}
//入队
bool inq(sqq &Q,int x){
if((Q.rear+1)%maxsize==Q.front))
    return false;//队满则报错
Q.data[Q.rear]=x;//新元素插入队尾
Q.rear=(Q.rear+1)%maxsize;//队尾指针加1取模
	return true;
}
```

![](/img/02823.jpg)

##### 循环队列——出队操作

![](/img/5 003054.jpg)

![](/img/003037.jpg)

```c++
//出队（删除一个队头元素，并用x返回）
bool dequeue(sqqueue &Q,int &x){
    if(Q.rear==Q.front)
        return false;//队空则报错
    x=Q.data[Q.front];
    Q.front=(Q.front+1)%maxsize;
    return true;
}
//获得队头元素的值，用x返回
bool gethead(sqqueue Q,int &x){
    if(Q.rear==Q.front)
        return false;//队空则报错
    x=Q.data[Q.front];
    return true;
}
```

![](/img/003259.jpg)

![](/img/003732.jpg)

##### 方案一：判断队列已满/已空

![](/img/003859.jpg)

##### 方案二：判断队列已满/已空

![](/img/004627.jpg)

![](/img/005723.jpg)

![](/img/010525.jpg)

![](/img/10615.jpg)

![](/img/012029.jpg)

##### 方案三：判断队列已满/已空

![](/img/015907.jpg)

![](/img/020127.jpg)

##### 其他出题方法

![](/img/020219.jpg)

![](/img/020307.jpg)

![](/img/20408.jpg)

#### 3.2.3 队列的链式实现

![](/img/64045.jpg)

```c++
typedef struct linknode{//链式队列节点
    int data;
	struct linknode *next;
}linknode;
typedef struct{//链式队列
    linknode *front,*rear;//队列的队头和队尾指针
}linkqueue;

```

![](/img/105247.jpg)

![](/img/105324.jpg)

##### 初始化（带头结点）

```c++
typedef struct linknode{
	int data;
	struct linknode *next;
}linknode;
typedef struct{
    linknode *front,*rear;
}linkqueue;
//初始化队列（带头节点）
void init(linkqueue &Q){
    //初始时，front、rear都指向头结点
    Q.front=Q.rear=(linknode*)malloc(sizeof(linknode));
    Q.front->next=NULL;
}
void testlinkqueue(){
    linkqueue Q;//声明一个队列
	init(Q);//初始化一个队列
}
//判断队列是否为空
bool empty(linkqueue Q){
    if(Q.front==Q.rear)
        return true;
    else 
        return false;
}
```

![](/img/105721.jpg)

##### 初始化（不带头结点）

```c++
//初始化队列（不带头结点）
void init(linkqueue &Q){
    //初始时 front、rear都指向NULL
    Q.front=NULL;
    Q.rear=NULL;
    
}
//判断队列是否为空（不带头结点）
bool empty(linkqueue Q){
    if(Q.front ==NULL)
        return true;
    else 
        return false;
    
}
```

![](/img/145827.jpg)

##### 入队（带头结点）

```c++
//新元素入队（带头结点）
void enqueue(linkqueue &Q,int x){
    linknode *s=(linknode *)malloc(sizeof(linknode));//申请一个新的节点
    s->data=x;//把数据x放到这个新节点中
    s->next=NULL;
    Q.rear->next=s;//新节点插入到rear之后
    Q.rear=s;//修改表尾指针
}
```

![](/img/61628.jpg)

##### 入队（不带头结点）

```c++
//新元素入队（不带头节点）
void enqueue(linkqueue &Q,int x){
    linknode *s=(linknode *)malloc(sizeof(linknode));//申请一个新节点
    s->data=x;//将数据元素x存入新节点中
    s->next=NULL;
    if(Q.front==NULL){//在空队列中插入第一个元素
        Q.front=s;//修改队头队尾指针
        Q.rear=s;
        
    }
    else{
        Q.rear->=x;//新节点插入到rear接待年之后
        Q.rear=s;//修改rear指针
    }
}
```

![](/img/213162018.jpg)

##### 出队（带头结点）

```c++
//队头元素出队（不带头节点）
bool dequeue(linkqueue &Q,int &x){
    if(Q.front==Q.rear)//空队
        return false;
    linknode *p=Q.front->next;
    x=p->data;//用变量x返回队头元素
    Q.front->next=p->next;//修改头结点的next指针
    if(Q.rear==p)//此次是最后一个节点出队
        Q.rear=Q.front;//修改rear指针
	free(p);//释放节点空间
    return true;
}
```

![](/img/162420.jpg)

![](/img/162449.jpg)

![](/img/162528.jpg)

![](/img/162558.jpg)

##### 出队（不带头结点）

```c++
//队头元素出队（不带头结点）
bool dequeue(linkqueue &Q,int &x){
    if(Q.front==NULL)
        return false;//空队
    linknode *p=Q.front;//p指向此次出队的节点
    x=p->data;//用变量x返回队头元素
    Q.front=p->next;//修改front指针
    if(Q.rear==p){//此次是最后一个节点出队
        Q.front=NULL;//front指向NULL
        Q.rear=NULL//rear指向NULL
        
    }
    free(p);//释放节点空间
    return true;
}
```

![](/img/163452.jpg)

##### 队列满的条件

![](/img/163600.jpg)



#### 3.2.4 双端队列

![](/img/215747.jpg)

##### 双端队列

![](/img/65800.jpg)

![](/img/165931.jpg)

##### 考点：判断输出序列合法性

* 若果在输出序列中看到某一个序号的元素，那么在这个元素输出之前，意味着它之前的所有的那些元素，肯定都已经输入到这个队列里边了

###### 栈

![](/img/215028.jpg)

![](/img/215054.jpg)

###### 输入受限的双端队列

![](/img/215213.jpg)

* 下划线是栈中非法但是输入受限的双端队列中合法的输出序列

###### 输出受限的双端队列

![](/img/215458.jpg)

### 3.3 栈和队列的应用

#### 3.3.1 栈在括号匹配中的应用

![](/img/230809.jpg)

##### 括号匹配问题

* 当我们遇到左括号的时候，就把它压入栈中，当我们遇到右括号的时候，就把栈顶的那个左括号给弹出，然后检查他们两是否匹配

![](/img/20240.jpg)

##### 算法演示

```c++
//yxc表达式求值
#include <iostream>
#include <cstring>
#include <stack>
#include <vector>
#include <unordered_map>
#include <algorithm>
using namespace std;
stack<int> num;
stack<char> op;
void eval(){
    auto b = num.top();num.pop();
    auto a = num.top();num.pop();
    auto c = op.top();op.pop();
    int x ;
    if(c=='-') x = a-b;
    else if (c=='+')x=a+b;
    else if (c=='*') x =a*b;
    else x = a/b;
    num.push(x);
}

int main(){
    string str;
    cin>>str;
    unordered_map<char,int> pr{{'+',1},{'-',1},{'*',2},{'/',2}};
    for(int i = 0;i<str.size();i++){
        auto c = str[i];
        if(isdigit(c)){
            int x = 0,j=i;
            while(j<str.size()&&isdigit(str[j]))x=x*10+str[j++]-'0';
            num.push(x);
            i=j-1;
        }
        else if(c=='(') op.push(c);
        else if(c==')'){
            while(op.size()&&op.top()!='(') eval();
            op.pop();
        }
        else {
            while(op.size()&&op.top()!='('&&pr[op.top()]>=pr[c])eval();
            op.push(c);
        }
    }
    while(op.size())eval();

    cout<<num.top();
    return 0;




}

```

![](/img/20923.jpg)

![](/img/5220958.jpg)

![](/img/221017.jpg)

![](/img/21056.jpg)

![](/img/3143234.gif)

![](/img/5221915.jpg)

![](/img/22117.jpg)

![](/img/222144.jpg)

![](/img/224034.jpg)

```c++
//算法实现
#define maxsize 10//定义栈中元素的最大个数
typedef struct{
    char data[maxsize];//静态数组存放栈中元素
	int top;//栈顶指针
}sqstack;
//初始化栈
void init(sqstack &S)
    //判断栈是否为空
    bool empty(sqstack S)
    //新元素入栈
    bool push(sqstack &S,char x)
    //栈顶元素出栈，用x返回
    bool pop(sqstack &S,char &x)
  //匹配括号
bool check(char str[],int length){
    sqstack S;
    init(S);//初始化一个栈
    for(int i = 0;i<length;i++){
        if(str[i]=='('||str[i]=='['||str[i]=='{'){
            push(S,str[i]);//扫描到左括号，入栈
        }
        else{
            if(empty(S))//扫描到右括号，且当前栈空
                return false;//匹配失败
        
        char top;
        //如果没扫描到左括号，扫描到右括号且当前栈非空
        pop(S,top);//栈顶元素出栈
  		if(str[i]==')'&&top!='(')
            return false;
        if(str[i]==']'&&top!='[')
            return false;
        if(str[i]=='}'&&top!='{')
            return false;
        }
    }
    return empty(S);//检索完全部括号后，栈空说明匹配成功
}
```

![](/img/225156.jpg)

#### 3.3.2 栈在表达式求值中的应用

![](/img/3124.jpg)

![](/img/724452.jpg)

![](/img/033854.jpg)

##### 熟悉的算术表达式

![](/img/13042.jpg)

![](/img/213403.jpg)

##### 中缀、后缀、前缀表达式

![](/img/213618.jpg)

![](/img/214304.jpg)

* 后缀左优先，前缀右优先

##### 中缀表达式转后缀表达式（手算）

![](/img/12342134.gif)

![](/img/221833.jpg)

* 后缀表达式中的运算符从左到右的先后顺序和中缀表达式当中运算符的生效次序是相同的

![](/img/2622709.jpg)

![](/img/222752.jpg)

##### 中缀表达式转后缀表达式（机算）

* 后缀表达式没有界限符

* 不带括号的情况

![](/img/4803.jpg)

![](/img/3234442112.gif)

* 带括号的情况
  * 当栈顶是左括号的时候，不需要弹出任何元素，直接把当前的运算符压入栈

![](/img/254545 .gif)

![](/img/032217.jpg)

##### 后缀表达式的计算（手算）

![](/img/1424243243.gif)

![](/img/223240.jpg)

![](/img/223305.jpg)

![](/img/23834.jpg)

##### 后缀表达式的计算（机算）

![](/img/2314.gif)

![](/img/230002.jpg)

* 中缀表达式适合人类运算，后缀表达式适合机器进行运算，因为不用判断运算符的优先级，从左到右直接运算即可

![](/img/230149.jpg)

##### 中缀表达式转前缀表达式（手算）

![](/img/214332222.gif)

![](/img/015322.jpg)

![](/img/015400.jpg)

* 按照右优先规则确定的这些运算符的生效顺序，和我们前缀表达式当中各个运算符从右到左出现的次序是相同的

##### 前缀表达式的计算

* 先出栈的是左操作数，后出栈的是右操作数
  * 和后缀表达式的运算刚好相反
    * 后缀表达式中，先出栈的应该是右操作数，后出栈的是左操作数

![](/img/024339.jpg)

##### 中缀表达式的计算（用栈实现）

```c++
//狗蛋写的
#include <iostream>
#include <cstring>
#include <stack>
#include <vector>
#include <unordered_map>
#include <algorithm>
using namespace std;
stack<int> num;
stack<char> op;
void eval(){
    auto b = num.top();num.pop();
    auto a = num.top();num.pop();
    auto c = op.top();op.pop();
    int x ;
    if(c=='-') x = a-b;
    else if (c=='+')x=a+b;
    else if (c=='*') x =a*b;
    else x = a/b;
    num.push(x);
}

int main(){
    string str;
    cin>>str;
    unordered_map<char,int> pr{{'+',1},{'-',1},{'*',2},{'/',2}};
    for(int i = 0;i<str.size();i++){
        auto c = str[i];
        if(isdigit(c)){
            int x = 0,j=i;
            while(j<str.size()&&isdigit(str[j]))x=x*10+str[j++]-'0';
            num.push(x);
            i=j-1;
        }
        else if(c=='(') op.push(c);
        else if(c==')'){
            while(op.size()&&op.top()!='(') eval();
            op.pop();
        }
        else {
            while(op.size()&&op.top()!='('&&pr[op.top()]>=pr[c])eval();
            op.push(c);
        }
    }
    while(op.size())eval();

    cout<<num.top();
    return 0;

}
```

```c++
//yxc
#include <iostream>
#include <cstring>
#include <algorithm>
#include <stack>
#include <unordered_map>

using namespace std;

stack<int> num;
stack<char> op;

void eval()
{
    auto b = num.top(); num.pop();
    auto a = num.top(); num.pop();
    auto c = op.top(); op.pop();
    int x;
    if (c == '+') x = a + b;
    else if (c == '-') x = a - b;
    else if (c == '*') x = a * b;
    else x = a / b;
    num.push(x);
}

int main()
{
    unordered_map<char, int> pr{{'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}};
    string str;
    cin >> str;
    for (int i = 0; i < str.size(); i ++ )
    {
        auto c = str[i];
        if (isdigit(c))
        {
            int x = 0, j = i;
            while (j < str.size() && isdigit(str[j]))
                x = x * 10 + str[j ++ ] - '0';
            i = j - 1;
            num.push(x);
        }
        else if (c == '(') op.push(c);
        else if (c == ')')
        {
            while (op.top() != '(') eval();
            op.pop();
        }
        else
        {
            while (op.size() && op.top() != '(' && pr[op.top()] >= pr[c]) eval();
            op.push(c);
        }
    }
    while (op.size()) eval();
    cout << num.top() << endl;
    return 0;
}
```

```

```

![](/img/032513.jpg)

![](/img/7032452.jpg)

![](/img/032706.jpg)

* 两者都是从左往右扫描
  * 先弹出的是右操作数，后弹出的是左操作数

![](/img/233333 00_00_17-00_02_02Part001 00_00_00-00_00_30.gif)

![](/img/233333 00_00_17-00_02_02Part002 00_00_00-00_00_30.gif)

![](/img/233333 00_00_17-00_02_02Part003 00_00_00-00_00_30.gif)

![](/img/233333 00_00_17-00_02_02Part004 00_00_00-00_00_30.gif)

#### 3.3.3 栈在递归中的应用

![](/img/053122.jpg)

##### 函数调用背后的过程

![](/img/040036.jpg)

* 在函数里边修改a的值或者b的值，那么它修改的其实是函数中a和b的值，但是main函数里面的a、b这两个变量其实对应的是内存当中的这两份数据，因此在func1里面修改a和b的值，影响不到main函数里面a和b的值

![](/img/52103.jpg)

* 函数执行完之后把它的相关信息弹出栈，释放对应的内存空间

![](/img/052212.jpg)

![](/img/052247.jpg)

##### 栈在递归中的应用

![](/img/52618.jpg)

![](/img/52704.jpg)

![](/img/052738.jpg)

![](/img/52845.jpg)

![](/img/052932.jpg)

![](/img/053016.jpg)

#### 3.3.4 队列的应用

##### 队列应用——树的层次遍历

![](/img/53645.jpg)

* 首先被遍历的是根节点，遍历到1号节点的时候把1号节点的左右孩子塞入队列的队尾

![](/img/053843.jpg)

* 遍历完1号节点之后，就可以出队，从队列中删除1号节点，接下来检查新队头节点即2号节点，同样的把2号节点的左右孩子放入队尾
  * 没有孩子的直接出队

```c++
//yxc
queue<int> q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}
```

##### 队列应用——图的广度优先遍历

![](/img/054434.jpg)

* 遍历1号节点，检查1号节点相邻的其他节点有没有被遍历过，没被遍历过放到队列的队尾，处理完1号结点之后就可以让他，即1号节点出队

![](/img/055017.jpg)

* 接下来处理2号节点，看2号相邻的节点中有没有还没被处理过的节点，把没有处理过的放到队列末尾，然后2号可以出队

![](/img/23455124.jpg)

##### 队列在操作系统中的应用

![](/img/055158.jpg)

![](/img/55608.jpg)

![](/img/055714.jpg)

### 3.4 数组和特殊矩阵

![](/img/055749.jpg)

![](/img/1427.jpg)

![](/img/212221443.jpg)

##### 一维数组的存储结构

![](/img/174645.jpg)

##### 二维数组的存储结构

![](/img/74717.jpg)

* 行优先存储

![](/img/174809.jpg)

* 列优先存储

![](/img/75624.jpg)

##### 普通矩阵的存储

![](/img/180421.jpg)

##### 对称矩阵的压缩存储

![](/img/80520.jpg)

![](/img/0619.jpg)

* 矩阵下标和一维数组下标的映射函数

![](/img/180736.jpg)

![](/img/180851.jpg)

* 如何访问上三角区

![](/img/180941.jpg)

* 万变不离其宗，具体转换只需要看aij对应的是数组中的哪一个元素即可
* 列优先
  * 前面有j-1列，i-j就是该位置前面有多少个元素（按列数），最后加上这个数字本身

![](/img/191407.jpg)

![](/img/93022.jpg)

##### 三角矩阵的压缩存储

![](/img/193049.jpg)

* 按照行优先或者列优先的原则把不是常量的数据都放到一个一维数组里面

![](/img/01621.jpg)

* 行优先下三角

![](/img/201644.jpg)

* 行优先上三角

![](/img/201806.jpg)

![](/img/01828.jpg)

##### 三对角矩阵的压缩存储

![](/img/202006.jpg)

![](/img/03317.jpg)

* j-(i-2)，因为第i行前面有i-2个0

![](/img/204906.jpg)

![](/img/205001.jpg)

##### 稀疏矩阵的压缩存储

###### 顺序存储

![](/img/210903.jpg)

###### 十字链表法

* 绿色数组对应系数矩阵中的各行，橙色数组对应稀疏矩阵的各列，每个非零元素对应一个节点

![](/img/1211.jpg)

## 第四章 串

### 4.1 串的定义和实现

#### 4.1.1 串的定义和基本操作

![](/img/31931.jpg)

![](/img/31000.jpg)

##### 串的定义

![](/img/31004.jpg)

##### 串vs线性表

![](/img/231054.jpg)

![](/img/231131.jpg)

##### 串的基本操作

![](/img/411.jpg)

![](/img/31516.jpg)

##### 字符集编码（ASCII码）

![](/img/1823.jpg)

##### 拓展：乱码问题

![](/img/231902.jpg)

#### 4.1.2 串的存储结构

##### 串的顺序存储

```c++
//静态数组实现
#define maxlen 255//预定义最大串长为255
typedef struct{
	char ch[maxlen];//每个分量存储一个字符
	int length;
}sstring;
//动态数组实现
typedef strct{
    char *ch;//按串长分配存储区，ch指向串的基地址
    int length;//串的长度
}hstring;
hstring s;
s.ch = (char *)malloc(maxlen * sizeof(char));
s.length =0;
```

![](/img/21648.jpg)

![](/img/022333.jpg)

* 方案三的缺点：查询字符串长度的时间复杂度为O(n)
  * 方案二的缺点：字符串长度的范围是8bit即255，比较短
* 方便随机存储，但增删改查不方便

##### 串的链式存储

```c++
typedef struct stringnode{
	char ch;//每个节点存1个字符
    struct stringnode *next;
}stringnode, *string;

typedef struct stringnode{
    char ch[4];//每个节点存多个字符
    struct stringnode *next;
}stringnode, *string;
```

![](/img/8022551.jpg)

* 便于增删改查，但没有随机存储的特性

##### 基本操作的实现

```c++
#typedef maxlen 255//预定义最大串长为255
typedef struct{
    char ch[maxlen];//每个分量存储一个字符
	int length;//串的实际长度
}sstring;
//求子串
bool substring(sstring &sub,sstring s,int pos,int len){
    //字串范围越界
    if(pos+len-1>s.length)
        return false;
    for(int i = pos;i<pos+len;i++)
        sub.ch[i-pos+1]=s.ch[i];
    sub.length =len;
    return true;
}
//比较操作。若S>T，则返回值>0;若S=T，则返回值=0；若S<T，则返回值<0
int strcompare(sstring s,sstring t){
    for(int i = 1;i<=s.length && i<=t.length;i++){
        if(s.ch[i]!=t.ch[i])
            return s.ch[i]-t.ch[i];
}
	//扫描过的所有字符都相同，则长度长的串更大
    return s.length-t.length;
}
//定位操作
int index(sstring s,sstring t){
    itn i=1,n=strlength(s),m=strlength(t);
    sstring sub;//用于暂存字串
    while(i<=n-m+1){
        substring(sub,s,i,m);
        if(strcompare(sub,t)!=0)++i;
        else return i;//返回子串在主串中的位置
    }
    return 0;//S中不存在与T相等的子串
}
```

![](/img/2847.jpg)

![](/img/030350.jpg)

![](/img/30709.jpg)

![](/img/030914.jpg)

### 4.2 串的模式匹配

#### 4.2.1 朴素模式匹配算法

![](/img/000451.jpg)

##### 是什么

![](/img/31144.jpg)

##### 朴素模式匹配算法

![](/img/033021.jpg)

```c++
int index(sstring s,sstring t){
    int i = 1,j=1;
    while(i<=s.length &&j<=t.length){
        if(s.ch[i]==t.ch[j])
            i++,j++;//继续比较后继字符
  		else 
            i=i-j+2,j=1;//指针后退重新开始匹配
    }
    //只有两种情况可能跳出循环：1.i越界，说明遍历了整个主串都没有找到符合条件的子串。2.j越界，说明模式串遍历完毕，在主串中找到了对应的子串
    if(j>t.length)//说明匹配成功
        return i-t.length;
    else //匹配失败
        return 0;
}
```

```c++
//YXC
s[N],p[M];//s是主串，p是模板串

for(int i = 1;i<=n;i++){
//
bool flag = true;

for(int j = 1;j<=m;j++)

if(s[i+j-1]!=p[j]){//因为匹配的时候指向s的也要往后挪动，所以这里的[]内是指s的本轮循环的位置还要往后挪多少位置，最开始的时候是初始位置对比字串，所以挪动的位置为0，此后要-1来保持对准

flag = false;

break;
	}

}
//这里判断的是能否匹配，如果要返回第一次出现的位置，成功后break掉再返回i即可

//完整版
#include <iostream>
#include <cstring>
#include <stdio.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    string a;
    string b;
    getline(cin,a);
    getline(cin,b);
    bool flag=true;
    int N,M;
    N=a.length();
    M=b.length();
    for(int i = 0;i<N;i++){
        flag = true;
        for(int j = 0;j<M;j++){
            if(a[i+j-1]!=b[j]){
               flag = false;
               break;
            }
        }
        if(flag) {
            cout<<i<<endl;
            break;
        }

    }
    if(!flag)cout<<"false"<<endl;
    system("pause");
return 0;


}
```

![](/img/33358.jpg)

![](/img/33453.jpg)

![](/img/033603.jpg)

![](/img/235906.jpg)

![](/img/000322.jpg)

![](/img/000435.jpg)

#### 4.2.2 KMP算法

##### yxc笔记

![](/img/20240324234854.jpg)

存在五个相等的轴，其中：

* 由于第一段第二段在i-j都相等，所以P①=S①，P②=S②
* 由于J+1匹配失败，P字串向后移动直到再次匹配，此时P③=S②，由于S②=P②，所以P②=P③
* 由于P实际上为字串位移，所以P③=P①
* 综上，存在五段相等的轴
* 因此，只需要求子串P中，P①=P②的最大区域，当该区域越大， P再次匹配往后移动的距离越短

因此，对于字串P：

* 需要预处理出以某个点为终点的后缀与前缀相等，相等的长度最大为多少

  ![](/img/20240325000048.jpg)

  ```c++
  Next[i]=j//即从i开始的后缀与从1开始的前缀相等，而且后缀的长度最长
  ```

  

```c++
// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度 s[]要匹配的长串，p[]比较短的模板串
求模式串的Next数组：
for (int i = 2, j = 0; i <= m; i ++ )//扫描p的长度
{
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}

// 匹配O(n)
for (int i = 1, j = 0; i <= n; i ++ )//扫描s的长度
{
    while (j && s[i] != p[j + 1]) //之前没有匹配元素下回溯或者某个元素不匹配
        j = ne[j];//回溯到next数组下标j指向的元素
    if (s[i] == p[j + 1]) j ++ ;//匹配成功，继续往后匹配
    if (j == m)//j=m，说明所有元素都匹配上了，匹配成功
    {
        j = ne[j];//这里是指匹配成功后还有其他要进行的操作
        // 匹配成功后的逻辑
    }
}
```

```c++
//完整
#include<iostream>
using namespace std;
const int N =10010,M=100010;
int n ,m;
char p[N],s[M];
int ne[N];

int main(){
	
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n>>p+1>>m>>s+1;
	//求next数组的过程
	for(int i = 2,j=0;i<=n;i++){
		while(j&&p[i]!=p[j+1]) j = ne[j];
		if(p[i]==p[j+1])j++;
		ne[i] = j;//注意，此处的ne数组已经是优化过的ne数组
	}
	
	
	 
	//kmp匹配过程
	for(int i = 1,j=0;i<=m;i++) //i枚举Si ，j和Si匹配的是P(j+1) ,总往前错一位 
	{
		while(j&&s[i]!=p[j+1])//j没有退回起点，退回起点意味着要重新开始匹配 ;不等意味着那个位置不匹配了 
	    	j = ne[j];//ne[j]是当前j点的最长后缀的长度，j是不匹配后往后移动更新的检验分界点。由于j从0开始，所以当j等于上一个j的ne长度时，相当于j被更新到图示位置 
	    if(s[i]==p[j+1]) j++;//下一个字符终于匹配，继续检验下一个位置的字符是否匹配 
		if(j==n) {
			//匹配成功 
			cout<<i-n<<" ";//输出子串的位置
			j=ne[j];
		}
	}
	
	
} 
```

kmp匹配过程

![](/img/001529.jpg)

求next数组的过程

![](/img/004944.jpg)

完整过程

##### 朴素模式匹配算法优化思路

![](/img/014440.jpg)

![](/img/014524.jpg)

![](/img/014554.jpg)

![](/img/4654.jpg)

![](/img/014722.jpg)

![](/img/014746.jpg)

![](/img/014906.jpg)

![](/img/15003.jpg)

![](/img/15330.jpg)

![](/img/145703.jpg)

![](/img/145745.jpg)

![](/img/45931.jpg)

![](/img/50005.jpg)

![](/img/50038.jpg)

![](/img/50101.jpg)

![](/img/126.jpg)

![](/img/50436.jpg)

![](/img/0608.jpg)

* 找到前缀和后缀相同的子串，然后回溯到前缀的下一个位置

![](/img/151344.jpg)

* next指明了当我们在模板串的第几个元素适配的时候，应该把j的值修改为多少

![](/img/171352.jpg)

##### KMP算法

![](/img/194349.jpg)

![](/img/194410.jpg)

![](/img/195940.jpg)

```c++
//模式匹配部分
int kmp(sstring s,sstring t,int nex[]){
    int i = 1,j=1;
    while(i<=s.length&&j<=t.length){//没有匹配完的时候
        if(j==0||s.ch[i]==t.ch[j]){//匹配成功或者开始匹配的时候，两者往后移
            ++i;
            ++j;//继续比较后继字符
        }
        else 
            j=next[j];//匹配失败，模板串向右移动
    }
    if(j>t.length)
        return i-t.length;//匹配成功
    else 
        return 0;
}
```

###### 朴素模式匹配vsKMP算法

![](/img/038.jpg)

![](/img/200101.jpg)

###### 求模板串的next数组（手算练习）

![](/img/9204157.jpg)

![](/img/204227.jpg)

![](/img/9204250.jpg)

![](/img/4405.jpg)

![](/img/04430.jpg)

![](/img/204450.jpg)

![](/img/04534.jpg)

![](/img/9204555.jpg)

![](/img/205124.jpg)

![](/img/05205.jpg)

![](/img/5452.jpg)

![](/img/205542.jpg)

![](/img/05600.jpg)

###### next数组的优化

![](/img/05858.jpg)

![](/img/210358.jpg)

![](/img/210935.jpg)

![](/img/11009.jpg)

![](/img/11122.jpg)

![](/img/9211155.jpg)

![](/img/211433.jpg)

![](/img/11449.jpg)

![](/img/11556.jpg)

![](/img/11716.jpg)

![](/img/211742.jpg)

![](/img/211758.jpg)

![](/img/11854.jpg)

![](/img/11930.jpg)

![](/img/212022.jpg)

![](/img/212117.jpg)

###### 练习：求nextval数组

![](/img/213824.jpg)

```c++
//求nextval数组
nextval[1]=0;
for(int j = 2;j<=t.length;j++){
    if(t.ch[next[j]]==t.ch[j])
        nextval[j]=nextval[next[j]];
    else
        nextval[j]=next[j];
}
```

###### next和nextval数组的个人总结

* next数组采用求匹配失败的元素的左边起子串的前缀后缀相同的下一个位置
* nextval数组j=1的位置无脑写0，然后后面的进行回溯，如果回溯到不一样的就保持不变，一样的就继续回溯

## 第五章 树与二叉树

### 5.1 树的基本概念

#### 5.1.1 树的定义和基本术语

![](/img/0308.jpg)

##### 树的基本概念

![](/img/225449.jpg)

![](/img/25509.jpg)

![](/img/225556.jpg)

##### 结点、树的属性描述

![](/img/225923.jpg)

![](/img/230009.jpg)

![](/img/230050.jpg)

![](/img/230119.jpg)

![](/img/30203.jpg)

##### 树vs森林

![](/img/230249.jpg)

#### 5.1.2 树的性质

##### 树的常考性质

![](/img/012222.jpg)

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()



### 5.2 二叉树的概念

#### 5.2.1 二叉树的定义和基本术语

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()



#### 5.2.2 二叉树的性质

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()



#### 5.2.3 二叉树的存储结构

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()



### 5.3 二叉树的遍历和线索二叉树

#### 5.3.1 二叉树的先中后序遍历

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()



#### 5.3.2 二叉树的层次遍历

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()



#### 5.3.3 由遍历序列构造二叉树

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()



#### 5.3.4 线索二叉树的概念

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()



#### 5.3.5 二叉树的线索化

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()



#### 5.3.6 在线索二叉树中找前驱后继

![]()

![]()

![]()

![]()

![]()

![]()

![]()

![]()



### 5.4 树、森林

#### 5.4.1 树的存储结构

#### 5.4.2 树和森林的遍历

### 5.5 树与二叉树的应用

#### 5.5.1 哈夫曼树

#### 5.5.2 并查集

#### 5.5.3 并查集的进一步优化