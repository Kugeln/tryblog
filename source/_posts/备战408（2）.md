---
title: 备战408（2）
date: 2024-03-22 19:27:52
tags: 408日常	
sticky: 101
categories: 算法
banner_img: /img/1920x1080.jpg
index_img: /img/1920x1080.jpg
---

# 排序

## 快速排序——分治 O(nlogn)-O(n²)

* 确定分界点：q[l],q[(l+r)/2],q[r];随机
* 调整区间：第一个区间所有的数都小于等于x，第二个区间所有的数都大于等于x
* 递归处理左右两端

快排非稳定，归并稳定（位置不发生变化）

暴力做法

* a[],b[]

* q[l-r] q[i]<=x x->a[]

  ​          q[i]>=x x->b[]

* a[]->q[] b[]->q[]

```c++
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;
int i = l - 1, j = r + 1, x = q[l + r >> 1];
 while (i < j)
   {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
   }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}

```

## 归并排序——分治 O(nlogn)

* 确定分界点：mid=(l+r)/2
* 递归排序left,right
* 归并——合二为一O（n）

```c++
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];

}
```

# 二分

二分不用考虑有没有解

## 整数二分

* 有单调性的题目可以二分，但可以二分不一定有单调性，二分的本质不是单调性
* 二分的本质是性质，使得一部分满足红色性质，一部分满足绿色性质，整个区间可以一分为二，二分可以寻找性质的边界

![](/img/010256.jpg)

①红点

* mid=l+r+1>>1;

  if(check(mid))  true ->[mid,r]  l = mid;//mid满足红色性质

  ​                          false->[l,mid-1]  r = mid-1;//mid不满足红色性质，在绿色性质区域

②绿点

* mid = l+r>>1;

  if(check(mid))  true->[l,mid] r = mid;//mid满足绿色性质

  ​                          false->[mid+1,r] l = mid+1;//mid满足红色性质，不满足绿色性质

```c++
//mid属于绿色区域
bool check(int x) {/* ... */} // 检查x是否满足某种性质
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用，即如果更新方式是r=mid,l=mid+1;
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
```

```c++
//mid属于红色区域
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用,即如果更新方式是l=mid,r=mid-1;
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

## 浮点数二分

注：判断是否满足绿色性质

```c++
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求，比要求的位数多2
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

# 高精度

## 大整数存法

一般从个位开始存，即a[0]为个位数字

```c++

```











## 高精度加法

A、B位数都是10^6

## 高精度减法

A、B位数都是10^6

## 高精度乘法

一般为大整数x小整数，大整数的位数一般是小于10^6，小整数的数值一般小于10^9

## 高精度除法

















# 前缀和与差分

# 双指针算法

# 位运算

# 离散化

# 区间合并

# 链表与邻接表：树与图的存储

# 