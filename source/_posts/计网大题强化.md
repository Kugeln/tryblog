---
title: 计网大题强化
date: 2025-06-24 21:37:22
tags: 408日常
sticky: 272
banner_img: /img/1920x1080 (41).jpg
index_img: /img/1920x1080 (41).jpg
---

* 真题应反复多做，千万别舍不得
* 真题的抹开分数无法代表任何东西，别自负、更别自卑
* 计网真题要分类做，更能感受命题规律
* 计网真题每年只有8道真题、1道大题，全部真题分类二刷一遍，8~10天足矣

## 计算机网络各种协议

![](/img/jisuanjiwangluoxieyi.png)

![](/img/jiwangxieyi.png)

* 数据链路层
  * PPP协议，点对点协议
  * CSMA协议
    * 1-坚持
      * 一直看路，路空就走
    * 非坚持
      *  路没空低头看手机，随机一段时间再抬头看
    * p-坚持
      * 一直看路，路空有概率走也有概率不走
  * CSMA/CD协议，有线局域网
    * 走前先看路，走的时候一直看，要撞了就回去，随机一段时间再出发
  * CSMA/CA协议，无线局域网
    * 走前看路，路空等一段时间还是空就出发，撞了就回退并开始计时，空闲就继续倒计时，倒计时为0重新出发
  * ALOHA协议，随机访问介质访问控制协议/争用型协议
    * 人和车随时可以通行，相撞后等待一段随机的时间进行重传
  * 时隙ALOHA协议，随机访问介质访问控制协议/争用型协议
    * 每个时间段开始的时候人或车才能走，撞了以后等一段时间
  * 网络适配器
    * 实现了物理层和数据链路层的功能
  * 可以把电脑发送的数据转化为以太网帧，再变成比特流发送出去
  * HDLC协议
  
* 网络层
  * IP协议
  * ICMP协议
  * ARP协议
  * RARP（逆地址解析协议）
  * SDN
  * Traceroute/Tracert
  * IGP内部网关协议
    * OSPF，直接用IP数据报
  * IGMP（网际组管理协议），封装在IP数据报中传送

* 传输层
  * TCP协议
  * NAT
  * UDP协议

* 应用层
  * EGP外部网关协议
    * BGP-4，基于TCP
  * RIP
    * 路由信息协议
    * 分布式的基于距离向量的路由选择协议
    * 基于UDP
  * FTP协议
    * 文件传送
    * 基于TCP
  * DHCP协议
    * 基于UDP
    * ip地址分配
  * PING，直接使用网络层的ICMP
  * 移动ip归属代理代理功能的实现
  * DNS
    * 基于UDP
    * 域名解析
  * TFTP
    * 简单文件传送协议
    * 基于UDP
  * SNMP
    * 简单网络管理协议
    * 基于UDP
  * SMTP
    * 简单邮件传送协议
    * 基于TCP
  * TELNET
    * 远程终端协议，远程终端接入
    * 基于TCP
  * HTTP
    * 超文本传送协议
    * 万维网
    * 基于TCP
    * 本身是无连接的，虽然http使用了tcp链接，但通信的双方在交换http报文之前不需要先建立http链接
  * 使用客户/服务器模型
    * Web
    * FTP文件传输协议
    * 远程登录
    * 电子邮件
  * 电子邮件协议
    * SMTP
      * 邮件发送协议
    * POP3
      * 邮件读取协议
      * 基于TCP
    * IMAP

## 概述

![](/img/jhndgbfdv.png)

![](/img/vervrev.png)

* **通常就是选择题第一题 2分**

* OSI参考模型
  * 主考记忆
  * 层次顺序，各层关系
    * 物、链、网、输、会、示、用
  * 各层功能
* TCP/IP模型
  * 各层协议之间的关系

### OSI和TCP/IP模型梳理

* OSI（记忆、各层关系、功能）

  * OSI参考模型中，网络层采用**虚电路**连接

    * 提供可靠有序的虚电路服务，支持无连接和面向链接的通信
      * 虚电路不需要预分配带宽
      * OSI参考模型中路由器的路由表会记录虚电路号(VCID)和下一跳地址
    * 虚电路服务在两台主机开始正式传输之前，需要通过OSI的第三层网络层去建立一个虚电路，这条虚电路会对应一个VCID虚电路号
      * 虚电路在建立的时候需要进行路由选择规划道路，建立后转发路径不发生改变
      * 当左边这台主机发出自己的IP数据报或者说IP分组的时候，只需要指明自己要发的这个IP分组的VCID，即通过哪一条虚电路进行转发
      * 当分组或者数据报经过A主机的时候，A主机这边会记录一个表，表包括VCID和下一跳
        * 不会检查IP数据报里的目的地址，检查的是虚电路号，然后通过虚电路号找到下一跳

    ![](/img/110114.jpg)

    ![](/img/111433.jpg)

    ![](/img/11653.jpg)

    ![](/img/111729.jpg)

  * 设计者认为应该由**网络层提供可靠、有序的传输服务**

  * 会话层和表示层的功能和位置

    * 会话层
      * 会话管理（**断点重传**）
        * 传文件传到一半，断了，重新连接之后可以断点重传
    * 表示层
      * 编码
        * 不同主机上对于各种字符信息的编码显示可能不一样，表示层解决**各个主机编码不一样**的问题
      * 数据格式转换

  * **网络层**实现的是**主机到主机**之间的传输

    * **传输层**实现的是**端到端（进程到进程）**之间的传输
    * **数据链路层**实现的是**相邻结点**之间的传输

* TCP/IP（各种协议之间的关系）

  ![](/img/87i574.png)

  * 数据链路层&物理层协议（网络接口层）
    * 802.3CSMA/CD
      * 以太网
    * 802.11CSMA/CA
      * 无线局域网
    * 802.5令牌传递协议
  * 网络层
    * ARP
      * 需要使用链路层的某一个协议去服务
    * IP
      * 可以使用链路层的某一个协议去服务
        * 当我们说一个协议为另一个协议服务的时候，本质上是我们再强调**这个协议的服务数据单元（SDU）携带的是被服务协议的协议数据单元（PDU）**
  * 传输层
    * TCP
      * 使用IP协议
    * UDP
      * 使用IP协议
      * **无连接服务**
  * 应用层
    * SMTP/POP3（电子邮件）
      * 使用TCP
    * HTTP（浏览网页）
      * 使用TCP
    * DNS
      * 使用UDP
    * DHCP（动态主机配置获得IP地址）
      * 使用UDP
    * FTP（文件传输）
      * 使用TCP

## 物理层

![](/img/,umjhngfd.png)

![](/img/bu564v534cx3.png)

* 选择题

* **模拟信号**

  * **调制**

    ![](/img/647nb3.png)

    ![](/img/56b4v.png)

    * ASK
      * 调幅AM
      * 幅度
      * 4种幅度可以表示2bit
    * FSK
      * 调频FM
      * 频率
      * 8种振幅意味着3bit
    * PSK
      * 调相PM
      * 相位
      * 8种相位意味着4bit
    * QMA
      * 正交幅度调制
      * QAM-16意味着总共有16种信号，4bit

  * 香农

    * **有噪声信道**上，极限**比特率**（数据传输速率）=Wlog2（1+S/N)   b/s
      * W是带宽（单位为hz）
      * S是信道内所传输信号的平均功率
      * N为信道内的高斯噪声功率
      * S/N为信噪比，无单位记法时信噪比=S/N，采用分贝记忆法时，信噪比=10log10（S/N）

  * 奈氏

    * **无噪声信道**上，极限**波特率**=2W（以**Hz**为单位的**带宽**）
    * 极限**数据传输速率（比特率）**=2Wlog2V b/s（V是一个码元的离散电平数量）

  * 码元、bit的关系

    * **每个周期的信号对应一种码元，而一个码元能携带多少个bit就得看一个周期内的信号有多少种**

  * 波特率

    * 每秒传输的**码元数**

  * 比特率

    * 每秒传输的**bit数**

* **数字信号** 波形

  * **编码**

  ![](/img/7n46b.png)

  ![](/img/68m57.png)

  ![](/img/9m789n.png)

## 数据链路层

![](/img/98kujrytb.png)

* 选择题

  * **CSMA/CA**

    ![](/img/7n85.png)

    * 画图（预约信道）

    ![](/img/ury.png)

    ![](/img/wevr.png)

    * 三个地址

    ![](/img/Q232C2.png)

    ![](/img/buzhidaoweishenme.jpg)

    * **无线**通信当中，**无线局域网**使用
      * 手机和路由器

  * **CSMA/CD**

    * **以太网**（**最短帧长**）

    * **冲突检测（边发边检；冲突停发）**

      ![](/img/h4q.png)

      * 节点间的最长距离（距离是题目变量）
        * ①计算出最短的帧的发送时间
        * ②根据**最短帧发送时间大于等于两倍单向传播时间**
        * ③结合信号在信道上的**传播速度**，计算出信道的最长距离等于多少
      * 距离固定，冲突检测的**最短**或者**最长**时间
        * 最短帧长和传输速率，就可以计算出发出一个最短的帧需要多长时间
        * **发出一个帧最短所需要的时间不能小于二倍的单向传播时延**
        * 计算出上述条件之后，再结合信号的传播时间、信号的传播速度，就可以得知节点之间的**最长的距离**等于多少

* 大题：通常结合高层协议考察

  * 链路层MAC帧通常会和高层协议结合起来考察（**如何封装成帧**）

  * ARP

    ![](/img/twrh.png)

    ![](/img/qcewcew.png)

    * 要能从空ARP表开始分析
    * **广播找人，单播回应**
    * 网络层协议，定义了ARP分组，和IP分组是两个独立的东西，是单独的数据结构
    * 会被封装到链路层MAC帧里面，最终要实现地址解析，要通过几个ARP分组的传输，找到一个IP地址对应的MAC地址等于多少
    * 如果一台主机要发送一个IP分组给另一台主机，但是**另一台主机刚好与自己从属于从一个局域网**，这种情况下**需要把IP分组封装成一个MAC帧**。MAC帧当中应该直接指明与我从属于同一个局域网的那个目的主机，它的MAC地址等于多少
    * 如果一台主机要发送的目的主机并不在本网络内，那么此时发送方得把这个IP数据报发送给**默认网关**，默认网关也有一个MAC地址，所以这个IP数据报发送给默认网关的时候，也需要把**目的MAC地址填写为默认网关的MAC地址**
    * 也就是说，当我构造一个IP数据报的时候，一旦确定了目的IP地址，那么如果**目的IP地址直接就是和我在同一个网络**，那就需要**用ARP协议查到目的IP地址对应的MAC地址** 
    * 运行只需要发出一个ARP分组（请求），被查询的一方回复一个ARP响应分组,ARP协议的工作就完成了
    * 每一台主机内部都有一张ARP表，记录了**自己已经查询到的IP地址和MAC地址之间的映射关系**
    * ARP分组里面必须指明**想要找的主机的IP地址，我的IP地址，我的MAC地址**，之后**MAC帧的目的地址全1（广播）**
    * 想要找的主机收到ARP请求分组之后，会构造一个ARP相应分组返回给“我“
      * 内容包括**被查询主机的MAC地址和IP地址**
      * 不需要广播，直接单播
    * 收到ARP响应分组之后，会把收到的**IP地址和MAC地址之间的映射关系**记录到ARP表中

  * IP

    ![](/img/y4n.png)

    ![](/img/5vc3.png)

    ![](/img/n5nb6b.png)

    ![](/img/675b5v4.png)

    ![](/img/trvev.png)

    * 太长

      * 分片问题

        * 最长1500B（MTU最大传输单元）
        * 418首总偏
          * 偏移量表示的是每个IP数据包当中，它携带的数据**在原始IP数据报当中的位置**
          * **偏移量必须是8字节的整数倍，最后一个分片除外**
        * 每一个分片都有自己的IP首部，而首部当中都包含418首总偏这几个字段
        * 还有MF（是否还有其他分片）DF（是否允许分片）
          * 如果链路层无力承担大的IP数据报，但是原IP数据报的DF又=1，此时只能把IP数据报丢掉，再通过一个ICMP报文告诉发送IP数据报的源节点，IP数据报已经被丢掉，发生了异常
            * ICMP协议本质就是网络当中的异常通知机制

      * 例子

        ![](/img/61259.jpg)

        * 假设IP数据报首部20B，数据2000B，假设其链路层的MTU=800
          * DF字段的值取决于源IP数据报
          * 第一个分片
            * MF=1，DF=0
            * 首部20B，总长度796B，偏移量0
          * 第二个分片
            * MF=1，DF=0
            * 首部20B，总长度796B，偏移量97
          * 第二个分片
            * MF=0，DF=0
            * 首部20B，总长度468B，偏移量194

    * 太短

      * 填充问题
      * 不能小于46字节
      * 路由器收到IP数据包的时候如何区分这个IP数据报真实的数据是多少？
        * 418首（首部长度）总（总长度）偏（偏移量）

    * **如何判断太长还是太短**

      * 418首总偏，去看总长度，找到每个IP数据报的总长度，然后看看实际总长度是否小于46，或者是否大于下一段链路的MTU

    * 路由器转发后帧的地址变换

  * DHCP（**参考海投简历找工作流程**）

    ![](/img/uytres.png)

    ![](/img/0888io.png)
  
    ![](/img/wxewxww.png)
  
    * 要能分析DHCP全过程，**每个报文被如何封装**
    * **四个DHCP报文的目的MAC地址和源MAC地址如何配置**
      * 假设H3新加入网络
        * ①刚接入网络的时候，没有被分配IP地址，需要跟**本网络的DHCP服务器**发生通信，请求DHCP服务器给自己分配一个**IP地址及配置默认网关、配置子网掩码**
          * H3天生携带的只有**MAC地址**
        * ②涉及四个报文
          * **第一**个报文**发现报文**
            * 说明自己的**MAC地址**
            * 在链路层会被封装成**MAC帧**
              * **目的MAC地址**是**广播地址**，**48bit全1**
                * 因为h3刚加入网络不知道DHCP服务器的MAC地址是多少
                * 因此DHCP发现报文**会被整个网络内所有的节点收到，但是应用层只有DHCP服务器接收**
              * **源MAC地址**是自己的MAC地址
          * **第二**个报文**提供报文**
            * 提供**IP地址、子网掩码、默认网关**
            * **单播帧**
              * **目的MAC**是**新加入的主机MAC地址**
              * **源MAC**是**DHCP服务器的MAC地址**
          * **第三**个报文**请求报文**
            * 在一个局域网内部可能会有很多台DHCP服务器
              * 也就是说H3发出第一个DHCP发现报文的时候，网络内所有的DHCP服务器都会收到，每一台都会以为这个节点在跟自己索要IP地址。
              * 因此H3可能被多个DHCP服务器分配IP地址
              * 因此H3需要发送请求报文向**网络内所有DHCP服务器告知自己的IP地址是哪个DHCP服务器分配的**
              * 因此请求报文的**目的MAC是广播地址**
            * **广播帧**
          * **第四**个报文**确认报文**
            * 确认H3的IP地址是该DHCP服务器分配的
            * **单播帧**
    * **IP地址如何分配**
      * ①**发现报文**
        * 刚开始没有IP地址，因此**源IP地址全0**
        * 刚加入不知道DHCP服务器的IP地址，**目的IP地址为广播地址，全1**
      * ②**提供报文**
        * **目的IP地址广播地址**，因为H3目前还没有IP地址，为了**防止H3的网络层过滤掉这个IP数据报**，应该用广播IP去告诉H3应该接收
          * 因为每台主机的网络层都会检查目的IP地址是多少，如果**目的IP地址和自己的IP地址相同或者是广播地址**，这些主机才会接收这个IP数据报
        * **源IP地址是DHCP服务器自己的**
      * ③**请求报文**
        * 因为尚未确定IP地址，所以**源IP地址依旧是全0**
        * 因为有多个DHCP服务器，H3要告诉所有分配IP的DHCP服务器，最终自己接收了哪个DHCP服务器发来的IP地址，因此**目的IP是广播IP**，以防DHCP服务器的网络层把这个IP数据报过滤掉
      * ④**确认报文**
        * H3还没有真正确定自己的IP地址，因此**目的IP地址仍然是广播IP**，这样才能确保H3的网络层不要把这个IP数据报过滤掉

## 网络层

![](/img/6em6.png)

### 子网划分

![](/img/675b5v4.png)

* ①观察可以自由分配的位数有多少个
  * x.x.x.x/n **32-n bit可以自由分配**
* ②题目的条件
  * 分多少个子网、各子网大小（主机数）
    * **如果希望子网尽可能小，那么子网的叶子节点尽可能深**
    * **如果希望子网尽可能大，那么子网的叶子节点尽可能浅**
    * **如果想要定长子网（大小相等），那么就是要构造一颗满哈夫曼树**

![](/img/trvev.png)

* **主机中子网掩码的作用：①发送IP数据报的时候，判断本主机和目的主机是否在同一个网络**
  * 如果是，通过ARP协议获得MAC地址，然后直接封装成帧发送
  * 如果不是，通过ARP协议获得路由器默认网关的MAC地址，然后将IP数据报封装成帧发给路由器
* **路由器中子网掩码的作用：①用IP数据报的目的IP地址去对比路由转发表中的表项，根据子网掩码按位与**
* **路由器和路由器之间获取MAC地址采用的也是ARP协议**
* **ARP是有缓存的ARP表的，最近一段时间查的IP地址和MAC地址映射关系会被记录在表中**
  * 因此第二次发送的时候不用重复ARP过程
  * 发送请求分组和发送响应分组的，两者的ARP表都会把**对方记录在ARP表中**
* **子网掩码配置不当**，可能导致**判断是否属于同一个网络出错**，导致IP数据报发送到默认网关，**默认网关收到IP数据报后，发现转发接口和来源接口相同，会直接丢弃IP数据报**，因此IP数据报无法被同一个网络的对方接收
* **默认网关配置错误**，当要给另一个网络的主机发送IP数据报的时候，会发送到非默认网关的IP地址，假如该IP地址有效，该主机检查IP目的地址不匹配，会**直接丢弃该IP数据报**
* 综上，**子网掩码配置错误，同一子网内的通信出错；默认网关配置错误，不同子网内的通信出错**
* **从属于同一个子网的主机的子网掩码位数相同**

### 例子

![](/img/avwevr.png)

#### H3发送给H6

* ①H3**用子网掩码和目的IP地址逐位与，提取出目的IP地址的网络前缀**，判断自己和H6是否处于同一个网络
  * 如果目的IP地址的网络前缀和自己的网络前缀匹配，说明两者从属于同一个网络
  * 如果不匹配，说明目的IP地址不在同网络内
  * **当我在判断是否和对方处于一个网络的时候，不需要知道对方的子网掩码**
    * 这些都是配置在主机内部的，唯我独有，我只知道自己的子网掩码配置
* ②H3发现自己和H6是同一个网络，不同发送给默认网关，**把IP数据报封装成MAC帧**
  * 目的MAC地址通过ARP协议获得
    * H3发送一个ARP请求分组（广播帧）
      * 其他所有主机都收到，只有H6回复
    * H6发送一个ARP响应分组（单播帧）
* ③MAC帧在局域网内传递，会被H5和H6收到（因此**集线器无脑转发MAC帧**），但是H5**检测到目的MAC地址和自己的MAC地址不匹配会直接丢弃**，最终只有H6接收MAC帧
  * **在用ARP协议获取MAC地址的时候，有一个广播帧和单播帧，但是当发送IP数据报的时候，是一个单播帧**
* 假设H3连接的交换器里面是一个空交换表，**空交换表在此过程中会如何变化？**
  * H3发送ARP请求分组（广播帧）给交换机，交换机又**把广播帧交给所有与之相连的节点**
    * 所以所有其他节点都会受到这个封装着ARP分组的广播帧
  * ①收到ARP请求分组（广播帧）的时候，**空交换表中会增加H3的MAC地址，以及对应接口**
  * H6发送ARP响应分组（单播），交换机收到ARP响应分组后，检查单播帧的目的地址是H3，而H3MAC地址及其对应接口刚刚被记录在了交换表中，因此ARP响应分组能够精准转发给H3
  * ②由于单播帧中指明了源MAC地址即H6的MAC地址，交换机也会记录H6的MAC地址及对应接口 
* **如果不是局域网，ARP协议如何操作？**
  * **ARP仅在同一局域网内有效，从属于不同局域网的节点，查不到也没必要查其MAC地址**
* **每经过一个路由器，MAC地址都会改变**

#### H3发给H7

* ①H3**用子网掩码和目的IP地址逐位与，提取出目的IP地址的网络前缀**，判断自己和H7是否处于同一个网络
* ②不是同一个网络，H3应该把IP数据报封装成帧发送给默认网关（DHCP协议配置）
* ③通过ARP协议获得默认网关的MAC地址
  * 由于交换机的交换表中已经有H3和H6，所以交换表在发送ARP请求分组的时候不会发生变化。但是在默认网关发出ARP响应分组的时候，**交换表会记录下B2的MAC地址和对应接口**
* ④H3将MAC帧发给交换机，交换机发给B2路由器默认网关
* ⑤路由器拆帧，检查IP数据报的目的IP，查路由表从B0转发出去
  * 路由表有子网掩码，查表的时候也需要逐位与检查和哪一个表项匹配
  * **目的MAC地址变成下一个接收MAC帧的网卡/接口的地址**（本图中C0），**源MAC地址写成自己发出去的接口（本图中B0）**
* ⑥某公司路由器接收到MAC帧，拆出IP数据报，检查目的IP，查路由转发表，找到对应接口转发出去
* ⑦目前某公司路由器只知道目的IP地址，但不知道对应的主机MAC地址，通过ARP协议获得目的主机的MAC地址，然后单播发送，H7收到IP数据报
  * 路由器发送一个ARP请求分组（广播帧）
  * 交换机假如空表，则加入路由器C2接口对应的MAC地址及其接口
  * H7发送ARP响应分组（单播），交换机的交换表中加入H7的MAC地址及其接口

### 普通路由器和NAT路由器的工作原理

![](/img/xwqxq.png)

* 假如两各路由器之间的链路，一端配备了IP地址，我们就可以从左边的IP地址去推测右边的IP地址等于多少 
  * **一条点对点链路通常是30位子网掩码，两个路由器之间构成最小子网就是点对点链路，子网内只有两台主机**

#### 例

![](/img/wefawaf.png)

![](/img/eafeawf.png)

![](/img/wxea.png)

![](/img/wq2.png)

![](/img/weqxcc.png)

![](/img/c32q.png)

![](/img/3c21332z.png)

![](/img/x321rc23.png)

![](/img/v3rgr2g.png)

![](/img/2c3c1r2.png)

* 静态IP地址配置就是非DHCP配置
* Web服务器默认80端口
* NAT路由器对外填的IP地址是公网IP
* **外网端口号配置错误**，会导致**访问出错**
* **80端口几乎是所有网站对外暴露的一个端口**
* 假如H1发出了一个TCP握手①报文段，然后这个TCP握手①当中，会默认指明要建立连接的端口号是80端口，而要访问的WEB服务器IP是公网IP，如果说这个NAT路由器对外暴露端口是90，那么**这台NAT路由器收到TCP握手请求的时候，会映射失败**，因为表中只有90，而TCP里面是80，因此**IP数据报不会转发进内网**
* **既然内外网端口号可能不一样，那么假如h2主机上的微信想要和h1主机上的微信通信，h2怎么知道端口号的？**
  * h2和h1打开为新进程的时候会向腾讯服务器上报ip地址和自己的微信端口号，NAT路由器在收到这个IP数据报之后，会把端口号和IP地址修改成NAT对外网映射的IP地址和端口号
  * **腾讯服务器收到的报告的IP数据报是NAT映射的对外网IP地址和端口号**
  * h2在发送前会先向腾讯服务器询问，想要联络的人的微信ID，通讯地址，端口号，然后h2在建立连接的时候就可以用公网IP和公网端口号去建立连接了
* **如果不是熟知端口号，内外的端口号可以不一样，熟知端口的内外端口号一般保持一致**
  * **Web服务器一般80端口**
    * 如果一台主机想要访问某个网站，只要用DNS把网址转换为IP地址，再结合80端口就可以和这个网站服务器建立TCP连接
* **熟知端口不用经过查询端口的步骤就可以建立TCP连接，而非数值端口，需要有中间步骤，向一个中间服务器查询IP地址的端口号，才可以建立连接**

### 路由聚合

路由聚合分析过程：

* ①无脑配表（大）
* ②检查同一个出口的IP地址能不能聚合

### IP协议+应用层（HTTP、DNS协议）

* HTTP的作用：打开网页
  
  * **握手③携带HTTP请求报文**
* DNS的作用：打开网页的第一步，把域名（网址）翻译成IP地址

* **递归查询和迭代查询**

  * 递归是其他人代跑腿最终返回结果

  * 迭代是自己去跑腿查结果

* **本地域名服务器递归，其他迭代**

  ![](/img/hteah.png)

* **本地域名和其他服务器均迭代**

  ![](/img/wegggg.png)

* **本地递归，根域名迭代，顶级域名递归，权限域名迭代**

  ![](/img/dsavva.png)

* **访问一个网站的过程**
  
  * ①把域名转换成IP地址（DNS查询）
* **一台主机如何知道DNS服务器的地址等于多少**
  
  * DHCP配置IP地址、子网掩码、默认网关以外还会配置默认DNS

### 路由选择算法（路由算法）与路由选择协议（路由协议）

![](/img/mV43.png)

* 路由协议和路由算法之间的关系：**某一种路由协议的实现基于某一种路由算法**
*  **RIP**基于**距离-向量路由算法**
* **OSPF**基于**链路状态路由算法**
* **BPG**基于**路径向量路由算法**
* 路由选择的目的：**确定转发路径**，当收到一个IP分组的时候，这个IP分组应该从哪条路径转发出去
* **BGP协议封装在TCP报文段，再封装IP数据报里面，OSPF直接封装到IP数据报里面，RIP先封装在UDP报文段，再封装到IP数据报里面**

#### 例子

![](/img/WQEV.png)

* A、B、C、D、E、F是外联部，网络是社团，人在网络中对应主机
* 假如a这个社团的某一个人，想要联系d社团的另一个人，他不知道怎么找人，可能的方法就是拜托外联部A去传递消息
  * 人把消息交给外联部，外联部也不直接认识D社团的人，但可以拜托B或者E外联部转交消息

#### 距离向量路由算法

![](/img/05210.jpg)

#### RIP路由协议（自治系统内部）

* 把**路由器跳数**视为距离
  * 路由器直达网络，距离为1
  * 每多经过一个路由器，距离+1
  * **距离=16时，表示不可达**
    * 只支持比较小的网络
* 原理：**Bellman-Ford算法**
* 工作过程：
  * 每个路由器仅告诉邻居**距离向量（到达目的网络的最短距离）**
    * **仅告诉邻居**
  * 告诉邻居们，从本路由器到达每个目的网络的距离
  * 自治系统刚启动时：**定期交换**
  * 收敛后：**定期交换**+距离向量**有更新就交换**
* RIP算法的特点
  * **好消息传递快，坏消息传递慢**

##### 习题带练RIP

###### 1

![](/img/c432.png)

![](/img/I8KO679.png)

###### 2

![](/img/3V4B.png)

![](/img/96M.png)

###### 3

![](/img/290234C0.png)

![](/img/hg4f3.png)

* 路由器会把邻居们发给他的最新的距离向量保存在本地，除非某个节点再次更新了自己的距离向量

![](/img/56h456h.png)

* 假如R1不存在，那么R2更新后，到达该网络的距离是什么？
  * R3更新前，缓存了R2的距离向量<N,2>，因此当R3和201.1.2.0断掉之后，会从R2走，于是距离向量更新成<N,3>
  * 该距离向量被发给R2，R2本身是以R3为下一跳到的201.1.2.0，因此R2的距离向量会被更新为<N,4>
* 注意：向邻居节点发送的是**距离向量**，即**<网络，距离>**，不包括下一跳，因此邻居不知道距离对应的下一跳是不是自己

##### 例：RIP路由选择协议如何构建路由表

![](/img/WQEREWBT.png)

* RIP路由协议规则：
  * 直连网络距离为1，每经过一个路由器距离+1
  * 相邻的邻居节点之间会定期交换
  
* RIP情况下我们认为图是无向图，边权值为1

* 假设：
  
  * 0s的时候每台路由器启动，每隔30s交换一次距离向量
    * 有点像图的广度优先遍历
  
* 工作过程
  * 0s各台所有的路由器，整个网络一起启动

    ![](/img/C34Q.png)

    ![](/img/34TB.png)

    * R1路由器在0这个时候，会去探测与自己直连的网络有哪几个
      * R1探测后发现目前与自己直连的网络只有192.1.1.0/24，知道自己与N1网络的距离为1
        * 某个网络可以用网络前缀，去表示这个网络的网络号
        * 在算法运行的过程当中，**表示一个网络是用网络前缀（CIDR记法）**
      * 因此R1路由的距离向量，只有一个分量<N1,1>。
      * 同理R2的距离分量<N2,1>,R3的距离分量<N3,1>，R4的距离分量<R4,1>
    * 与此同时，0s时，每一台路由器，会紧接着告诉自己的邻居，“我”可以直达的网络是哪一个，到这个网络的代价是多少
      * 比如R1告诉R2和R3，它到N1的距离=1
      * R2和R3收到R1发来的消息之后，就会修改自己的距离向量，加入到N1的距离向量
      * 除此之外，R2和R3还会记录下来自己到N1的最佳路径的下一跳是R1
    * **总结**：**0s时**
      * ①先探测自己直连的网络，得到自己的距离向量
      * ②通知邻居，告诉邻居自己的距离向量
      * 每一个路由器都在**向自己的邻居同步自己掌握的信息**，各个路由器在收到自己邻居发来的这个新的路径信息后，就及时地去**更新自己的路由表**

  * 1s时的路由表状态（黑字部分）

    ![](/img/V43QB.png)

  * 30s（交换路由向量的时候）

    ![](/img/V43QB.png)

    * **RIP协议收敛：往后各个路由器的路由表表项不会再改变**

  * 有更新就交换

    ![](/img/ES4BB3.png)

#### OSPF算法（自治系统内部）

* 核心原理：
  * 带权无向图
    * 邻接表存储
      * 方便维护
  * djkstra算法
  * 每台路由器都要构造**整个自治系统的网络拓扑结构**。路由器、某个网络作为图的“顶点”
* 重点
  * **距离可以由网络管理员自己定义**
    * 如：以链路TTL作为距离
  * 按照dijkstra算法求最短路径
    * 不断加入距离最近的顶点更新距离
* 工作过程
  * 每个路由器告诉**自治系统内的所有路由器**“自己的相邻有哪些”
  * **洪泛法，通知所有人**
    * 如果一个节点更新，那么它和各条边的信息首先会发送给和它直接相连的节点
    * 它的邻居会把该节点发过来的OSPF链路更新报文发给其他相邻节点，重复收到的不转发
  * **新节点刚加入**时：**找邻居抄作业**
    * 让邻居把完整的邻接表转发给自己，然后加入自己的情况，构造自己的邻接表
  * **收敛后**：**定期交换+相邻结点、路径信息有变化时**

##### 习题带练

###### 1

![](/img/43g57h3h.png)

![](/img/1f15g1.png)

![](/img/453f4yffef.png)

* 路由器刚加入网络的时候，把和自己直连的边的信息全网广播，告诉给网络上的每一个路由器

#### 边界网关协议BGP（自治系统外）

* 自治系统

![](/img/C3H34.png)

* BGP解决的是边缘路由器之间IP数据报分组转发的路径选择问题
* RIP和OSPF解决的是一个小范围的自治系统内部的IP数据报转发问题
* 工作过程：
  * 每个边界路由器知道自己能够到达的自治系统内部的网络，然后告诉和自己相关联的路由器，哪些网络可以经过它到达。
  * 逐个传播，最后整个互联网都知道各个自治系统包含了哪些网络，以及要到达这个网络下一跳应该找哪个边界路由器
* BGP协议的会话有两类
  * EBGP（外）
    * 两个边界路由器之间交换信息
  * IBGP（内）
    * 给内部路由器通知到达外部某些网络怎么走
* AS跳数最短优先
  * AS跳数一致，采用**热土豆算法**
    * 看谁能够最快把IP数据报发到自治系统之外，也就是内部算法得出的最近的路由器

##### 习题带练

###### 1

![](/img/H4Y6JJ.png)

![](/img/V677B.png)

###### 2

![](/img/4B76K.png)

![](/img/4VB74B.png)

![](/img/5V46GUBHG.png)

![](/img/53V3.png)

## 传输层

### 校验

![](/img/90awjelkcj.png)

* IP数据报仅校验首部，因为IP数据报的数据部分为UDP/TCP报文段，所以IP数据报数据部分的校验由传输层来进行
* 因此**路由器只保证IP数据报首部在转发过程中没有错误，IP数据报的数据部分由主机来进行保证**
* **只要首部有字段发生改变，首部校验和就跌重新算**
* UDP和TCP都是对整体（**首部+数据**进行校验）

#### UDP校验

![](/img/222906.jpg)

![](/img/g998.png)

![](/img/89f687iu.png)

![](/img/876876g87.png)

![](/img/g687g678.png)

![](/img/09j09709.png)

### 拥塞控制

![](/img/90awjelkcj.png)

* 拥塞控制中，**无论是拥塞窗口还是阈值还是发送窗口的大小，都是以MSS的倍数作为单位的**
* **套路**
  * **①**写MSS（最大报文段长度），写RTT（往返时间），接收缓存
    * 接收缓存和接收窗口的大小关系
      * 接收缓存大于等于接收窗口，接收缓存剩余多少量会影响接收窗口的大小
      * eg：接收缓存5KB，对面已经发了2KB，我接收了但是还没有交给应用层，那么我还能接收的量只剩下3KB，多了会数据溢出
    * 接收缓存什么时候被清空
      * 取决于操作系统和应用程序的配合
        * 数据在操作系统内核区，接收缓存当中收到这个数据，相当于数据只是到达了传输层，还得复制给应用层的某个进程
        * 如果操作系统想要清空接收缓存的数据，会把2KB的数据从传输层接收缓冲区复制到应用层那边定义的数组里面
        * **本质是OS内核区数据复制到应用程序的用户区**
      * 一般题目给出
      * 如果题目中**没有给接收缓存大小**，可以认为是无穷大的，这种情况下，**发送窗口的大小只会受到拥塞窗口大小的影响**
  * **②**从0时刻开始，以RTT为单位，写：阈、拥、收、发是多少
    * 阈值
      * =发生拥塞时的拥塞窗口大小/2
    * 拥塞窗口
      * 发生拥塞后开始慢重传，拥塞窗口变为1
      * 阈值前，过一个RTT翻倍一次
      * 阈值后，过一个RTT增加1
      * **拥塞窗口翻倍的底层原理是每收到一个ACK就+1，也就是这轮RTT中收到了多少个ACK，然后基于原本的拥塞窗口进行调整（前提是没有到阈值）**
        * 比如说只发了29MSS的数据，那么只会收到29ACK，拥塞窗口只+29
    * 接收窗口
      * **当前可以接收的还有多少**
    * 发送窗口：动态变化
      * 取决于**拥塞窗口和接收窗口当中更小的值**
      * 发送窗口的意思是**下一次最多能发多少**
* **发送窗口不能超过拥塞窗口也不能超过接收窗口，但是拥塞窗口和发送窗口以及接收窗口没有直接联系**

#### 例

##### 1

![](/img/04._40.jpg)

![](/img/04_43.jpg)

![](/img/04._51.jpg)

![](/img/0456.jpg)

![](/img/04._63.jpg)

* 在缓冲区满了又清空之后，会给发送方一个ACK，这个ACK会告诉发送方接收缓冲区又恢复到60KB了

### TCP

#### TCP建立和释放

![](/img/C2135V12.png)

* **TCP建立阶段**
  * 握手①和握手②的特点：**SYN=1，且不带数据，消耗一个序号**
  * 握手③的特点：**SYN=0，可以携带数据，有多少B消耗几个序号**
  * 握手①**ACK=0**，握手②握手③**ACK=1**
  * **整个TCP的全过程只有握手①的ACK=0**
  * 服务器和客户消耗的序号是**各自的序号，只消耗自己的**

* **TCP释放阶段**：
  * 挥手①和挥手③**FIN=1，消耗1个序号**，挥手②和挥手④**FIN=0**
* 哪些完成了TCP建立的过程，可以根据**SYN**进行判断
  * **SYN=1的两个TCP报文段对应的就是握手①和握手②，SYN=0的TCP报文段对应的就是握手③**

* **如何判断S（服务器）收到C（客户）的多少数据**
  * 需要关注：
    * ①客户端给服务器发的**初始序号**等于多少
      * **握手①的初始序号再+1才是数据的初始序号**
        * 除了握手①以外，其他每一个TCP报文段中的ack都是有效的
    * ②需要关注服务器给客户端发回来的**最后一个ack确认号等于多少**
    * ③ack-数据初始序号

![](/img/231C5V231.png)

![](/img/04.95.jpg)

* IP数据报转发的过程当中，**首部可能发生改变，但是TCP报文段不会发生改变**
  * **但是NAT路由器在转发分组的时候，目的IP和源IP以及目的端口号和源端口号会发生更改，校验和也会更改，因此TCP报文段就会发生改变**
  * **IP数据报的标识也不会变**

#### TCP+HTTP

* 网页的构成
  * ①浏览器获取HTML文件
  * ②解析HTML文件，从HTML文件里面去找所引用的其他文件的存储路径
    * 如果想要引用其他网站的某一张图片，可以用URL的方式告诉浏览器
  * ③根据路径找到文件，本地或者继续向服务器请求
* 需要关注**题目给出的条件**
  * ①是否是**持续链接**
    * 在所有文件获取之前，TCP连接会不会被断掉
  * ②是否采用**流水线**

##### 持续连接非流水线

![](/img/X1235V32V.png)

* HTTP请求：告诉网站我希望请求获得你的哪一个网页
* **浏览器在收到HTML文件之后才能知道还要请求哪些文件**
* 非流水线的情况下，每个文件都需要一次HTTP请求
  * **握手①握手②对应1RTT，握手③+HTTP请求和HTTP响应报文（携带HTML文件）对应1RTT**
  * 剩下的**每次HTTP请求和HTTP响应对应1RTT**

##### 持续连接流水线

![](/img/321V5V12.png)

* 浏览器连续发出N个HTTP请求，网站连续发出N个HTTP响应
* 上述过程花费1个RTT
* 因此采用持续流水线的情况下
  * 获取网站所需图片至少花费**1RTT**
  * 从发出HTTP请求到获得全部网站资源至少花费**2RTT**
  * 从建立TCP连接到获取全部网站资源至少花费**3RTT**

##### 非持续串行TCP请求

![](/img/C413V.png)

* 非持续连接意味着，每建立好一次TCP连接，只用这个TCP连接请求一个文件。这个文件获得之后，就会立即释放前面的TCP连接，如果**要请求下一个文件，就需要建立新的TCP连接**。
  * 每个文件的请求都需要**2RTT**

##### 非持续并行TCP请求

![](/img/AWZV531.png)

* 非持续意味着**每个文件的请求都需要额外的单独建立一次TCP**
* 并行TCP请求意味着，并行地建立N个TCP连接（同时）
* 也就是说获得N个文件的花费时间是：
  * 从**握手**到**获得HTML文件**需要**2RTT**
  * 从**握手**到**获得N个文件**需要**4RTT**
  * 从**获得HTML文件**到**获得N个文件**需要**2RTT**
  * 从**发出HTML请求**到**获得N个文件**需要**3RTT**

##### HTTP大文件传输

* **小文件不考虑传输时延，大文件需要考虑传输时延**
* **传播时延是RTT不会因为文件大小而改变**，但是**传输时延会因为文件大小改变**
  * HTTP请求报文和HTTP文件一般很小，是小文件
* **传输时延=文件大小/带宽**

![](/img/5B24V2.png)

###### 例

![](/img/04._140.jpg)

![](/img/04._144.jpg)

![](/img/V12351.png)

* **每收到一个ack，接收窗口的大小就会减少（-1* MSS)，拥塞窗口的大小就会增加(+1*MSS)**

* 下一个要发送=初是序号+已发送的数据量

![](/img/V1235.png)

* 最快的挥手情况：
  * 客户发出挥手①，服务器没有更多数据要发给客户了，挥手②和挥手③前后脚接连发出，**客户端返回挥手④，此时服务器断开连接**，客户端在发出挥手④后，**再等待2MSL，客户断开连接**

## 王道基础课物理层内容

### 电路交换、报文交换、分组交换

![](/img/c2c.png)

#### 电路交换

![](/img/wavrawr.png)

![](/img/weve.png)

![](/img/j5ej.png)

![](/img/453v34b5.png)

![](/img/45by34by543v.png)

![](/img/waeg.png)

![](/img/weccew.png)

#### 报文交换

![](/img/wexaefwaef.png)

![](/img/waecv.png)

![](/img/3c42v3.png)

![](/img/34ctv44t.png)

![](/img/1c31r.png)

#### 分组交换

![](/img/weagggg.png)

![](/img/32c11r.png)

![](/img/x21c21r.png)

![](/img/h4h.png)

![](/img/rewgrewg.png)

![](/img/1r31xc132r.png)

![](/img/fgrg.png)

#### 虚电路交换

![](/img/2c2.png)

![](/img/1232313c.png)

![](/img/23c213.png)

#### 知识回顾与重要考点

![](/img/c13r123.png)

![](/img/xxx2xr1.png)

![](/img/fgert.png)

![](/img/xxxx.png)

![](/img/gr4g.png)

## 王道基础课网络层内容

### 网络层的功能

![](/img/pipocw.png)

* 在五层协议模型中处于**第三层**，为**传输层**提供服务
* **应用层**的传输单位是**报文**
  * 应用层，把报文交给传输层之后，**传输层会把报文拆分成报文段**
  * 紧接着传输层又把报文段交给网络层，让网络层进行传输。**网络层会在报文段的基础之上加一个首部**，我们把它称为**IP数据报的首部**。那这样的一整块数据就是所谓的IP数据报。也就是我们之前经常提到的分组。**IP数据报和IP分组在408计网里面是等价的**
* 网络层实现了**主机到主机**的传输
* 数据链路层实现了**相邻结点**之间的传输

![](/img/eqgqrg.png)

![](/img/eagrg.png)

* **路由器也被称为网关**
* 路由器根据**路由协议**，生成**自己的路由表**，然后根据路由表规划**IP数据报（分组）的最佳转发路径**

![](/img/qcqqcq.png)

### IPv4

![](/img/h54h456.png)

* ARP协议，ICMP协议和IGMP协议的**数据会被封装在IP分组当中**

![](/img/w45nwn5q4q.png)

#### IP数据报（IP分组）的格式

![](/img/b56b56b6.png)

* **首部一定有20B的固定内容**
* **首部长度以X4B为单位**，也就是假如首部有20B，那么首部长度就是5，所以**整个首部的最大长度是15*4B=60B**
* 填充是为了**凑足4B的整数倍**
* **总长度包含首部和数据部分**

![](/img/452vv2.png)

* **标识**字段表示**分片来自哪个完整IP数据报**
* **片偏移以8B为单位**

![](/img/e56n.png)

* **只校验IP数据报首部**

![](/img/w45nwn.png)

#### IP数据报的生存时间TTL

![](/img/w45bw4b5n.png)

![](/img/65eb3.png)

* 到达一个路由器，路由器会将TTL-1，**若在某一个路由器TTL变成0，则该路由器不会将这个IP数据报转发出去**，会丢弃该IP数据报，然后路由器给源主机发送ICMP报文

#### IP数据报的“分片”问题

![](/img/qb3b.png)

![](/img/qb43qb6n.png)

![](/img/65n6nn.png)

![](/img/w4s5.png)

* 以太网MAC帧的46-1500就是IP数据报的大小
* **一个链路层数据帧能承载的最大数据量称为最大传送单元（MTU）**，以太网的MTU=**1500B**
* 每个分片又是独立的IP数据报

### IP地址

* IP地址发展顺序
  * ABCDE类👉子网划分👉CIDR👉NAT

![](/img/vvvvv.png)

* 单播地址分配给某一台主机
* 多播地址为了实现**IP多播**，即把IP分组发给**从属于同一个多播地址的一系列主机**

![](/img/45v4v5.png)

* IP地址为了方便阅读，会记录成**十进制的形式，8bit一组对应一个十进制数，32bit的IP地址有4个十进制数**
* 因为8bit对应一个十进制数，8bit能表示的数值范围是**0~255**
* **默认网关就是默认路由器**，即每一台主机接入互联网的时候需要经过哪一台路由器的转发，需要把**和它连接的这台路由器的接口的IP地址配置为默认网关**。
  * 这样当一台主机要往互联网上发送一个IP数据报的时候，就知道**IP数据报应该先发给默认网关**，然后路由器就会把IP数据报转发到互联网上

#### 例子

![](/img/weffwef.png)

* 某一个网络里面所有主机的网络号相同，网络内部各台主机的主机号可以由网络管理员自由分配

* **路由器和其他节点连接的接口必须分配IP地址**

* 路由器会从**IP数据报首部目的地址段拆分出网络号**，然后根据路由转发表进行转发

* H1向H7发送IP数据报的过程：

  ![](/img/xxcvvadf.png)

  * ①h1知道默认网关的IP地址之后，通过ARP协议查询到默认网关的MAC地址，将MAC帧的目的MAC地址写成B2接口的MAC地址。然后H1把MAC帧发送给交换机
  * ②交换机根据MAC帧的目的地址转发到路由器的B2接口
  * ③路由器收到IP数据报之后，检查目的网络的IP地址，根据路由器转发表从某个接口转发出去。
    * 转发的时候要修改MAC帧的目的地址为转发目的接口的MAC地址
  * ④目的路由器收到IP数据报，检查IP数据报的目的地址，根据路由器转发表找到对应接口进行转发，并对MAC帧的目的地址进行修改
    * MAC地址由ARP协议得出
    * ARP协议的作用就是让同一个网络的主机和路由器之间，**查询到IP地址对应的MAC地址**
  * **IP数据报的源地址和目的地址没变，但是MAC的目的地址和源地址一直在变**

* H1向H6发送IP数据报的过程：

  ![](/img/ffffdsfawef.png)

  * ①H1检查目的网络的IP地址，发现**从属于从一个网络，不用发给默认网关**，通过ARP协议查询到H6的MAC地址，直接把数据报封装成MAC帧，通过交换机（直接）和集线器（广播）发送给H6

#### 一些特殊用途的IP地址

![](/img/wefffff.png)

![](/img/xxcvvadf.png)

* 向网络号为Y的网络广播IP分组

![](/img/fffffffsdf.png)

* 表示本网络中主机号为Y的主机

![](/img/ffffdsfawef.png)

* 向本网络广播IP分组

![](/img/weffwaf.png)

* DHCP协议请求分配IP地址

![](/img/wccwcwcw.png)

* 不会发送到网络上，从H1网络层发出然后H1自己接收

#### 子网划分和子网掩码

![](/img/vweqvvqv.png)

* 路由器的一个接口对应的就是一个独立的网络
* 作用：**把一整块很大的IP地址块拆分成两个更小的部分**
* 引入子网之后，一台主机除了IP地址和默认网关之外，还要配置子网掩码（十进制记录）
  * 17位1，对应的是网络号和子网号总bit数，15位0，对应主机号
  * **用子网掩码和IP地址进行逐位与运算得到网络号和子网号部分（网络前缀）**
* 子网掩码的作用：判断是否属于同一个网络，不能只考虑网络号，还要考虑子网号，**只有网络号和子网号完全相同的两个IP地址才属于同一个子网**

![](/img/cwavew.png)

* 想要更多子网，就在主机号中抠出更多位数作为子网号

![](/img/waevb.png)

* 划分成多个子网以后，可以增加多个路由器，再由一个总路由器和外部连接
  * 好处：如果只有一个总路由器，不同子网主机之间的IP数据报都需要总路由器进行转发，**负担较大**，多个路由器能够减少总路由器的压力

##### 画图训练

![](/img/ewrwer.png)

###### 同一子网内部发送IP数据报

![](/img/weffwfafe.png)

* ①源地址：H3ip地址，目的地址：H6ip地址，h3检查目的地址和自己是否从属于从一个网络
  * 用配置的子网掩码和目的地址以及源地址逐位与
* ②**在同一个网络内，H3把IP数据报封装成MAC帧**，并**在MAC帧当中直接说明H6的MAC地址**
* ③MAC帧通过交换机到达集线器，集线器会把指责个MAC帧无脑转发给H5和H6，H5不会接受这个MAC帧因为地址不一样。由于IP地址匹配，H6会接收这个MAC帧，然后拆掉MAC帧的首部和尾部，得到IP数据报。

###### 不同子网同一个路由器之间发送IP数据报

![](/img\vvvvsadf.png)

* ①源地址：H1ip地址，目的地址：H3ip地址，h1检查目的地址和自己是否从属于从一个网络
  * 用配置的子网掩码和目的地址以及源地址逐位与
* ②两者网络前缀不相等，说明不在同一个网络，H1需要把IP数据报发送给默认网关
* ③H1根据ARP协议知道默认网关的MAC地址，把IP数据报封装成MAC帧，目的地址是默认网关对应接口的MAC地址
* ④MAC帧经过交换机交给路由器，路由器的数据链路层把帧的首部尾部控制信息拆除之后，再把IP数据报交给路由器的网络层
* ⑤路由器的网络层用目的地址和路由转发表中的每一个表项对比
  * **先和子网验码逐位与，相与的结果再和目的网络号进行比较**
* ⑥IP数据报封装成帧转发出去，交换机根据MAC地址转交给H3

###### 不同网络不同路由器，一个子网一个非子网发送IP数据报

![](/img/32v3.png)

* ①源地址：H1ip地址，目的地址：H7ip地址，h1检查目的地址和自己是否从属于从一个网络
  * 用配置的子网掩码和目的地址以及源地址逐位与
* ②两者网络前缀不相等，说明不在同一个网络，H1需要把IP数据报发送给默认网关
* ③H1根据ARP协议知道默认网关的MAC地址，把IP数据报封装成MAC帧，目的地址是默认网关对应接口的MAC地址
* ④MAC帧经过交换机交给路由器，路由器的数据链路层把帧的首部尾部控制信息拆除之后，再把IP数据报交给路由器的网络层
* ⑤路由器的网络层用目的地址和路由转发表中的每一个表项对比
  * **先和子网验码逐位与，相与的结果再和目的网络号进行比较**
  * **对于没有子网划分的网络来说，可以给这种网络配置一个默认子网掩码，1的位数规则和有子网划分的一样**
* ⑥IP数据报封装成帧转发出去，转发给下一个路由器
* ⑦传统路由器根据目的IP地址的前几个bit判断到底是A、B、C、D、E哪类地址，然后根据不同类别取出对应网络号的bit数，然后主机号全部置为0。取出网络号之后再和转发表的表项进行对比。
* ⑧找到对应接口，逐层转发到H7

![](/img/c213.png)

* ①H7封装IP数据报，检查是否从属于同一个网络，因为不是从属于同一个网络，H7需要把它封装成帧，发给默认网关。
  * 没有进行子网划分的网络。所以H7不需要去管什么子网掩码，那些东西由于自己属于c类网络。所以就需要用自己的前24比特IP地址的前24比特和这个目的地址的前24比特进行对比。对比失败，那么说明这个目的地址和自己并不在同一个网络之内。
* ②路由器检查目的IP，属于B类网络，查看目的地址前16bit，主机号置0，与转发表的表项对比，从某个接口转发出去
* ③到达有子网划分的路由器，该路由器首先用目的IP地址和每一行进行对比
  * **先和子网验码逐位与，相与的结果再和目的网络号进行比较**
  * **对于没有子网划分的网络来说，可以给这种网络配置一个默认子网掩码，1的位数规则和有子网划分的一样**
* ④匹配成功，从某个接口转发出去
  * 由于转发接口的IP地址和目的IP地址属于同一个网络，所以**这个路由器把IP数据报封装成帧的时候，就可以直接把MAC帧的目的地址写为H1的MAC地址**

###### 发送到互联网

![](/img/3ax.png)

* ①H1构造IP数据报，源地址：H1的IP地址，目的地址：目的IP地址。检查目的地址和自己是否从属于从一个网络
  * 用配置的子网掩码和目的地址以及源地址逐位与
* ②两者网络前缀不相等，说明不在同一个网络，H1需要把IP数据报发送给默认网关
* ③H1根据ARP协议知道默认网关的MAC地址，把IP数据报封装成MAC帧，目的地址是默认网关对应接口的MAC地址
* ④MAC帧经过交换机交给路由器，路由器的数据链路层把帧的首部尾部控制信息拆除之后，再把IP数据报交给路由器的网络层
* ⑤路由器的网络层用目的地址和路由转发表中的每一个表项对比
  * **先和子网验码逐位与，相与的结果再和目的网络号进行比较**
  * **对于没有子网划分的网络来说，可以给这种网络配置一个默认子网掩码，1的位数规则和有子网划分的一样**
  * **如果目的IP地址和配置的除默认路由外所有行都对不上，则转发给默认路由对应接口**
* ⑥IP数据报封装成帧转发出去，转发给下一个路由器。传统老路由器检查网络号，发现属于A类网络，取出前8bit网络号，末尾24位置0，然后和转发表对比，**如果都对比不上，从“其他“的转发接口发出**，路由器封装成帧发给下一跳
* ⑦重复上述过程逐一转发，最终到达目的主机

##### 大题分析思路

![](/img/erhehra.png)

![](/img/wceaceea.png)

![](/img/awecrve.png)

* 什么时候会发生匹配的“转发接口”和IP数据报的入口相同？
  * H1要给H2发送一个IP数据报，H1发送的时候误将IP数据报封装成了一个广播帧，到达B3的时候路由器根据目的IP地址查表，发现转发接口刚好是B3，出口和入口相同，因此路由器不用把这个IP数据报重新转发回去了，**直接丢弃即可**

##### 子网掩码的CIDR记法

![](/img/wqevewqb.png)

* xxx.xxx.xxx.xxx/n，**代表这台主机配置的子网掩码前n个bit全是1，后面的bit全是0**
* /n是某台主机内部子网掩码配置，构造IP数据报的时候不需要加这个后缀也没地方加

#### 无分类编址CIDR

![](/img/45vv45vv.png)

##### 定长子网划分和变长子网划分

![](/img/bwbretb.png)

* 定长子网划分的缺陷

![](/img/tynwee.png)

###### 例1：无分类编制CIDR、变长子网划分的应用

![](/img/23132b3.png)

###### 例2：无分类编址CIDR、变长子网划分的应用

![](/img/433h23.png)

![](/img/2c3v2.png)

* 需保证**任何一个子网的前缀不是另一个子网的前缀**，利用**哈夫曼编码**
* h是指原始的CIDR地址块当中，可以自由分配的主机号的位数
  * **因为如果只有1位bit进行分配，不是1就是0，而这两个地址是特殊ip地址不能分配给主机，所以一个网络至少2位bit**
* 一个叶子节点和根节点的距离，就是子网中要加多少个bit作为网络前缀

![](/img/webbb.png)

![](/img/bw35.png)

* 路由器直连主机的点对点链路，说明**路由器的接口和主机构成一个最小子网**，**至少需要两个IP地址分配给路由器和主机，除此之外还有广播地址全1和本网络全0，一共四个地址**

##### 回顾

![](/img/dvsvbb.png)

#### 网络地址转换NAT

![](/img/AWG.png)

##### 要点总结

![](/img/EFAFDSAG.png)

![](/img/wqwcq.png)

![](/img/efwqfq.png)

* 外网IP也常被称为公网IP
* 部分IP地址只能作为**私有IP**，并且不同局域网内能**重复**，也就是说**不同局域网内可能出现相同的私有IP地址**

* 发送IP数据报的时候，先发送到连接局域网的路由器接口，然后通过NAT路由器转换为外网IP发送出去
* NAT表记录了**外网IP端口号和内网IP端口号之间的映射关系**，端口号是NAT路由器自己去随机分配的，外网地址是被ISP分配的全球唯一IP

###### 手机1的微信给手机2的微信发一段文字

![](/img/Q3VT43.png)

* ①手机1在微信里面输入文字信息“在吗”？

* ②“在吗“属于应用层数据，应用层会将数据发给传输层，传输层通过TCP协议，在数据前加入TCP首部，TCP首部里面指明源端口号及目的端口号

  * 手机1只知道自己的端口号和手机2通过NAT路由器转换后的**被映射的外网IP地址和端口号**
    * 端口号通过服务器查到的
      * 比如腾讯有个服务器专门服务于微信各个进程，这个服务器的IP地址是固定的，程序员在开发微信的时候可以把这个腾讯服务器的IP地址写到程序里面
        * 这样即使不同手机的IP地址不同，但是他们都能**用一个固定的IP地址找到腾讯的服务器，然后腾讯的服务器告诉他们要找的用户的IP地址和端口号**

  * ③传输层把数据交给网络层，网络层的IPv4协议把数据封装成IP数据报，在首部指明**源IP地址（这台手机自己的内网IP）和目的IP地址（对面手机被映射的外网IP）**
  * ④IP数据报交给数据链路层封装成MAC帧发给默认网关，来到NAT路由器
  * ⑤NAT路由器收到IP数据报之后，需要完成**内网IP端口号和外网IP端口号之间的转换**，查NAT表找到对应表项，修改源IP地址为映射的外网IP地址，源端口转化为映射的外网端口
    * NAT路由器需要包含传输层的功能（修改端口号）
  * ⑥NAT把IP数据报发到外网上，然后通过路由器层层转发到达另一方的NAT路由器，另一方的NAT路由器**根据NAT表进行内外网地址转换，修改目的IP和目的端口号**，转发到内网上，然后根据目的IP地址，到达目的主机
  * ⑦目的主机拆掉IP数据报首部得到传输层数据，根据传输层首部的目的端口号确定应用层的数据属于微信进程，这样手机2的微信收到了”在吗”数据

###### 浏览器进程想给dilidili服务器发送一个数据

![](/img/htwhtnwn.png)

* dilidili服务器上运行了一个web服务器进程，被分配了一个外网IP，没有使用NAT技术

过程：

* ①浏览器准备好了数据，把数据交给传输层的TCP协议，TCP协议添加首部的信息，包含源端口号（2111）和目的端口号（80），交给网络层，网络层封装成IP数据报，包含源IP地址（内网IP）和目的IP地址（dilidili外网IP）
* ②IP数据报发送给默认网关，由于是**内网发向外网，所以NAT路由器需要把源IP地址和源端口映射为外网的IP地址和端口**，接下来把IP数据报发向外网
* ③通过各个路由器层层转发，最后IP数据报会到达外网IP200.1.1.4，**由于这台主机所属的网络没有使用NAT功能，所以这个IP数据报可以根据目的IP地址直接精准送达** 
* ④主机根据这个目的端口号80知道数据是WEB服务器进程来处理的

##### 端口号

![](/img/WECA.png)

* 每一台主机的传输层都可以定义65536个端口
* 每台主机的端口号是独立的

##### 数据的传输过程（垂直视角）

![](/img/2CRQ.png)

##### 如何缓解IP地址不够用的问题

![](/img/CQ23V.png)

* 一个局域网内能承载多个主机，如果说一个局域网内的多个设备可以共享一个IP地址，那么就可以大幅度缓解IP地址不够用的问题
* 如果全球唯一的IP地址结合上一个端口号，让其指向局域网内的某一个特定进程

![](/img/QZ3C.png)

![](/img/3V4VQ44V.png)

### 路由聚合

![](/img/fffwef.png)

* **转发接口相同，部分网络前缀也相同**，将这几条**路由表表项聚合为一条**，叫做路由聚合
  * 路由聚合缩小路由表，使得查询更快
  * 但是会引入一些无效地址
    * 因此如果目的IP地址是无效地址，有可能仍然被转发

#### 最长前缀匹配原则

![](/img/awefg.png)

* 因为G3和铁柱网吧属于同一个子网，所以应该从铁柱网吧子网所对应的IP地址块当中分配一个地址给G3
* **匹配子网前缀更长的优先转发**

#### 大题分析

![](/img/zbwa.png)

![](/img/wecrvev.png)

#### 例

![](/img/wb3baw.png)

* H1给狗剩发送IP数据报的过程：
  * ①源地址是H1的IP地址，目的地址是狗剩的IP地址。
    * H1判断目的地址和自己的IP地址是否属于同一个网络，用子网掩码和本机地址及目的IP地址逐位与，发现不在同一个网络内，需要通过路由器转发到别的网络
  * ②IP数据报发送给默认网关，主机根据ARP协议找到路由器B3接口的MAC地址，MAC帧的目的MAC地址会填入B3接口的MAC地址，然后H1把这个帧交给交换机，交换机根据目的MAC地址交给B3接口
  * ③路由器查询路由表，由于目的IP地址之和默认路由表项匹配，因此IP数据报封装成帧从默认路由接口转发出去
    * 每一个路由器都会用目的IP地址查转发表再从对应接口转发出去，不断重复
  * ④IP数据报到达县路由器，用IP地址和自己的表项对比，从G1接口转发出去到咸鱼电信。
  * ⑤咸鱼电信接收到IP数据报以后开始查路由表，根据匹配表项从对应接口转发出去，最后到达狗剩的主机
* 铁柱给H1发送一个IP数据报的过程：
  * ①源地址是铁柱的IP地址，目的地址是H1的IP地址。
    * 铁柱判断目的地址和自己的IP地址是否属于同一个网络，用子网掩码和本机地址及目的IP地址逐位与，发现不在同一个网络内，需要通过路由器转发到别的网络
  * ②IP数据报发送给默认网关，主机根据ARP协议找到路由器G3接口的MAC地址，MAC帧的目的MAC地址会填入G3接口的MAC地址，然后铁柱把这个帧交给交换机，交换机根据目的MAC地址交给G3接口
  * ③路由器查询路由表，由于目的IP地址之和默认路由表项匹配，因此IP数据报封装成帧从默认路由接口转发出去
    * 每一个路由器都会用目的IP地址查转发表再从对应接口转发出去，不断重复
  * ④IP数据报到达ISP，用IP地址和自己的表项对比，从A2接口转发出去到某学校路由器。
  * ⑤某学校接收到IP数据报以后开始查路由表，根据匹配表项从对应接口转发出去，最后到达H1

### ARP协议

![](/img/23v44532v.png)

#### 各种协议之间的服务关系

![](/img/234v32vb.png)

![](/img/32v45432.png)

![](/img/x234c32v.png)

#### ARP表

![](/img/EWVVEW.png)

#### ARP协议的工作过程

![](/img/23eser.png)

* IP数据报首先要发送给默认网关
  * 目前虽然IP数据报配置了默认网关的IP地址，但没有配置默认网关的MAC地址
* 这种情况下，**H3会构造一个ARP请求分组，指明自己的IP地址，MAC地址和目的IP地址**
* 上面是网络层的PDU，要交给数据链路层并在数据链路层封装成MAC帧
* 因为是广播找人，**MAC帧目的地址全1，源地址是自己的MAC地址**
* MAC帧发给交换机，由于是广播，所以交换机转发到其他所有接口，所有节点都会收到，但只有默认网关收到后不会丢弃
  * 默认网关会顺手把H3的MAC地址和IP地址记录在自己的ARP表中

![](/img/2c3333.png)

* 目的接口会给H3回复一个单播帧，源IP地址是默认网关IP地址，目的IP地址是H3的IP地址，源MAC是默认网关的MAC地址，目的MAC地址是H3的MAC地址
* H3收到ARP响应分组之后，知道所求IP地址和MAC地址之间的映射关系填入ARP表
* **广播找人，单播回复**
* **集线器无脑转发，交换机精准转发**

### DHCP动态主机配置协议

![](/img/webgqwvec.png)

#### DHCP协议的位置

![](/img/rebwwegrwt.png)

![](/img/qwevqrevwq.png)

#### DHCP协议的工作过程

![](/img/34f1f.png)

![](/img/132c.png)

* 为了管理每一个子网当中的这个IP地址资源，通常来说会给每个局域网配置一个DHCP服务器

##### H3新加入网络的过程

![](/img/3c3v3v.png)

* H3本身拥有一个MAC地址，但是没有IP地址、子网掩码、默认网关，因此H3会向DHCP服务器请求给自己分配自己需要的这些东西

* 四个步骤

  * ①**客户（新接入网络的主机）向服务器（DHCP）**发送一个**发现报文**

    * 应用层（DHCP发现报文）：说明自己的**MAC地址**是多少

    * 传输层（UDP数据报）：目的端口号和源端口号

    * 网络层（IP数据报）：源地址尚未分配IP地址，因此全0，刚加入，不知道DHCH服务器地址，目的地址未知，因此广播寻找DHCP服务器

      ![](/img/3qx32.png)

    * 数据链路层（MAC帧）：源地址自己的MAC地址，目的地址全1，广播帧，因为不知道DHCP服务器MAC地址

      * 报文会被广播到网络当中的各个节点，每个节点都会收到，但只有DHCP服务器不会丢弃
        * 因为到达UDP数据报发现目的端口号不匹配

  ![](/img/43v2.png)

  * ②DHCP服务器收到发现报文之后，给主机返回一个**提供报文**
    * 应用层（DHCP提供报文）：说明提供的IP地址，子网掩码，默认网关，租用期，默认DNS
    * 传输层（UDP数据报）：目的端口号和源端口号
    * 网络层（IP数据报）：目的地址H3尚未分配IP地址，因此广播寻找，源地址DHCP服务器
    * 数据链路层（MAC帧）：源地址自己的MAC地址，目的地址从发现报文已知，填H3的MAC地址（**单播帧，精准转发，其他主机收不到**）

  ![](/img/343453245.png)

  * ③客户向服务器发送一个**请求报文**
    * 应用层（DHCP请求报文）：说明自己的**MAC地址**是多少，接受IP地址xxxx
    * 传输层（UDP数据报）：目的端口号和源端口号
    * 网络层（IP数据报）：虽然在走IP地址申请的流程，但是IP地址直到4个报文发送完毕，还不属于H3，因此**源地址全0**，目的地址未知，因为网络中DHCP服务器中可能不止一个，因此可能不止一个DHCP服务器给H3发了IP地址，所以H3要广播告诉网络内的DHCP服务器，自己接收了哪个DHCP服务器分配的IP地址
    * 数据链路层（MAC帧）：源地址自己的MAC地址，目的地址全1，广播帧，理由同IP广播原因

  ![](/img/v432v.png)

  * ④服务器向客户发送一个**确认报文**
    * 应用层（DHCP确认报文）：说明提供的IP地址，子网掩码，默认网关，租用期
    * 传输层（UDP数据报）：目的端口号和源端口号
    * 网络层（IP数据报）：目的地址H3尚未分配IP地址，因此广播寻找，源地址DHCP服务器
    * 数据链路层（MAC帧）：源地址自己的MAC地址，目的地址从发现报文已知，填H3的MAC地址（**单播帧，精准转发，其他主机收不到**）

  ![](/img/2c3423.png)

### ICMP相关内容

![](/img/33241161.jpg)

![](/img/145759.jpg)

![](/img/145814.jpg)

* 传输层协议UDP和TCP只在**超时（TTL=0）、目的不可达、分片失败**的情况下发送ICMP报文

#### IP数据报

![](/img/144342.jpg)

* 需要发送ICMP的情况补充：
  * 源点抑制：当路由器或主机因为拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应该把数据报的发送速率放慢
* 不需要发送ICMP的情况补充：
  * 对第一个分片的数据报片的所有后续数据报片，都不发送ICMP差错报文
  * 对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报，不发送ICMP差错报告报文

#### UDP

![](/img/145854.jpg)

![](/img/150027.jpg)

![](/img/150037.jpg)

#### TCP

![](/img/45538.jpg)

![](/img/145654.jpg)

## 王道基础课传输层内容

### 传输层概述

![](/img/ewqcgeq.png)

* TCP通常会用于对数据准确性要求很高的地方
  * 如传文件
* UDP通常用于准确性要求不高，但是实时性要求高的场景
  * 如视频通话、直播

#### 传输层在协议栈中的位置

![](/img/2C33251V.png)

#### 传输层“端口号”的概念

![](/img/3VAVVVVVVV2.png)

#### 进程、端口号、传输层协议之间的关系

![](/img/C2512V251V.png)

* **两台主机的端口号是相互独立的**
* **UDP、TCP的端口号也是互相独立的**
* 两个进程通信时，需要指明
  * ①**传输层协议**
  * ②**自己的端口号，对方的IP和端口号**
* 套接字：IP地址：端口号
* 复用：多个进程使用同一个协议
* 分用：传输层接收到的数据，可以根据数据的目的端口号判断数据应该交给哪个进程

#### 熟知端口号

![](/img/C153V.png)

![](/img/fbced7dc407e04cbcf90e97b4ded4030.png)

![](/img/201533.jpg)

#### 有链接的传输vs无连接的传输

![](/img/ZFQV.png)

#### 可靠的传输vs不可靠的传输

![](/img/C1C53525.png)

### UDP数据报

![](/img/iunbrb.png)

#### UDP协议、UDP数据报、UDP首部

![](/img/btrvecwe.png)

* 如果应用层的报文太大，**UPD会直接拒绝这种请求**，如果要传输，需要在应用层（自己的程序中）把这个报文先拆分好后再交给UPD进行传输

  ![](/img/144026.jpg)

  ![](/img/44036.jpg)

* UDP协议中，数据的检查交给应用层（进程）去实现

* **UDP不支持拥塞控制**

* **UDP支持一对多的传输**

  * 一对一：封装成单播数据报

  * 一对多：封装成广播/多播数据报

    * eg：IP广播，端口号711

    ![](/img/215206.jpg)

#### TCP和UDP的区别

![](/img/brevcw.png)

* **TCP只支持一对一的传输**

#### UDP数据报格式

![](/img/bwevvvq.png)

* **总长度=首部+数据（字节为单位）**
* 理论最大：因为还要受到IP数据报MTU的限制

#### UDP数据报示例

![](/img/n53b4b.png)

### UDP检验

![](/img/wvebwb.png)

![](/img/ybtvrece.png)

* 生成方法：**16bit为一组，进行二进制加法，得到的中间结果逐位取反，得到最终检验和**
* 检验方法：数据和检验和，16bit一组相加，结果全1，则没有比特错误，如果非全1出错
  * 相加≈异或，因为检验和是数据和取反，所以一定每位都和数据和相异，因此最终结果全1
* **IP数据报的首部检验和也采取同样的方式，但是只检验首部且不添加伪首部**

#### UDP检验过程

##### 发送方

![](/img/bytbytbtrb.png)

* 伪首部中的UDP长度和真正的首部当中的UDP长度**相等**
* 在计算检验和之前添加12B的伪首部
  * 伪首部只用于检验和计算，实际上并不会在网络层传输

##### 接收方

![](/img/wervebrwbt.png)

#### 要点总结

![](/img/brtynytn.png)

### TCP报文段

#### TCP报文段

![](/img/8897.png)

#### TCP协议工作的三大阶段

![](/img/wveqrq.png)

* A进程挥手告别之后，A给B发送数据的通道就被关闭了
* 建立连接的时候肯定是客户端先发起，但是**断开连接没有固定的先后顺序，可以服务器先断开，也可以客户先断开**

#### 建立一次TCP连接可以传输多个报文

![](/img/webrqcqre.png)

* 每个UDP数据报运输的是一个完整的报文，而TCP只在意字节而不在意数据来自哪个报文
* TCP中的MSS是指一个TCP段中有效数据的大小（**TCP首部不算在MSS内**）

#### TCP段格式

![](/img/wvrweb.png)

* UDP首部8B，而IP和TCP首部都是20~60B

![](/img/b45c2.png)

![](/img/wbqc2.png)

* 注意区分大写的ACK和小写的ack（32bit确认号）

  * 大写ACK的作用：**标记当前的TCP报文段当中确认号这个字段是否有效**
    * 整个TCP过程中，**只有握手①的ACK=0**，因为由客户发起握手，没有上面需要确认的数据

  ![](/img/nb5b3.png)

![](/img/weabrbewae.png)

* TCP首部中的**数据偏移表示的是首部长度，以4B为单位，和IP数据报中的首部单位一样**
* **TCP数据部分=IP数据报总长度-IP数据报首部-TCP首部**

![](/img/awcervwvar.png)

* URG的作用示例：

  ![](/img/weqcrewqvrq.png)

  假设进程1想给进程2发送两个文件和一个即时文字消息，按理来说应该顺序发送，但是现在要求文字聊天数据优先传递，就要用到URG。

  其中，**紧急指针是紧急数据的专用序号，是同seq序号区分的另一组序号**

* RST的严重差错：进程杀灭、主机崩溃

![](/img/x2xr32v3.png)

![](/img/qwexwqrcq.png)

![](/img/wqevrq.png)

![](/img/34b2344.png)

* 两个进程在建立连接的时候，通过**选项**协商MSS最大段长的长度
  * 提前协商有利于B进程提前准备好缓冲区，基于MSS大小去设置自己的接收缓冲区
  * 两边设置的MSS可以不一样

##### 选项字段的作用

![](/img/34b2344.png)

![](/img/x2tc34b.png)

##### TCP校验

![](/img/qwxeqwr.png)

##### rwnd的作用

![](/img/qwexwqrcq.png)

![](/img/43v32b32.png)

* 对面先告诉你接收窗口的大小，接着才能继续发送

##### SYN和FIN的作用

![](/img/x2xr32v3.png)

![](/img/qwevrbqwce.png)

##### seq序号的作用

![](/img/v34b342b.png)

##### ack确认号的作用

![](/img/1v5b1b51.png)

* ack具有**累计确认**的作用

![](/img/3c21v1351v.png)

#### 总结

![](/img/324cvtb323x.png)

### TCP连接管理

![](/img/3122b21.png)

![](/img/23c2115.png)

#### 命题角度

![](/img/x213512xr1.png)

#### 建立连接（三次握手）

![](/img/213513232132x21.png)

* SYN表示一个进程是否在请求连接或者同意请求连接
* ACK表示的是ack（反馈已接收数据）是否有效

![](/img/vq3wasd.png)

![](/img/x231v5231.png)

* 在服务器进程允许其他客户进程建立连接的时候，就会监听自己的端口，于是**服务器进程进入了listen监听的状态**
  * 在服务器进程**收到握手①之后，从监听状态转换到同步已收到**状态
  * 在服务器进程**收到握手③之后，进入到已建立连接**状态

##### 建立连接阶段耗时分析

![](/img/2135143.png)

* 客户进程**从收到握手②开始可以发送数据**
* 服务器进程**从收到握手③开始可以发送数据**

#### 释放连接（四次挥手）

![](/img/x123c1c.png)

* **挥手②和挥手③的序号seq差值取决于两次挥手中间还需要传输多少数据**
  * eg：挥手②seq5600，后面又传输2200B，挥手③seq7800

![](/img/awecwvva.png)

* **两方的状态并不单属于客户进程或者服务器进程，而是取决于哪一方先断开连接，先断开连接的一方是左边，后断开一方是右边**

##### 释放连接阶段耗时分析

![](/img/waxeffccaew.png)

![](/img/waev.png)

* 为什么设置TIME-WAIT
  * 防止网络传输出现错误，挥手④没有发送到服务器进程，这种情况下服务器进程会重新发送挥手③

#### 要点回顾

![](/img/webrvcwcarawv.png)

### TCP可靠传输、流量控制

* 可靠传输：告诉数据的发送方，哪些数据已经被正确接收
* 流量控制：数据的接收方要告诉数据的发送方，发送数据的速度应该控制在什么范围
* 拥塞控制：发送方检测网络状况，根据网络是否拥塞调整自己发送数据的速度

![](/img/ewqvrqvr.png)

* 数据链路层的确认和重传机制以MAC帧为单位，而传输层的确认和重传机制，以TCP报文段为单位
* 接收方发ack的同时发rwnd，然后发送方基于此调整发送窗口

#### TCP首部的相关字段

![](/img/qwevrqewqx.png)

#### 过程

##### TCP传输的底层原理

![](/img/BB43VE.png)

![](/img/BSB5.png)

![](/img/J76V5.png)

* ①客户通过系统调用，给自己的进程绑定一个通信用的端口号
  * ②接着客户进程要发出建立连接的请求，在程序当中请求操作系统新建一个套接字对象（数据结构），告诉操作系统想要链接的服务器IP和端口号
    * socket套接字中记录了对方和自己的IP和端口号
  * ③接下来可以在自己的程序当中进行系统调用，让操作系统的TCP协议这个部分，根据socket的信息去发起TCP连接，即发出握手①
  * ④服务器进程收到握手①之后，也会生成一个socket对象，包含了和自己建立连接的对方的IP地址和端口号，以及自己的IP地址和端口号
    * 每一个socket对象都会包含两个缓冲区，分别是接收缓冲区和发送缓冲区
      * 本质上是操作系统给这一次TCP连接分配的char型数组，这个char型数组被包含在socket数据结构里面
  * ⑤服务器进程发送握手②，含ack，seq，rwnd
  * ⑥客户进程收到后，调整发送窗口为8
  * ⑦客户进程发出握手③，含seq，ack，rwnd
  * 发送窗口不能超过发送缓冲区的大小，也不能超过对方接收窗口的大小
  * 从TCP协议的视角来看，客户待发送数据的第0个字节，对应序号是600+0，下标为1的字节对应的序号是601
  * ⑧调用send函数（其中指明数据和发送对象）之后，操作系统会把数据按顺序填入发送缓冲区，有新的位置再填入
  * ⑨TCP协议根据socket对象里面的这些信息区构建TCP报文段，然后把这些东西发给对方，因为发送窗口只有8，所以一次只发8数据
  * ⑩服务器的接收缓冲区收到这些数据的时候，调用receive函数，告诉操作系统用户区存储空间的指针，告诉操作系统接收数据来自哪个socket对象，这样当这个socket对象的接收缓冲区有新的数据到来的时候，操作系统就可以把这些数据按照应用层的进程的姿势，把它复制一份到这个空数组当中

![](/img/13C4V315.png)

* 一个端口可以建立多个TCP连接，但是每个TCP连接仅支持一对一全双工通信
* 接收缓冲区和发送缓冲区的大小可以不相等，具体分配多少是由操作系统的内核去决定的

![](/img/65N345.png)

![](/img/IKUNHTG.png)

* ①假设客户端进程首先给服务器进程发送了三个字节的数据，那么，从客户端的发送窗口中取出三个字节封装成TCP报文段，在网络层封装成IP数据报，经过路由器的转发到达服务器的传输层，被放到接收缓冲区里面
* ②接收方的TCP协议对数据进行TCP校验，如果没有错误，服务器进程给客户端进程返回ack，rwnd
* ③客户进程确认自己600-602数据已经被接收，接下来发送从603开始的数据，清楚已经确认接收的数据，存入新的数据。然后根据rwnd调整自己的发送窗口

![](/img/JMGHF.png)

![](/img/CSDGFD.png)

![](/img/CQWEVRBQE.png)

* 接收缓冲区满了以后，服务器的TCP协议会把已经收到的这些数据按序交付给应用层，把这些数据从内核区复制到用户区，清空接收缓冲区，接收窗口变大。服务器发送tcp报文段，告知对方接收窗口大小和ack，客户的发送窗口也重新调整

![](/img/XEWRQ.png)

![](/img/WQECVRBQC.png)

![](/img/MJHGF.png)

![](/img/KTILTUL.png)

* 有序无序：看前面有没有收到

#### 超时重传机制

![](/img/Y89OLYU.png)

![](/img/YNTBRV.png)

* 计时器时间到了，发送方就会进行超时重传，并重置计时器
* 超时重传的情况

![](/img/IKUJYH.png)

![](/img/LKJHFN.png)

* 未超时情况

![](/img/BJGJH.png)

![](/img/TYJJTRK.png)

* 只要超时，客户端这边就会重新构造TCP报文段，重置计时器
  * 如果对面正常收到TCP报文段，那么会返回ack，发送方在计时器超市之前收到ack，那么就正常继续

#### 快重传机制、立即确认机制

![](/img/TYRBWB.png)

##### 推迟情况

![](/img/Q2AG.png)

* 假设623在传输过程中丢失了，而另外的三个TCP段都可以顺利被接收方接收，因此622、624、625三个数据都可以被顺利接收。
  * 因为采用的是推迟确认的方法，数据的接收方收到第1、3、4报文段，那么推迟了0.5s之后，在这个时间点，服务器不得不给发送方返回一个ack，确认号=623，接收窗口的大小应该=3
    * 因为623之前的所有数据已经收到了，那么现在服务器这边还可以接受从623开始的3个字节，所以接收窗口的大小是3，也就是说，**接收窗口的大小取决于ack（已经收到的数据，而不取决于接收缓冲区的剩余大小）**
    * **接收窗口和确认号这两个东西是组合起来看的，当客户端收到这两个东西的时候，就会知道在623之前的所有数据已经被按序接收了，而目前可以给服务器发送的，应该是从623开始往后的三个字节**
* 对于客户端而言，发送的时候分别给四个报文段都设置了各自的计时器，根据服务器返回的ack，622已经被接收，因此622不用再占用发送缓冲区，挪出。与此同时，由于对方的接收窗口=3，客户端的发送窗口相应缩小变成3。
* 此时出现的问题是，客户端这边发送窗口框住的数据已经发出去了，但是还没有超时，客户端不需要立即重发，得等到三个都超时后再依次重发。因此客户端目前发送窗口中已经没有可以发送的数据了，那直到这个超时重传计时器超时，623、624、625才会开始依次超时重传，虽然624、625对面服务器已经接收，但依旧要重发

![](/img/AB2352.png)

* 服务器接收后检查三个报文段，发现后面的两个报文段是重复的，只需要接收623，由于接收缓冲区已满，数据交付给应用层，ack=626，接收窗口=8
* 此次客户端传送的三个TCP段都没有超时，于是根据ack的值可以确定三个报文段顺利接收，把他们移出缓冲区，空出来的缓冲区读入新的数据，发送窗口调整为8
* 问题：
  * 虽然能够发挥累计确认的特性，但是如果其中的个别报文段传输出现问题，那很有可能导致几个报文段陆续超时，而其中的某些报文段本来是没有必要重传的

##### 快重传机制和立即确认

![](/img/waver2.png)

* 注：**图中冗余ack出错，一共四个ack，一个正常ack，三个冗余ack，应当多加一个**

* 客户端发出了1、2、3、4，连续发出了四个TCP报文段，其中，第二个报文段它丢失了。
  * 由于采用了立即确认机制，因此服务器每收到一个报文段就立即给客户端返回ack，接下来携带622这个字节的这个报文段中途丢失，服务器这个边收到的就是携带623、624、625，收到623的时候返回ack622，624、625同理，而622发出前已经有一个正常ack622，因此出现三个冗余ack。
  * 由于发送方收到三个同样序号的冗余ack，那么在发送方收到第三个冗余ack的时候就立即重传三个ack对应的报文段即622，由于引入了快重传机制，因此报文段的重传，大大提前了，因此由于计时器还没有超时的时候就已经进行了重传，整个过程当中顺利送达的两个报文段并没有被重复的传输
* **因为快速重传机制通过冗余ack去出发，而冗余ack又需要立即确认机制去支持，所以但凡支持快速重传的TCP，都采用立即确认的机制。而不支持快速重传的TCP，就会采用推迟确认的机制**

![](/img/c23ra.png)





#### 要点回顾

![](/img/AB235CC.png)

![](/img/avracr.png)

* 如果服务器也有数据传送给对面，那么久不用推迟，立即返回ack段并捎带自己的数据（稍待确认）
* 如果连续收到两个长度为MSS的傲文端，就应该立即返回ACK段（累计确认，确认最后一个）

![](/img/AV325BAAAAAA2.png)

* **通过接收方的接收窗口大小区限制发送方的发送窗口大小**

### TCP拥塞控制

![](/img/qwecrwec.png)

#### TCP拥塞控制和流量控制的区别与联系

![](/img/weqrvwqercr.png)

* 假设A和D在进行TCP连接
  * 流量控制：控制**TCP连接的双方**给彼此发送数据的速度，只管局部
  * 拥塞控制：控制**整个网络**中每台主机的数据发送量，当发生拥塞的时候，希望尽快地降低网络中这些路由器的负载，是一个全局的问题
    * 如果说主机注入的数据量太大，超出了整个网络的传输能力，网络中就会经常出现丢包的现象，即网络变得好卡，也就是发生拥塞
* 拥塞窗口：每一个发送方都会维护的一个变量，数据的发送方，它的发送窗口**不能超过接收方的接收窗口大小，也不能超过拥塞窗口的大小**，反映的是当前这个网络传输数据的能力
* 顺利收到ack——不用色
  * **超时重传**：严重拥塞
    * 发出一个报文段之后没有按时收到ack，主要原因是路由器发生了丢包的状况
      * 比如说C发出了TCP报文段，在网络层封装成IP数据报，到达中间的某一台路由器的时候，由于路由器的负载很大，来不及接收这个主机发来的TCP段，那么对于C主机而言，这个发出的TCP段会迟迟收不到ack，那么路由器丢包，说明此时路由器的负载已经很重了，因此我们可以判断发生了严重拥塞
  * **冗余ack快重传**：有点拥塞
    * 因为收到冗余ack，说明发送方发出了四个TCP报文，其中三个TCP报文顺利到达，另外一个TCP报文丢失，1/4的概率，说明网络可能有点拥塞但是没到严重的地步

![](/img/txwre.png)

#### 慢开始、拥塞避免

![](/img/qwvrebwqevecx.png)

* 传输轮次以RTT为单位
* **0RTT的时候拥塞窗口为1**
* **慢开始网络拥塞的情况下，拥塞窗口重新设置为1，阈值设置发生超时重传时拥塞窗口的一半**
  * **网络拥塞指的是超时重传**，只有超时重传会把拥塞窗口变成1，如果是冗余ack触发快恢复，拥塞窗口和阈值一样变成超时重传时拥塞窗口的一半

![](/img/gsthr.png)

* 由于发送方已经把阈值降为了12，因此发送8个报文段接收到8个返回的ack时，拥塞窗口为8+4=12，因为拥塞避免算法在一个RTT内，即使收到多个ack，也只能让cwnd+1
  * **连续回的n个ack卡在了阈值之间，然后有一个ack导致cwnd到达阈值，然后之后的同一个RTT内的所有其他阈值都不再加cwnd，因为到达阈值的那一个ack已经是让cwnd+1的ack了 **
* **cwnd是向下取整，因此不会出现一半的情况**

#### 快重传、快恢复

![](/img/trewfqf.png)

![](/img/74336.jpg)

![](/img/weqrvwqercr.png)

* 快恢复：**把拥塞窗口和阈值变成当前值的一半**

![](/img/weerbqvc.png)

* **阈值不能小于2，如果拥塞窗口为2的时候出发了快重传，阈值也是2**

## 王道基础课应用层内容

### 网络应用模型

![](/img/becqce.png)

#### 客户/服务器模型（C/S模型）

![](/img/wqebqvcew.png)

##### 客户/服务器模型实例：百度网盘

![](/img/awbrweab.png)

![](/img/wbnawer.png)

* A想要给D分享一个文件
  * A把文件传到服务器，D得从服务器

#### P2P模型（对等模型）

![](/img/wevqv.png)

* 整个网络当中的传输内容，都不会保存在一个中心的服务器上，而是每个节点他都具有上传以及下载数据的功能，他们的权利和义务对等
* p2p模型中并不存在永远在线的服务器，主机既可以提供服务，也可以请求服务，每台主机既可以成为服务器，也可以成为客户

##### P2P模型实例：BT种子下载

![](/img/weabwb.png)

![](/img/ybtrwce.png)

* a有文件资源，那么a可以把这个资源的BT种子分享给其他的主机，b可以用这个下载工具区打开这个文件资源的BT种子，接下来a就可以给b传输这个数据，这样b也有了这个文件资源
* 如果c也想要这个文件资源，那么c用下载工具打开文件资源相关的BT种子之后，这个软件就会从网络当中所有的节点去获取文件资源，此时A主机给C传一部分，B也给C传一部分，两边的传输同时进行，对于C来说，接受文件的速度就会翻倍，那么C下载的速度就会非常快

### DNS

#### DNS系统

![](/img/vqweq.png)

#### 域名

![](/img/ytne.png)

* 自左向右级别变高，最长不能超过64位，实际中为了方便记忆不超过12位，只能用-
* 二级域名和顶级域名可能发生重合

#### 域名解析过程

![](/img/45b2.png)

![](/img/34b6n2.png)

#### 域名服务器

![](/img/agaf.png)

* 我们访问www.qq.com，实际上就是向www.qq.com服务器发出了一个请求网页数据的http报文
* 网站服务器收到请求之后，就会给我的浏览器进程返回网页的数据
* 然而一台网站服务器的IP地址是多少，我们并不知道，因此**需要用DNS将域名转化为IP地址**

#### 本地域名服务器

![](/img/vav.png)

* 专门用于提供DNS服务的主机
* 这台主机的内部，**会缓存近期被查询过的域名和IP地址的映射关系**
  * 一台主机想要访问某个网站的时候，会**先对本地域名服务器发出一个DNS请求**，如果本地域名服务器能够在自己的缓存当中找到，就可以快速响应，告诉这台主机访问域名对应的IP

#### 域名服务器类比

![](/img/XZCV.png)

* 校长对应根域名服务器，院长对应顶级域名服务器，系主任对应权限域名服务器

#### 递归查询

* 假设你听说你们学校的计算机学院数字媒体系有一个A大佬，想要向A大佬请教一个问题，但是你只知道这个大佬的一级域名，二级域名，三级域名，接下来你要怎么做？

  * 第一种方式（**递归查询**）：去校长办公室找校长，校长不知道，让去找计算机学院院长，计算机学院院长也不知道，让去找数字媒体系系主任，去找系主任，系主任知道，找到了a大佬的联系地址
    * 然后系主任把消息上报给院长，院长上报给校长 ，校长反馈给我
    * 但是这种方法会导致根域名服务器负担太重

  ![](/img/WEC.png)

  * 第二种方法（**递归查询**）：假设宿舍楼里面有个人脉王，知道全校很多同学的联系方式。假设在这之前有人已经向人脉王打听过A大佬的联系地址，那这个人脉王会把这个地址先缓存下来。
    * 假设在这种情况下去问人脉王，想要找计算机学院数字媒体系的A大佬，人脉王检索记忆会把联系地址直接给我，于是我就可以根据这个地址直接去找到a大佬。此时如果另一个人也想找A大佬，那也可以快速获得A的地址
    * 只有在人脉王被问到不知道的联系方式的时候，比如我想问B的联系地址，向人脉王发出一个DNS请求，通过请求告诉他，我想找计算机学院数字媒体系的B大佬，你是否知道他的联系地址。
    * 此时人脉王会代替我去找校长，校长找院长，院长找系主任，然后系主任知道反馈给院长，院长反馈给校长，校长反馈给人脉王。
    * 人脉王收到结果以后再把B大佬的地址告诉我，返回一个DNS响应报文，然后顺便把B的域名和IP地址写到自己的缓存当中

  ![](/img/ZZSDF.png)

  ![](/img/3CC32CA.png)

  ![](/img/3R2QQT.png)

  ![](/img/QG34GT.png)

#### 迭代查询

![](/img/Q3G4T.png)

![](/img/QV3H44HG.png)

* 询问人脉王B大佬的联系地址，人脉王查了自己的缓存发现没有，于是请教校长。
  * 校长说我不知道，但是可以告诉你计算机学院的院长办公室地址在哪
    * 注意，校长没有帮人脉王跑腿，而是告诉人脉王下一个节点的地址在哪
  * 人脉王知道计算机学院的院长办公室以后，去问院长，院长说不知道，但是告诉了人脉王数字媒体系的系主任的办公室在哪（下一级域名服务器的地址）
  * 人脉王去找系主任，系主任知道，告诉了人脉王B的联系地址，人脉王获得答案，告诉我B的联系地址，并把结果记录在自己的缓存当中

### 文件传送协议FTP

![](/img/rewvtb.png)

* TFTP适合UDP协议，小型文件传输
  * 需要将文件或者程序同时向许多机器下载的时候，就经常会去用到这个TFTP
  * 比较容易实现，面向小文件的文件传送协议
  * TFTP代码占用的内存小，适用于一些比较小的计算机或者特殊用途的设备
* FTP协议可以屏蔽不同操作系统之间的差异性

![](/img/qwvrqwv.png)

#### FTP工作原理

![](/img/31CV.png)

* 控制进程和数据传送进程都是从属进程
* 文件传送完就关闭数据连接，结束运行

### 电子邮件

![](/img/AWV4T34.png)

![](/img/21C31.png)

* 用户代理：用户和电子邮件系统的接口
* 邮件服务器：24h不间断工作

#### 简单邮件传送协议SMTP

![](/img/2131.png)

![](/img/32C1.png)

* 过程
  * 1、连接建立
    * 发送方写邮件，邮件写好后发送给发送方的邮件服务器，放到邮件服务器的邮件缓存。
    * SMTP客户，也就是发送方的邮件服务器每隔一定的时间就会对邮件缓存里面的邮件进行扫描
    * 如果发现邮件，就准备用SMTP协议进行发送，使用熟知端口号25与接收方的SMTP邮件服务器建立TCP连接
    * 连接建立之后，接收方的邮件服务器就要发出一个应答信息，也就是220service ready，告诉发送方已经可以准备接收了，服务就绪
    * 然后SMTP客户向SMTP服务器发送一个hello命令，并且附上发送方的主机名
    * 如果SMTP服务器有能力接收邮件，就会返回一个应答250OK，如果没有能力接收邮件，就会回答一个421service not available服务不可用，如果在一定时间内发送不了邮件，邮件服务器就会把这个情况告诉发件人，也就是发送方
  * 2、邮件发送
    * 首先发送方服务器发送“ mail from 发送方电子邮件地址 ”命令
    * 如果接收方服务器准备好了，会返回一个250 OK，如果没有准备好，也会返回数字，加上一定的英文信息说明。
    * 发送方如果收到了250OK，就会发送一个或者多个RCPT命令（指明要发送给谁，即收件人的邮箱地址）
    * 每发送一个RCPT命令，就会有相应的一个信息从SMTP服务器当中返回，并且显示250OK（收件人地址正确），或者是返回550 no such user here（收件人的地址错误）
    * 接下来正是传送数据，发送方服务器发送一个DATA命令，这个DATA命令表示它准备开始正式传输邮件，如果接收方服务器返回354 start mail input命令，就表示它同意传输，
    * 接下来A开始正式传输邮件内容，发送完毕之后也要返回CR LF，表示传输结束
    * 如果接收方邮件服务器发现有一个回车的部分，就确定这个邮件的内容已经完全传输结束，就会返回一个250OK
  * 3、连接释放
    * 邮件发完，SMTP客户发送QUIT命令，SMTP服务器返回221，表示同意释放TCP连接

#### 邮局协议POP3和网际报文存取协议IMAP

![](/img/B3B3BY.png)

#### 基于万维网的电子邮件

![](/img/543V.png)

### 万维网Web

#### 一个网页的构成

![](/img/ewqcreq.png)

![](/img/weqrcqw.png)

![](/img/ergwg.png)

* html文件的背后本质上就是一些字符信息，只不过这些字符有特殊的格式要求

#### 当你访问一个网站的时候，背后发生了什么

![](/img/ewgewggr.png)

* 当我的主机刚接入学校的局域网的时候，会通过DHCP协议动态获取一个IP地址，以及配置一个子网掩码，还有默认网关，以及学校DNS服务器的地址
* 假设我要访问dilidili.com，当我输入网址并敲下回车键之后，接下来我的浏览器会通过DNS服务器去查询输入的域名对应的IP地址。
  * 浏览器会根据主机里面配置好的DNS服务器的地址，构造一个DNS请求报文，指明要查询的域名，然后该报文被封装成UDP数据报，再封装成IP数据报，里面指明源地址是本主机IP地址，目的IP地址是主机内配置好的DNS服务器地址。
  * 根据目的IP地址，最终该IP数据报被本地域名服务器接收，这台本地域名服务器拆掉IP数据报首部得到了UDP数据报，检查UDP数据报的目的端口号是53，DNS服务器顺利接收UDP数据报
  * 然后DNS服务器检查自己的缓存，如果能找到对应IP地址，将查询结果包装成一个DNS响应报文，然后在传输层封装成UDP报文，在网络层封装成IP数据报发回浏览器进程
  * 浏览器进程收到DNS响应报文之后，知道网址对应的IP地址，于是浏览器进程会和这个网站服务器上面的web服务器进程，也就是TCP80端口号（web服务器专用熟知端口）建立起TCP连接。
  * 三次握手，其中握手③发出http请求报文，然后服务器发回http响应报文，携带html文件
  * 浏览器进程根据html文件请求需要的元素，每个元素对应一次http请求和http响应，最后获得全部元素，渲染网址到显示屏上

#### HTTP协议的工作方式

![](/img/rgergerg.png)



![](/img/weqcrqwerc.png)



### 超文本传输协议HTTP

![](/img/wqecrwqqr.png)

* 账号密码信息就是通过post方法发给服务器，让服务器处理post发过去的内容

#### HTTP报文格式实例

![](/img/wef.png)

#### cookie的作用

![](/img/wwqeqv.png) 

* 服务器给客户端办的一张临时身份证，有了这个，服务器就能区分当前和自己通信的客户端到底谁是谁，可以进行个性化处理
* 如果浏览器给服务器发的HTTP请求报文当中包含cookie字段，意味着这个浏览器之前肯定已经和服务器发生过交互

![](/img/xddrrt.png)

#### 总结

![](/img/ntrg.png)

* host字段：指明这台主机的域名地址
* connection字段：
  * 持续/非持续连接
* cookie字段

## 结课考试

### 题目

![](/img/32b5b.png)

![](/img/65n3.png)

![](/img/b4537n.png)

![](/img/3v426nbv26.png)

![](/img/0be48c6db25e_05.png)

### 讲解

#### 1

![](/img/a6n3.png)

![](/img/6m87n6b5vttrcex.png)

* 假如我们把FTP服务器视作百度网盘，用户界面对应网盘界面
  * 想要从网盘上下载文件，**首先得登录账号**
    * 此时百度网盘会**在后台创建一个控制进程**，这个后台的控制进程会尝试**和百度网盘的服务器的控制进程TCP21端口建立TCP连接**
      * **控制进程的TCP连接是持久的，只要不退出网盘就会保持连接**
  * 然后账号和密码会通过TCP连接传到服务器，百度网盘服务器的控制进程会对账号密码进行验证，确定用户有权限访问的文件
  * 假如我要上传一个文件，把文件拖进网盘，此时客户端的控制进程会通过已经建立好的TCP连接，告诉百度网盘的服务器要上传文件以及文件的相关信息，网盘服务器收到请求后，会通过控制进程去判断能否上传
  * 如果控制进程认为可以上传，就会返回一个数据传送进程的端口号，然后客户端会在后台建立数据传送进程，然后和返回的端口号尝试建立TCP连接，连接建立之后就可以开始传送文件了
    * **非持续，传完文件就断开TCP连接**
  * 百度网盘服务器那边可以有多个数据传送进程并发执行（**从进程**）
* 控制进程会永久监听TCP连接的21端口
* **主动方式使用TCP20端口**（通常用于匿名传输），**被动方式由服务器和客户协商决定**

![](/img/87m6n5b4v3cx.png)

* **初始序号+1就是数据部分的初始序号**，因为建立TCP连接的握手①消耗一个序号，握手③才可以开始携带数据

* 在拥塞避免算法前（到达拥塞阈值前），每一个ack都会导致拥塞窗口的值+1（单位MSS）
* **拥塞窗口一旦大于阈值，那么在1个RTT内，无论连续收到多少个ack，拥塞窗口最多只能+1**

![](/img/m87654e.png)

* 什么时候可能出现冗余ack？

  * ①第一个TCP报文段丢失
  * 此时来到拥塞控制的另一种策略
    * **连续收到三个重复的冗余ack（4个相同的ack），就要执行快重传算法**，即把**阈值和拥塞窗口设置为当前拥塞窗口的一半（计算机内部一般向下取整）**
    * 只有4个重复ack才能出现3个冗余ack，因为第一个ack不是冗余的，是正常的

  ![](/img/193723.jpg)

* **超时慢开始，冗余ack快重传**

#### 2

![](/img/m867n6b5evtrew.png)

![](/img/m87n655.png)

* 直通交换方式：交换机需要把开头的6个字节（目的MAC地址）先接收下来，然后才能根据目的MAC地址确认这个数据帧从哪个接口转发出去
  * 转发时延低，固定等于**6B/交换机的传输速率**
* 存储转发方式：交换机先把整个MAC帧全部接收到交换机内部的高速缓存里面，完整接收下来之后再决定这个帧应该从哪个接口转发出去
  * 转发时延高，等于**帧总长（6+6+2+N+4）/交换机传输速率**

![](/img/98,7mn76byhtvrge.png)

![](/img/.09,8m7n6b5v54.png)

* 在一段链路当中，**数据的传输速率上限取决于这段链路中最低的传输速率**

![](/img/9,8m7n6b5.png)

#### 3

![](/img/m867n6b5evtrew.png)

* **TCP里面ack以B字节为单位**，而**数据链路层中数据帧的确认以帧为单位**
* 注意区分帧的序号和发送窗口接收窗口的区别，帧的需要用3bit那就是0-7，但是接收窗口和发送窗口一共等于8
* 分析思路：先把某一方的发送窗口或者接收窗口写出来，根据时序图判断分析的这个结点之前已经发出的是哪几个帧，已经发送的标注出来，然后在发送的中间观察已经被ack确认接收的是哪几个，**已经确认的右边边界砍一刀，这个就是发送窗口的起点位置**

#### 4

![](/img/terbnmtrhgf.png)

![](/img/cv6uk.png)

* 分析RIP构建路由表的时候，可以先画初始向量，然后再画交换距离向量后各个路由器新增的表项

![](/img/m87tnb.png)

* 用邻接表记录自己周围的拓扑结构的信息，然后把自己相连的节点的信息，用洪泛法通知自己的邻居自己的拓扑结构

![](/img/ervtb.png)

* **同一个自治系统内**路由器之间的转发**并不会增加AS跳数**

![](/img/frdst.png)

# 一点录音

好，今天就这样，我们明天继续。

 Door, 我妈妈the screen in the kitchen，I turn the music, go get high, not list the little five. 

 拜拜，我们明天见，明天见，明天最后一天。

 对，明天也是。

 我会把这几天的这几个专题还没有覆盖的几个大题，作为明天的测试，以及明天测试之后要讲的题目。

 好。

 还会再见，还会再见的，不用这么悲伤。

 拜拜，听一首歌，要不然还陪大家聊几分钟，到40撤退可以吗？那6点40准时撤退。

 Pray for a was fine. 

 We feel like mine. 

 终于结束了。

 突然发现这首歌的歌词写的还是我，我以前从来没有看过他的歌词。Good. 

 the old rack. 

 年纪越大，看见的越多，你的父母不是英雄，他们和我一样都是普通人，真好。

 Don't know with. I used to be mad, but now I know sometimes. 

 成长真的不容易真的不容易，要受很多伤，感受很多。曾经没有感受过的东西，其实大部分同学在在开始考研之前应该算是比较顺的。大部分同学应该是这样对吧？虽然可能高考会有同学考得好一些，有的同学考的稍微普通一些，但是终归来说其实我们并没有太多的区别。就是你总能在一个固定的时间点顺利的迈到人生的下一个阶段，有没有？但是从大学毕业开始，从这个考研开始，我感觉至少我自己是这样的。就是我是从大学毕业开始，发现成长真的好难，就是每一步都是他不再会接下来的成长，不会再是那种每一个固定的时间点，生活都会给你一个确定的回馈，都会让你确定的迈入下一步就很难。但是this is life，这才是真活生活的真相，这才是生活的真相。

 Never really sure i'm. Going what everyday i'll be a new I. 

 基础还没完，可以报26的班了别同学不管不论如何，反正按照现在的节奏，尽快的把基础学完。学完之后你就直接跳过强化，直接上真题，把历年真题给尽可能的过一遍。历年真题只要过一遍之后，其实你要考个百来分，反正过线有书读的那种分数，这还是很有可能的。所以如果现在还没有结束基础的话，也没关系的，也没关系的。

 我自己在考研的那年，我的基础是在11月15号左右，就11月中旬左右才结束的基础。然后11月中旬基础结束之后，当时其实也没有什么王道的什么考研课程，没有这些东西。当时就是基础课结束，我就赶紧刷真题，把真题再重新复习一遍。其实很多真题在第一轮学的时候就已经就已经做过了。那你再把这个真题，上考场之前把真题尽可能多的把它啃一遍，啃一遍，那其实对于考试提分来说还是会有很好的效果的。所以如果现在进度不太理想的同学也不用着急，真题如果你来不及强化，你就直接真题，直接真题一定是效果最好的。

 真题过考点还是看书按顺序过考点？在11月份这个阶段，我的建议是用真题用真题过考点。因为如果你对真题比较，第一轮做完这些真题之后，你会发现其实真题它考试的侧重点是28定律。我觉得他就是个28定律。80%的分值藏在20%的考点。那有没有这种感觉，大家。

 80%. 

 的考点，80%的分值其实藏在20%的那个考点之内。其实我们基础课学的很全面，但是大多数都是比较偏的一些考点，考察的概率不高。所以所以现在所以现在如果你觉得那个时间不够的话，我建议就不要不要从头到尾刷王道书。

 王道书现在可以怎么用？首先第一第一大家要把真题，真题是最重要的，在这个阶段真题是最重要的。你可以不强化，你可以不冲刺，什么都可以不做。但是真题唯独真题你是必须做的，真题是必须做的，而且现在的时间也完全来得及，让你把历年的真题都研究一遍，时间是足够的，这个不用担心。

 然后除此之外就是。除此之外，那个。就是我们的王道书课后习题，王道的课后习题。你在第一轮复习的时候，不是已经做过这些王道书的课后习题吗？并且你肯定会对这些课后习题留下一些笔记。比如说哪些题目是错的，哪些题目是正确的那当你把这个课后习题就是曾经你已经掌握的这些课后习题，就是再一次的去回顾一遍，其实这样带来的效果是很好的。就在这个阶段你更多的是需要去把自己曾经已经学过的东西把它重新捡起来，然后确保我已经学过的东西上考场之后我是能做出来的。你可以少做一些新东西，但是曾经已经做过的你把它快速捡起来，这样的效果是更好的。

 好，所以最后这个阶段，真题还有王道的课后习题就是你做过的。已做过的课后习题。对，把这些东西再重新巩固弄一遍，其实就差不多了。没你想象的那么可怕。放轻松一点，我我在我自己在复习的时候，反正也是11月中旬才结束了第一轮，然后就直接进入了刷真题的环节，其实到最后的成绩也还不错。

 对二刷错题远比你做新题重要。对，这位同学的这个理念是正确的。二刷错题远比你做新题更重要。因为最重要的题目其实你已经在第一轮复习的时候都已经做过了，以及真题当中你还没有做过那些题目，就是最重要的题目。

 好，所以稳住。到最后这个阶段有时候考的是一种心态。有的同学并不是说你复习的不好，几乎所有的人都会觉得自己复习的不好。但是在最后这个阶段就是最终能赢的其实是心态稳住的那那群人不见得他们的能力或者智商或者学习的成效果比你好多少，或者比谁好多少，而在于他们的心态能稳住。他不会去他能够克制住自己的那种焦虑感，能够让自己的情绪注意力保持专注，保持平稳。用这样的状态坚持到考试的那一刻，我相信你会获得你想要的好结果。所以考研就是这样，你到最后比的是心态，其实跟能力，能力可能在最后这一阶段都不是最重要的。心态要好啊，心态要好直接放弃。对，按部就班就是最好的，less is more, 少想一些做就行了。你只要确定了每一门科目最重要的是什么，你做就行了。

 我在我跟大家分享一下，因为现在大家感觉都很慌。我在11月的时候，我考研的那一年11月的时候，就是跟大家一样那个时刻，11月份我做了16年的数学题，我自己在考研的时候，11月就是第一轮还没有完，第一轮还没有过完。就是专业课就是专业课，专业课的第一轮没没结束。然后在还有一件事情也让我很慌，当时就是2016年的数学一，我不知道大家做没做过2016年的数学一那套题，那套题有没有同学做过？你得了几分？

 2016年的数学一那套卷子让我印象极其深刻极其深刻。那套卷子我考的特别糟糕，就是我自己给自己，我觉得数学好像经过了一年的训练，好像没什么问题了，对吧？然后我做了之后，反正不到100，不到100，我没记错的话，是91还是多少。对，91还是多少？91还是92。反正这套题做完之后，我自己批改了，只有91。当时就觉得崩了，91的分数怎么可能上北大呢？我觉得我完了，我的我是不是又得来一轮，或者想到了各种坏的结果想到了各种坏的结果。

 然后那天我在那个自习室的天台上，刚好我的家人我的父母给我打电话，然后问我最近压力大不大，要保重好身体什么，那一刻我就破防了。就是我在那个自习室的天台上，留下了我恐惧的眼泪。恐惧的眼泪虽然没有大声哭，但是我感觉那一刻我的那种感受是没办法去克制的对那种情绪是他他来的非常自然，我觉得我无法克制，所以一滴猛男的眼泪从我的眼角流下。

 留下了之后我我觉得我觉得我完了，甚至我在那通电话里面跟我的家人说，万一我考不上怎么办？对吧？我已经开始想这种最坏的结果了，我已经开始给自己打咚咚退堂鼓，开始敲起来了。我想要告诉我的父母，就是我可能这次还是考不上怎么办？然后他们我忘了当时他们说了什么了，但大概意思就是反正就是别着急，反正心态要放稳之类的。那种就是一张试卷或者你今天的感受决定不了什么。对，所以听完父母的这番话，其实倒也没有给我带来太多的什么安慰和帮助。但这个时刻就是我我就下去散步，我想我想让自己稍微放松一点，然后那个猛男的那滴眼泪在我的脸颊上还没有完全的干透。

 当我在下楼的时候。刚好我的耳机里随机随到了这首歌，随机随随到了这首歌，然后越听越觉得奔跑吧骄傲的少年不就是这样吗？哪怕失败又会怎样，对吧？真的很巧，就是当我觉得我可能快不行的时候，当然我的内核肯定是不愿意放弃的那这个时候很巧，这首歌就刚好出现在了我的耳机里面。所以那一刻就是我我听这首歌的歌词，我觉得他好像是在鼓励我内容。只要全力以赴就无所谓失败。每一句歌词当时都打在了我的心巴上，猛男的眼泪突然觉得好像不需要再留了，冲就行了对吧？就那种感觉。

 也流过了眼泪，为了梦想疯狂。

 世界里的期待。

 所以我觉得最近这段时间，我们看到很多同学因为复习的进度或者某一些试卷模考的成绩不太好。我也曾和你一样，也在经历这种感受，也是在这个时期这个阶段。但是真的就是到最后上考场的那一刻，你这一年的回报都会在你的试卷上喷涌出来。

 加油。

 就行了，不用管那些结果什么的，胜利和失败不是用结果去衡量。

 好，陪大家听完这首歌，今天就结束。

 就在眼前。

 坚持。

 这段送给大家。

 如今，我整装待发，充满正能量，学会了坚强面对生命的真相。

 成功和失败不是用结果去衡量，挫折和磨难只会让你变得更强。经历过屈辱和嘲笑，那又怎样，胜利的使命仍然背负在你肩上。年轻的旋律多么自由而奔放。

 骄傲的少年却。时间的时代。

 生的歌我再唱一遍。

 好，这就是11月份那个时刻。我和大家一样，也在这首歌就是我在猛男的眼泪滴落我的脸庞的那一瞬间，这首歌也刚好想在我的耳畔回响。我觉得当时他也确实给了我一些态度和理念。然后这句话是我最想要送给大家的，也是当时最能鼓舞我的。成功和失败不是用结果去衡量，挫折和磨难只会让我变得更强。这句话。

 不是用结果。

 去衡量，挫折和磨难只会让你变得更强，可以吧？所以不用担心考研，考研只是你人生的一个小的插曲。就是考研的成与败，有结果还是没有结果，其实都不影响你依然有机会过一个灿烂的人生。所以稳住心态就行。反正最后这段时间我希望大家能够与自己和解，与未知的恐惧，与未知的结果去和解，然后最后都能够稳住心态。对，稳住心态，我们用最好的状态，最放松的心态去迎接最后的这段时间，好吗？好，明天我们再见，明天再见，拜拜，晚安玛卡巴卡，晚安无CDC晚安小点点，明天见。

