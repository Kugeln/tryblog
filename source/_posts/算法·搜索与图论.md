---
title: 算法·搜索与图论
date: 2024-03-26 16:13:52
tags: 算法
sticky: 102
categories: 算法
banner_img: /img/1920x1080 (2).jpg
index_img: /img/1920x1080 (2).jpg
---

# 搜索与图论

## DFS与BFS

* DFS用的是stack堆，BFS用的是queue队列，dfs往下搜的时候只需要记录路径上的所有点，因此空间和高度成正比，BFS会把每一层都存下来，所需要的空间是指数级别
* 当所有边的权重相同的时候BFS第一次搜索到的点一定是最近的一个点，DFS不具有最短路性质
* 涉及到最小步数，最短距离，最少操作几次基本都是bfs
* 算法思路奇怪的一般都是dfs，或者对空间要求比较高的

![](/img/171445.jpg)

### DFS深度优先搜索



* 最重要的就是顺序，一般是树的形式
* 回溯一定要注意恢复现场
* 剪枝：提前判断当前方案是不是合法的，如果不合法可以不用往下走直接回溯
  * 最优解剪枝
  * 可行性剪枝

```c++
//全排列
#include <iostream>
using namespace std;
const int N =10;
int n;
int path[N];//路径数组 
bool st[N];//判断数字有没有被用过 ，初始值为0 
void dfs(int u){

     if(u==n){//当u=n说明已经遍历完毕 ，如果u<n说明还没有填完 
     	for(int i = 0;i<n;i++)
     		cout<<path[i]<<" ";//输出遍历路径 
     		cout<<endl;
     		return ;
	 }
    for(int i = 1;i<=n;i++)//遍历寻找没有被用过的数 
    	if(!st[i]){//!0=1即没有被用过 
    		path[u]=i;//把i填到当前位置
			st[i]=true; 
			dfs(u+1);//继续递归下一个数字 
			st[i]=false;//恢复现场，即将原本填的数字回到没有用过的状态 
		}
} 
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n;
	dfs(0);//u=0的时候位于第一层，即三个位置均为空，u=1位于第二层， 已经填入1or2or3
	return 0;
}
```

```c++
//n皇后
#include <iostream>
using namespace std;
const int N =20;
int n;
char g[N][N];
int path[N];
bool col[N],dg[N],udg[N];//col是行，dg是对角线，udg是反对角线 
void dfs(int u){
	if(u==n){
		for(int i = 0;i<n;i++)
			puts(g[i]);
			puts("");
			return ;
	}
	for(int i = 0;i<n;i++)
		if(!col[i]&&!dg[u+i]&&!udg[n-u+i])
		{
			g[u][i]='Q';
			col[i]=dg[u+i]=udg[n-u+i]=true;
			dfs(u+1);
			col[i]=dg[u+i]=udg[n-u+i]=false;
			g[u][i]='.';
		}
}
int main(){
	cin >>n;
	for(int i = 0;i<n;i++)
		for(int j = 0;j<n;j++)
			g[i][j]='.';
	dfs(0);
	return 0;
}
```

### BFS宽度优先搜索

![](/img/232551.jpg)

## 树和图的存储

* 树是无环连通图

* 有向图
  * 边有方向

* 无向图
  * 边没有方向

### 有向图

#### 邻接矩阵

```c++
g[a][b] 存储边a->b//如果有权重，g[a][b]就是权重，无权重就是布尔值，不能保存重边，只能保留一条，适合存储稠密图，时间复杂度为O(n)
```

#### 邻接表

每个节点上开一个表，存一个点可以走到哪个点，插入即找到点对应的单链表然后头插

```c++
// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N], e[2N], ne[2N], idx;

// 添加一条边a->b
void add(int a, int b)//插入a的邻边
{
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++ ;//h[a]是头结点，将a节点开头的第一条边变为当前边，idx移动到下一条边
}

// 初始化
idx = 0;
memset(h, -1, sizeof h);
//邻接表的输入
for(int i = 0;i<m;i++)
{
    int a,b;
    cin>> a >>b;
    add(a,b);
}
```

## 树与图的遍历

时间复杂度O(n+m)，n表示点数，m表示边数

### 深度优先遍历

```c++
bool st[N];
int dfs(int u)
{
    st[u] = true; // st[u] 表示点u已经被遍历过

    for (int i = h[u]; i != -1; i = ne[i])//遍历点的边
    {
        int j = e[i];//存储当前链表节点对应的图里面的点的编号
        if (!st[j]) dfs(j);//j没有被搜到，继续搜
    }
}
```

### 宽度优先遍历

```c++
queue<int> q;//初始化
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())//队列不空
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}

```

```c++
void bfs()
{
	int hh =0,tt=0;//定义队头队尾
    q[0]=1;//q的第一个元素起点
    memset(d,-1,sizeof d);//初始化距离，-1表示没有被遍历过
    d[1]=0;//第一个点遍历
    while(hh<=tt){//队列不空
        int t=q[hh++]//取到队头
            for(int i = h[t];i!=-1;i=e[i])//拓展队头
            {
                int j =e[i];//拓展到队头连接的下一个点
                
            }
    }
}
```



## 树与图的遍历：拓扑排序

时间复杂度O(n+m)，n表示点数，m表示边数

```c++
int n,m;
int h[N],e[N],ne[N],idx;
int d[N],q[N];

bool topsort()
{
    int hh = 0, tt = -1;

    // d[i] 存储点i的入队
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}

```

## 最短路

## 最小生成树

## 二分图：染色法、匈牙利算法