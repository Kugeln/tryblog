---
title: 贪心
date: 2024-03-30 02:15:00
tags: 算法
sticky: 106
categories: 算法
banner_img: /img/1920x1080 (4).jpg
index_img: /img/1920x1080 (4).jpg
---

## 区间

### 区间选点

* 将每个区间按照右端点从小到大排序

* 从前往后依次枚举每个区间
  * 如果当前区间中已经包含点，则直接pass
  * 否则选择当前区间的右端点

```c++
#include <iostream>
#include <algorithm>
using namespace std;
const int N=100010;
int n;
struct Range{
    int l,r;
    bool operator< (const Range &w)const 
    {
        return r<w.r;
    }
}range[N];
int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        int l,r;
        cin >> l>>r;
        range[i]={l,r};
    }
    sort(range,range+n);
    int res=0,ed = -2e9;
    for(int i=0;i<n;i++)
        if(range[i].l>ed){
            res++;
            ed=range[i].r;
        }
    cout<<res;
    return 0;
}
```

### 区间分组

![](/img/112737.jpg)

```c++
#include <iostream>
#include <algorithm>
using namespace std;
const int N=100010;
int n;
struct Range{
    int l,r;
    bool operator< (const Range &w)const 
    {
        return l<w.l;
    }
}range[N];
int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        int l,r;
        cin >> l>>r;
        range[i]={l,r};
    }
    sort(range,range+n);
  priority_queue<int,vector<int>,greater<int>> heap;
    for(int i=0;i<n;i++)
        auto r=range[i];
    if(heap.empty()||heap.top()>=r.l) heap.push(r);
    else {
        int t=heap.top();
        heap.top();
        heap.push(r,r);
    }
        }
    cout<<heap.size();
    return 0;
}
```

### 区间覆盖