---
title: 计组强化大题
date: 2025-05-22 20:42:08
tags: 408日常
sticky: 268
banner_img: /img/1920x1080 (36).jpg
index_img: /img/1920x1080 (36).jpg
---

## 概览

![](/img/lwqecuoiqc.png)

![](/img/dsvtasvtwe.png)

* 数据的表示和运算计算量比较大，其他的计算量较小
* 存储系统是计组最重要的章节

![](/img/awercewacrw.png)

* 一条指令的执行过程是第五章CPU的内容
* 指令序列的工作过程是指令序列的内容
* 第四章第五章中间可能还会穿插着指令流水线
* 计组一定要吃透历年真题

## 存储系统串讲

### 地址变换过程

#### 框架

* 程序主要由一系列指令和数据组成，指令控制着程序运行的逻辑，而数据是指令运行过程中需要的一些内容

  * 比如手机游戏如果遇到一个npc，那么手机就需要加载这个npc的数据资源，需要从手机的外存里面，对应的数据当中读取出这个npc的模型
  * 这个3d模型会从外存中被加载到主存（内存），然后cpu会把内存当中这个3d模型的数据进行渲染，在cpu进行计算后会直到这个模型在显示器上应该显示成什么样子，最终cpu计算完之后会转换成像素的信息，然后显示在手机上

* 安装的这个APP可能有3GB，指令可能占了1GB，数据占了2GB，这些都是安装在外存里面的

  * 当启动APP以后，数据被加载到内存里面

  * 操作系统先会建立这个APP的进程，这个进程的大小取决于操作系统的位数

    * 比如说操作系统是32位的，那么它的一个进程，虚拟地址空间/逻辑地址（VA）总共占32位，2^32=4G，每个地址对应一个字节，所以32位的操作系统启动一个进程，这个进程的大小就是4GB
    * 所以虽然这个APP本身只有3GB的大小，但是当它启动在一个32位的操作系统之上的时候，它总共会有4GB的虚拟地址空间
    * 但我们不需要把全部的指令和数据都加载到内存当中，这个4GB是最大的虚拟地址空间的大小，也就是APP进程启动后，最大会占4GB的内存，但是事实上进程一般来说不用占那么多的地址空间，实际占个1GB就差不多了，数据和指令在需要的时候调入
      * 比如我在地图一进行游玩，不需要把地图二地图三的数据调入，等到我进入地图二再把地图二调入，启动游戏时候的loading，正在加载资源或者游戏场景，就是把相关的数据和指令从外存调入内存的的过程
      * 当我们在野外遇到一个全新的npc的时候，这个npc的模型资源还没有调入内存，但我们又需要使用这个npc的资源的时候，就会发生缺页（实际反馈就是卡顿）
      * npc的资源保存在外存里面，需要加载但是还没有调入内存就发生了缺页，那就会进入缺页异常的处理逻辑，就会调页，调页之后重新刷新，加载，渲染到屏幕上
    * 对于一个32位的虚拟地址空间来说，并不是全部都要用到，很多部分都是空闲的，有需要才会使用

    ![](/img/195632.jpg)

* 虚拟地址空间的1GB放到物理内存里面

  * 这1GB的数据和数据会被拆分成页，离散地放到内存当中的各个位置，只要确定一个页的大小，就可以确定1GB的指令和数据会被拆分成多少个页

* 虚拟地址(VA)到物理地址(PA)的转换，需要查页表，查页表才知道虚拟地址对应的物理地址

  * 操作系统管理一个数据结构叫页表，操作系统会管理这个进程的页表，而页表指明了这个进程的某一个虚拟地址和物理地址之间的对应关系

* 计算机的本质就是执行程序，而执行程序的过程无非就是不断地重复取指令和执行指令，取指令的指令就放在程序计数器（PC）当中

  * 程序计数器存储的CPU要执行的下一条指令的虚拟地址
  * 当APP启动的时候，首先会把某一些即将执行的指令，还有某一些即将用到的数据，给调入到内存当中，同时，操作系统会给这个进程建立一个4GB的虚拟地址空间，这个APP启动的时候要执行的第一条指令的虚拟地址，就直接放到CPU的PC计数器里面，然后去找到接下来要执行的那条指令
    * 指令访问的过程中，可能会访问到某一些数据
      * 参考指令的寻址方式
      * 指令需要的数据可能来自于寄存器，也可能是立即数，也有可能来自于内存
  * 如果这条指令访问的数据存储在内存中，这个数据需要去内存中去找，但是这个指令内部，只知道这个数据存储在哪个虚拟地址当中（进程的第x个字节），因此当指令要访问这个数据的时候，也需要把这个虚拟地址转换成物理地址，也就是需要去查页表，最终得到一个物理地址，在这个物理地址当中的某一个页里面找到这个数据的实际内容

* 访问主存或者说访问某一个虚拟地址的两个主要事件

  * 取指令的时候根据PC所指的虚拟地址，取出指令的时候，需要把它转换成物理地址，再从内存当中取出该条指令
  * 在执行指令的过程中，需要的数据可能在主存里，指令内部只知道数据存储的虚拟地址，需要把虚拟地址转换成物理地址，然后再去主存当中找到这个指令要处理的数据，然后从内存取到CPU，然后CPU再根据指令的功能对数据进行处理
  * 因此无论是取指令还是执行指令过程中，都可能涉及虚拟地址转换成物理地址的一个过程

* CPU从哪里直到这个数据的虚拟地址

  * 指令的地址码
    * 指令由操作码字段和地址码字段构成
      * 操作码指明了指令的功能
      * 地址码则指明了这条指令要处理的数据存储在什么地方
  * 下一条执行的指令存储在PC中，然后它会被取到IR指令寄存器当中（正在执行的指令），通过IR，CPU可以清楚的知道指令的操作码和地址码是什么，如果地址码字段的寻址方式指出数据在内存当中，那么地址码就会指出数据的虚拟地址VA
  * 然后通过查页表将VA转换成PA，然后再从内存里找到指令所需要的数据

#### 地址转换

![](/img/211018.jpg)

* 虚拟地址的位数就是虚拟地址的位数
* Cache是CPU内部的高速存储器，不属于操作系统的范畴，是硬件自动实现的内容，不是操作系统去实现的内容
* MAR里面存储的是物理地址
  * 只有把虚拟地址转换成物理地址之后，最终准备好要访存的时候，才会被写进MAR里面
* 虚拟地址到物理地址的转换需要经过一个部件，MMU（内存管理单元），经过MMU的处理，它会把VA转换为PA，然后PA会放进MAR寄存器（逻辑上也从属于MMU）里面
* 页表存储在内存里面，但因为内存查询起来比较慢，所以内存里面的页表被称为慢表
  * 而为了让这个页表查询起来更快，TLB快表存储在CPU内（逻辑上属于MMU），硬件实现，在CPU内部就可以实现虚拟地址和物理地址的转换
  * 根据虚拟地址去查TLB，如果快表命中，可以直接得到物理地址，不用去访问内存里面的慢表
* CPU如何判断当前正在执行的这个进程，页表在内存中的存储位置？
  * 页表始址寄存器（逻辑上属于MMU），指明了当前正在运行的这个进程的页表始址，它的页表在内存里存储在什么地方，直接指明页表在内存当中起始的物理地址
    * 只要知道起始地址，同时知道虚拟地址的页号，也知道页表项的长度，结合起来就能得到页号对应的页表项，然后就可以把这个页表项加载到TLB当中
    * 查到页表项之后，既知道了我的这个虚拟地址对应的物理页框号等于多少，同时我也会把这个页表项的内容复制一份到TLB当中，下一次想要访问同一个页框或者同一个页面的时候，就可以直接从TLB命中
    * 页框是物理内存中划分出来的固定大小的存储区域
    * 页面是逻辑地址空间划分出来的固定大小的单元，页框和页面大小相等
* CPU的页表始址寄存器里面的值从哪里来的？
  * 来自于PCB进程控制块
    * 操作系统会给每个进程建立一个数据结构叫做进程控制块PCB
      * 而这个进程控制块里面就有一个变量记录了这个进程的页表始址
    * 当一个进程被调度的时候，这个进程即将上处理机运行的时候，操作系统会把PCB里面的这个页表始址写到CPU的页表始址寄存器里面
      * 这样的话，当这个进程正在运行的时候，CPU可以直接根据页表始址寄存器里的值，直接找到页表的存储位置
    * 如果再换一个进程运行，那么我再从另一个PCB当中找到另一个进程的页表始址寄存器，页表始址再把这个值覆盖

![](/img/0000001.png)

* 无论是查快表还是慢表，最终要得到的就是物理页框号
* 物理页框号拼接页内偏移量得到完整的物理地址存储在MAR里面

![](/img/0000002.png)

#### 地址转换：查一级页表

![](/img/00003.png)

* 每一个页表项多少个字节，由操作系统和CPU决定，通常和CPU有关，只要确定了CPU的型号，基本上就确定了一个页表项
* 页号是隐含的，只需要确保页表项在内存中连续存储
* 首先要检查页表的有效位，有效位为1意味着页面此时是在内存里面的，没有缺页，有效位为0，则意味着缺页，缺页的时候需要从外存把页面的数据调进来
  * 页表项中会保存这个页面在外存当中的地址，如果有效位为0，发生缺页，操作系统就可以根据这个信息去外存当中找到缺失的页面，然后调入内存，更新这个页表项
* 一个进程的页表在内存当中必须是物理上连续存放的，虽然这个页表可能很长，但是为了支持根据页表起始地址和页号找到目标页表项，必须保证这些页表项在物理上是连续的

#### 地址转换：全相联TLB命中+不用查页表

![](/img/0000004.png)

* 快表为什么很快？
  * 采用比较器（异或门元器件）
    * 当且仅当每一bit都相同的时候结果全0，结果全部取非然后相与，只有所有的位都是1，结果才会是1，结果为1说明两者完全一致
    * 如果有一个位不一致，则结果存在一个1，然后取非出现一个0，最后相与结果必为0，所以不一致
* 每一个TLB表项对应的就是一个TLB寄存器，虚拟地址和TLB的比较，就是比较器电路全部连接到每一个TLB寄存器的标记位，只有虚拟地址的页框号和TLB的标记能够完全匹配的时候，这一行TLB才会被选中
* 选中的逻辑电路设计
  * 匹配成功得到信号1（比较器产生的信号），这个信号可以控制一个三态门，只有匹配的TLB寄存器才能被选通
  * 标记为和有效位再进行一个相与，然后把这个相与的信号作为刚才提到的这个TLB寄存器的三态门的选通信号，这就可以实现TLB的迅速并行比较，迅速获得想要的页框号
* 查页表的时候有可能发生有效位为0的情况
  * 有效位为0，说明这个页表一定是缺页的
* 如果快表命中，快表的有效位等于1，标记位也可以匹配得上，不可能缺页
  * 页面置换的时候，由一些页面可能被换到外存，换到外存之后，这个页面的有效位就从1修改为0，同时记录这个页面在外存当中存储的地址
    * 操作系统同时也会通知CPU让他把这个页表项的有效位置为0，也就是说当页面换出的时候，TLB的表项肯定也会跟着一起失效
  * 因此只要TLB命中一定不会缺页，TLB不命中查页表的时候，才有可能缺页

#### 地址转换：全相联TLB未命中+查一级页表

![](/img/000000005.png)

* 查慢表
  * 根据页表始址寄存器去找页表的起始地址
  * 根据每一个页表项的大小，结合页号，然后在内存当中找到要的页表项，也后确定它的页框，把他的页框放到MAR寄存器前页框号位，拼接页内偏移量得到物理地址

#### 地址转换：查二级页表

![](/img/00000000006.png)

* n级页表下虚拟地址的页框号被拆分为n段
* 以当前2级页表为例，高12位被用于查一级页表，CPU内部会记录第一级页表的起始地址，根据一级页号找到对应的页表项
  * 假设二级页表有效位为1，说明二级页表没有缺页，已经调入了内存，那么就可以知道二级页表在内存的哪个位置（这里的页框号对应的是二级页表在内存当中的起始物理地址）
    * 比如这张图中的11111H页框号代表二级页表存储在11111H这个页框里面，确认的是二级页表的起始存储地址
  * 知道二级页表的起始地址，再结合二级页表的这个页号，找到对应的页表项，然后有效位等于1代表没有缺页，找到页框号后把页框号读到MAR的高20位，再把低12位直接从这个虚拟地址那边拿过来
* 但是，当查到二级页表的页框号的时候，保存在TLB的时候，应该保存完整的虚拟页号985211H，而不是单纯的211H
* 无论是几级页表，虽然当我们在查慢表的时候会一级一级拆分页号进行查询，但只要我们命中了某一个页表项，并把这个页表项存储到TLB当中的时候，我们需要保存这个页表项对应的完整的所有的每一级页号，而不是只保存最后一级
  * CPU内部查TLB的时候，把整个虚拟页号作为一个整体，没有分级，作为一个整体去和全相联的表项对比

#### 地址转换：全相联TLB未命中+查二级页表

![](/img/00000000000007.png)

#### 地址转换：全相联TLB命中+不用查页表

![](/img/00000000008.png)

#### 地址转换：4路组相联TLB命中+不用查页表

![](/img/000000000009.png)

* 对TLB的表项进行分组，x路组相联就是x个页表项一组
* 对虚拟页号进行拆分，如果有2^n个TLB组，则组号占n位，在地址低位，剩余的地址高位是TLB标记
  * 如果采用全相联映射，则TLB标记页虚拟页号完全已知，如果是组相联，则是排除组号的地址高位

#### 访问物理地址：全相联Cache命中+不用访问主存

![](/img/0000000000010.png)

* 得到了物理地址说明页面一定已经在内存里了
  * 如果页面不在内存里会发生缺页，并且调页，然后再进行一次地址转换
* 如果没有Cache，直接根据这个物理地址，直接根据MAR指明的地址，直接去访问内存，读出这个地址对应的数据
* 根据Cache的映射方式的不同，要对物理地址进行不同的拆分
  * 全相联映射
    * 没有行号也没有组号，直接Cache标记和每一个Cache行的标记进行对比
    * Cache块的大小转为2^nB，然后n就是字块内地址所占的位数也就是最后n位，剩余的高位就是Cache块的标记
    * 用Cache标记去和Cache里面的Cache行进行比较，如果能完全匹配并且有效位为1
  * 直接相联映射
    * 有行号
    * 相当于1路组相联映射
    * 拆分成三个结构
      * 字块内地址，同上
      * 行号，看直接映射的情况下整个Cache有多少行，然后转化为2^n行，n就是行号所占的地址数量，位于中间
      * Cache标记，除了行号和字块内地址以外的最高位
  * 组相联映射
    * 有组号
* 访问到的数据会存储到MDR当中，然后MDR再把这个数据给到CPU，如果是指令，会放到IR指令寄存器当中，如果是数据，则可能放到CPU的某个通用寄存器当中
* Cache块的大小和页的大小不一样的
  * 408里面一个内存块的大小等于一个Cache块的大小
  * Cache块的大小一般来说要远远小于一个页的大小

#### 访问物理地址：全相联Cache未命中+访问主存

![](/img/00000000011.png)

* Cache标记位匹配不上和匹配上了但是有效位为0都是Cache未命中的情况

#### 访问物理地址：直接映射Cache命中+不用访问主存

![](/img/00000000012.png)

* 直接相联映射
  * 有行号
  * 拆分成三个结构
    * 字块内地址，同上
    * 行号，看直接映射的情况下整个Cache有多少行，然后转化为2^n行，n就是行号所占的地址数量，位于中间
    * Cache标记，除了行号和字块内地址以外的最高位
  * 根据行号找到对应的行，行号匹配以后去对比Cache标记，如果Cache标记匹配+有效位为1，那么Cache命中，可以直接从Cache块中根据字块内地址读取数据，读到MDR当中

#### 访问物理地址：直接映射Cache未命中+访问主存

![](/img/00000013.png)

#### 访问物理地址：2路组相联Cache命中+不用访问主存

![](/img/00000000014.png)

* 组相联映射
  * 有组号
  * x路组相联映射的意思是每组有X个Cache行
  * Cache标记+组号+字块内地址
    * 字块内地址同上
    * 组号是一共有2^n组，组号占n位
    * 剩余的高位是Cache标记
* 根据组号找到对应的分组，然后对比组内各Cache行的Cache标记和地址的Cache标记，匹配上以后对比有效位
* Cache行和Cache块不是一个东西
  * Cache行包括了Cache的标记位，有效位，替换位等辅助控制信息，再加上Cache块的数据，而Cache块指的就是主存数据的副本，也就是64B本身

#### 访问物理地址：2路组相联Cache未命中+访问主存

![](/img/000000000015.png)

### 三种映射方式的电路图

![](/img/ifokdsajkfjose.png)

* 图中中间的8个bit对应组号
  * 组号连接的折线表示8个bit可以命中某一个分组，这一个分组当中包含了4个Cache行
* 高22bit对应的是Cache的标记位
  * 标记对应的折线，最下面连接了4个比较器（⭕+＝）（用异或门，非门实现的东西）
  * 每一个Cache行当中都有tag标记位，每一个Cache行都会把这22个标记位和刚才我们要访问的这个物理地址的tag信息进行对比
  * v是有效位，有效位和TLBCache行标记位和地址标记位比较的结果输入与门的两端进行相与，产生的结果输入到最末端的四路选择器（多路选择器）
  * 四个Cache块的数据直接连到多路选择器当中，当上述步骤产生了1信号以后，会把对应Cache块的信号选通，让其通过多路选择器，然后就得到了一整个Cache块
  * 这个Cache块结合字块内地址，就可以找到想要的数据