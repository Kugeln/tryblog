---
title: 计组强化大题
date: 2025-05-22 20:42:08
tags: 408日常
sticky: 268
banner_img: /img/1920x1080 (37).jpg
index_img: /img/1920x1080 (37).jpg
---

## 概览

![](/img/lwqecuoiqc.png)

![](/img/dsvtasvtwe.png)

* 数据的表示和运算计算量比较大，其他的计算量较小
* 存储系统是计组最重要的章节

![](/img/awercewacrw.png)

* 一条指令的执行过程是第五章CPU的内容
* 指令序列的工作过程是指令序列的内容
* 第四章第五章中间可能还会穿插着指令流水线
* 计组一定要吃透历年真题

## 存储系统串讲

### 地址变换过程

#### 框架

* 程序主要由一系列指令和数据组成，指令控制着程序运行的逻辑，而数据是指令运行过程中需要的一些内容

  * 比如手机游戏如果遇到一个npc，那么手机就需要加载这个npc的数据资源，需要从手机的外存里面，对应的数据当中读取出这个npc的模型
  * 这个3d模型会从外存中被加载到主存（内存），然后cpu会把内存当中这个3d模型的数据进行渲染，在cpu进行计算后会直到这个模型在显示器上应该显示成什么样子，最终cpu计算完之后会转换成像素的信息，然后显示在手机上

* 安装的这个APP可能有3GB，指令可能占了1GB，数据占了2GB，这些都是安装在外存里面的

  * 当启动APP以后，数据被加载到内存里面

  * 操作系统先会建立这个APP的进程，这个进程的大小取决于操作系统的位数

    * 比如说操作系统是32位的，那么它的一个进程，虚拟地址空间/逻辑地址（VA）总共占32位，2^32=4G，每个地址对应一个字节，所以32位的操作系统启动一个进程，这个进程的大小就是4GB
    * 所以虽然这个APP本身只有3GB的大小，但是当它启动在一个32位的操作系统之上的时候，它总共会有4GB的虚拟地址空间
    * 但我们不需要把全部的指令和数据都加载到内存当中，这个4GB是最大的虚拟地址空间的大小，也就是APP进程启动后，最大会占4GB的内存，但是事实上进程一般来说不用占那么多的地址空间，实际占个1GB就差不多了，数据和指令在需要的时候调入
      * 比如我在地图一进行游玩，不需要把地图二地图三的数据调入，等到我进入地图二再把地图二调入，启动游戏时候的loading，正在加载资源或者游戏场景，就是把相关的数据和指令从外存调入内存的的过程
      * 当我们在野外遇到一个全新的npc的时候，这个npc的模型资源还没有调入内存，但我们又需要使用这个npc的资源的时候，就会发生缺页（实际反馈就是卡顿）
      * npc的资源保存在外存里面，需要加载但是还没有调入内存就发生了缺页，那就会进入缺页异常的处理逻辑，就会调页，调页之后重新刷新，加载，渲染到屏幕上
    * 对于一个32位的虚拟地址空间来说，并不是全部都要用到，很多部分都是空闲的，有需要才会使用

    ![](/img/195632.jpg)

* 虚拟地址空间的1GB放到物理内存里面

  * 这1GB的数据和数据会被拆分成页，离散地放到内存当中的各个位置，只要确定一个页的大小，就可以确定1GB的指令和数据会被拆分成多少个页

* 虚拟地址(VA)到物理地址(PA)的转换，需要查页表，查页表才知道虚拟地址对应的物理地址

  * 操作系统管理一个数据结构叫页表，操作系统会管理这个进程的页表，而页表指明了这个进程的某一个虚拟地址和物理地址之间的对应关系

* 计算机的本质就是执行程序，而执行程序的过程无非就是不断地重复取指令和执行指令，取指令的指令就放在程序计数器（PC）当中

  * 程序计数器存储的CPU要执行的下一条指令的虚拟地址
  * 当APP启动的时候，首先会把某一些即将执行的指令，还有某一些即将用到的数据，给调入到内存当中，同时，操作系统会给这个进程建立一个4GB的虚拟地址空间，这个APP启动的时候要执行的第一条指令的虚拟地址，就直接放到CPU的PC计数器里面，然后去找到接下来要执行的那条指令
    * 指令访问的过程中，可能会访问到某一些数据
      * 参考指令的寻址方式
      * 指令需要的数据可能来自于寄存器，也可能是立即数，也有可能来自于内存
  * 如果这条指令访问的数据存储在内存中，这个数据需要去内存中去找，但是这个指令内部，只知道这个数据存储在哪个虚拟地址当中（进程的第x个字节），因此当指令要访问这个数据的时候，也需要把这个虚拟地址转换成物理地址，也就是需要去查页表，最终得到一个物理地址，在这个物理地址当中的某一个页里面找到这个数据的实际内容

* 访问主存或者说访问某一个虚拟地址的两个主要事件

  * 取指令的时候根据PC所指的虚拟地址，取出指令的时候，需要把它转换成物理地址，再从内存当中取出该条指令
  * 在执行指令的过程中，需要的数据可能在主存里，指令内部只知道数据存储的虚拟地址，需要把虚拟地址转换成物理地址，然后再去主存当中找到这个指令要处理的数据，然后从内存取到CPU，然后CPU再根据指令的功能对数据进行处理
  * 因此无论是取指令还是执行指令过程中，都可能涉及虚拟地址转换成物理地址的一个过程

* CPU从哪里直到这个数据的虚拟地址

  * 指令的地址码
    * 指令由操作码字段和地址码字段构成
      * 操作码指明了指令的功能
      * 地址码则指明了这条指令要处理的数据存储在什么地方
  * 下一条执行的指令存储在PC中，然后它会被取到IR指令寄存器当中（正在执行的指令），通过IR，CPU可以清楚的知道指令的操作码和地址码是什么，如果地址码字段的寻址方式指出数据在内存当中，那么地址码就会指出数据的虚拟地址VA
  * 然后通过查页表将VA转换成PA，然后再从内存里找到指令所需要的数据

#### 地址转换

![](/img/211018.jpg)

* 虚拟地址的位数就是虚拟地址的位数
* Cache是CPU内部的高速存储器，不属于操作系统的范畴，是硬件自动实现的内容，不是操作系统去实现的内容
* MAR里面存储的是物理地址
  * 只有把虚拟地址转换成物理地址之后，最终准备好要访存的时候，才会被写进MAR里面
* 虚拟地址到物理地址的转换需要经过一个部件，MMU（内存管理单元），经过MMU的处理，它会把VA转换为PA，然后PA会放进MAR寄存器（逻辑上也从属于MMU）里面
* 页表存储在内存里面，但因为内存查询起来比较慢，所以内存里面的页表被称为慢表
  * 而为了让这个页表查询起来更快，TLB快表存储在CPU内（逻辑上属于MMU），硬件实现，在CPU内部就可以实现虚拟地址和物理地址的转换
  * 根据虚拟地址去查TLB，如果快表命中，可以直接得到物理地址，不用去访问内存里面的慢表
* CPU如何判断当前正在执行的这个进程，页表在内存中的存储位置？
  * 页表始址寄存器（逻辑上属于MMU），指明了当前正在运行的这个进程的页表始址，它的页表在内存里存储在什么地方，直接指明页表在内存当中起始的物理地址
    * 只要知道起始地址，同时知道虚拟地址的页号，也知道页表项的长度，结合起来就能得到页号对应的页表项，然后就可以把这个页表项加载到TLB当中
    * 查到页表项之后，既知道了我的这个虚拟地址对应的物理页框号等于多少，同时我也会把这个页表项的内容复制一份到TLB当中，下一次想要访问同一个页框或者同一个页面的时候，就可以直接从TLB命中
    * 页框是物理内存中划分出来的固定大小的存储区域
    * 页面是逻辑地址空间划分出来的固定大小的单元，页框和页面大小相等
* CPU的页表始址寄存器里面的值从哪里来的？
  * 来自于PCB进程控制块
    * 操作系统会给每个进程建立一个数据结构叫做进程控制块PCB
      * 而这个进程控制块里面就有一个变量记录了这个进程的页表始址
    * 当一个进程被调度的时候，这个进程即将上处理机运行的时候，操作系统会把PCB里面的这个页表始址写到CPU的页表始址寄存器里面
      * 这样的话，当这个进程正在运行的时候，CPU可以直接根据页表始址寄存器里的值，直接找到页表的存储位置
    * 如果再换一个进程运行，那么我再从另一个PCB当中找到另一个进程的页表始址寄存器，页表始址再把这个值覆盖

![](/img/0000001.png)

* 无论是查快表还是慢表，最终要得到的就是物理页框号
* 物理页框号拼接页内偏移量得到完整的物理地址存储在MAR里面

![](/img/0000002.png)

#### 地址转换：查一级页表

![](/img/00003.png)

* 每一个页表项多少个字节，由操作系统和CPU决定，通常和CPU有关，只要确定了CPU的型号，基本上就确定了一个页表项
* 页号是隐含的，只需要确保页表项在内存中连续存储
* 首先要检查页表的有效位，有效位为1意味着页面此时是在内存里面的，没有缺页，有效位为0，则意味着缺页，缺页的时候需要从外存把页面的数据调进来
  * 页表项中会保存这个页面在外存当中的地址，如果有效位为0，发生缺页，操作系统就可以根据这个信息去外存当中找到缺失的页面，然后调入内存，更新这个页表项
* 一个进程的页表在内存当中必须是物理上连续存放的，虽然这个页表可能很长，但是为了支持根据页表起始地址和页号找到目标页表项，必须保证这些页表项在物理上是连续的

#### 地址转换：全相联TLB命中+不用查页表

![](/img/0000004.png)

* 快表为什么很快？
  * 采用比较器（异或门元器件）
    * 当且仅当每一bit都相同的时候结果全0，结果全部取非然后相与，只有所有的位都是1，结果才会是1，结果为1说明两者完全一致
    * 如果有一个位不一致，则结果存在一个1，然后取非出现一个0，最后相与结果必为0，所以不一致
* 每一个TLB表项对应的就是一个TLB寄存器，虚拟地址和TLB的比较，就是比较器电路全部连接到每一个TLB寄存器的标记位，只有虚拟地址的页框号和TLB的标记能够完全匹配的时候，这一行TLB才会被选中
* 选中的逻辑电路设计
  * 匹配成功得到信号1（比较器产生的信号），这个信号可以控制一个三态门，只有匹配的TLB寄存器才能被选通
  * 标记为和有效位再进行一个相与，然后把这个相与的信号作为刚才提到的这个TLB寄存器的三态门的选通信号，这就可以实现TLB的迅速并行比较，迅速获得想要的页框号
* 查页表的时候有可能发生有效位为0的情况
  * 有效位为0，说明这个页表一定是缺页的
* 如果快表命中，快表的有效位等于1，标记位也可以匹配得上，不可能缺页
  * 页面置换的时候，由一些页面可能被换到外存，换到外存之后，这个页面的有效位就从1修改为0，同时记录这个页面在外存当中存储的地址
    * 操作系统同时也会通知CPU让他把这个页表项的有效位置为0，也就是说当页面换出的时候，TLB的表项肯定也会跟着一起失效
  * 因此只要TLB命中一定不会缺页，TLB不命中查页表的时候，才有可能缺页

#### 地址转换：全相联TLB未命中+查一级页表

![](/img/000000005.png)

* 查慢表
  * 根据页表始址寄存器去找页表的起始地址
  * 根据每一个页表项的大小，结合页号，然后在内存当中找到要的页表项，也后确定它的页框，把他的页框放到MAR寄存器前页框号位，拼接页内偏移量得到物理地址

#### 地址转换：查二级页表

![](/img/00000000006.png)

* n级页表下虚拟地址的页框号被拆分为n段
* 以当前2级页表为例，高12位被用于查一级页表，CPU内部会记录第一级页表的起始地址，根据一级页号找到对应的页表项
  * 假设二级页表有效位为1，说明二级页表没有缺页，已经调入了内存，那么就可以知道二级页表在内存的哪个位置（这里的页框号对应的是二级页表在内存当中的起始物理地址）
    * 比如这张图中的11111H页框号代表二级页表存储在11111H这个页框里面，确认的是二级页表的起始存储地址
  * 知道二级页表的起始地址，再结合二级页表的这个页号，找到对应的页表项，然后有效位等于1代表没有缺页，找到页框号后把页框号读到MAR的高20位，再把低12位直接从这个虚拟地址那边拿过来
* 但是，当查到二级页表的页框号的时候，保存在TLB的时候，应该保存完整的虚拟页号985211H，而不是单纯的211H
* 无论是几级页表，虽然当我们在查慢表的时候会一级一级拆分页号进行查询，但只要我们命中了某一个页表项，并把这个页表项存储到TLB当中的时候，我们需要保存这个页表项对应的完整的所有的每一级页号，而不是只保存最后一级
  * CPU内部查TLB的时候，把整个虚拟页号作为一个整体，没有分级，作为一个整体去和全相联的表项对比

#### 地址转换：全相联TLB未命中+查二级页表

![](/img/00000000000007.png)

#### 地址转换：全相联TLB命中+不用查页表

![](/img/00000000008.png)

#### 地址转换：4路组相联TLB命中+不用查页表

![](/img/000000000009.png)

* 对TLB的表项进行分组，x路组相联就是x个页表项一组
* 对虚拟页号进行拆分，如果有2^n个TLB组，则组号占n位，在地址低位，剩余的地址高位是TLB标记
  * 如果采用全相联映射，则TLB标记页虚拟页号完全已知，如果是组相联，则是排除组号的地址高位

#### 访问物理地址：全相联Cache命中+不用访问主存

![](/img/0000000000010.png)

* 得到了物理地址说明页面一定已经在内存里了
  * 如果页面不在内存里会发生缺页，并且调页，然后再进行一次地址转换
* 如果没有Cache，直接根据这个物理地址，直接根据MAR指明的地址，直接去访问内存，读出这个地址对应的数据
* 根据Cache的映射方式的不同，要对物理地址进行不同的拆分
  * 全相联映射
    * 没有行号也没有组号，直接Cache标记和每一个Cache行的标记进行对比
    * Cache块的大小转为2^nB，然后n就是字块内地址所占的位数也就是最后n位，剩余的高位就是Cache块的标记
    * 用Cache标记去和Cache里面的Cache行进行比较，如果能完全匹配并且有效位为1
  * 直接相联映射
    * 有行号
    * 相当于1路组相联映射
    * 拆分成三个结构
      * 字块内地址，同上
      * 行号，看直接映射的情况下整个Cache有多少行，然后转化为2^n行，n就是行号所占的地址数量，位于中间
      * Cache标记，除了行号和字块内地址以外的最高位
  * 组相联映射
    * 有组号
* 访问到的数据会存储到MDR当中，然后MDR再把这个数据给到CPU，如果是指令，会放到IR指令寄存器当中，如果是数据，则可能放到CPU的某个通用寄存器当中
* Cache块的大小和页的大小不一样的
  * 408里面一个内存块的大小等于一个Cache块的大小
  * Cache块的大小一般来说要远远小于一个页的大小

#### 访问物理地址：全相联Cache未命中+访问主存

![](/img/00000000011.png)

* Cache标记位匹配不上和匹配上了但是有效位为0都是Cache未命中的情况

#### 访问物理地址：直接映射Cache命中+不用访问主存

![](/img/00000000012.png)

* 直接相联映射
  * 有行号
  * 拆分成三个结构
    * 字块内地址，同上
    * 行号，看直接映射的情况下整个Cache有多少行，然后转化为2^n行，n就是行号所占的地址数量，位于中间
    * Cache标记，除了行号和字块内地址以外的最高位
  * 根据行号找到对应的行，行号匹配以后去对比Cache标记，如果Cache标记匹配+有效位为1，那么Cache命中，可以直接从Cache块中根据字块内地址读取数据，读到MDR当中

#### 访问物理地址：直接映射Cache未命中+访问主存

![](/img/00000013.png)

#### 访问物理地址：2路组相联Cache命中+不用访问主存

![](/img/00000000014.png)

* 组相联映射
  * 有组号
  * x路组相联映射的意思是每组有X个Cache行
  * Cache标记+组号+字块内地址
    * 字块内地址同上
    * 组号是一共有2^n组，组号占n位
    * 剩余的高位是Cache标记
* 根据组号找到对应的分组，然后对比组内各Cache行的Cache标记和地址的Cache标记，匹配上以后对比有效位
* Cache行和Cache块不是一个东西
  * Cache行包括了Cache的标记位，有效位，替换位等辅助控制信息，再加上Cache块的数据，而Cache块指的就是主存数据的副本，也就是64B本身

#### 访问物理地址：2路组相联Cache未命中+访问主存

![](/img/000000000015.png)

### 三种映射方式的电路图

![](/img/ifokdsajkfjose.png)

* 图中中间的8个bit对应组号
  * 组号连接的折线表示8个bit可以命中某一个分组，这一个分组当中包含了4个Cache行
* 高22bit对应的是Cache的标记位
  * 标记对应的折线，最下面连接了4个比较器（⭕+＝）（用异或门，非门实现的东西）
  * 每一个Cache行当中都有tag标记位，每一个Cache行都会把这22个标记位和刚才我们要访问的这个物理地址的tag信息进行对比
  * v是有效位，有效位和TLBCache行标记位和地址标记位比较的结果输入与门的两端进行相与，产生的结果输入到最末端的四路选择器（多路选择器）
  * 四个Cache块的数据直接连到多路选择器当中，当上述步骤产生了1信号以后，会把对应Cache块的信号选通，让其通过多路选择器，然后就得到了一整个Cache块
  * 这个Cache块结合字块内地址，就可以找到想要的数据

### 存储系统真题

#### Cache的题目如何分析

* 考法
  * 虚拟地址转化为物理地址的过程
    * 涉及TLB查快表
    * 查慢表
  * 通过物理地址去访问Cache的过程
    * 静态分析
      * Cache的地址结构（PA拆分）
      * Cache行的完整构成
        * TAG标记位
        * 有效位
        * 脏位
        * LRU替换位
        * 数据位（Cache块）
    * 动态分析
      * 物理地址访问序列
        * Cache命中率
          * 命中的地址，不命中的地址
        * Cache的替换
        * 直接给物理地址序列
        * 数组元素访问（for循环）
          * 把对数组元素的访问，转化成对物理地址的访问
        * 以机器代码形式
          * 哪些时候取指令，哪些时候访问数组数据

![](/img/kdsacowe.png)

##### 第一类题型：分析Cache的地址结构

![](/img/satnbvt.png)

* 类型
  * 取决于映射方式
  * 直接映射
    * 三个部分
    * TAG标记+行号+块内地址
  * 组相联映射
    * 三个部分
    * TAG标记+组号+块内地址
  * 全相联映射
    * 两个部分
    * TAG标记+块内地址
* 读题的时候需要关注的条件
  * 物理地址的位数（机器字长）
  * Cache总行数
    * =数据区大小/Cache块大小
    * Cache数据区总大小是指Cache数据块大小之和，只包括数据部分
    * Cache总容量（总大小）≠Cache数据区总容量
    * 组数=Cache总行数/组相联路数
  * Cache块大小
    * 一般直接给出
  * 映射方式
    * 直接映射
    * 组相联
      * 关注路数，确定组数
    * 全相联
  * 先关注PA位数，再关注映射方式，接着关注Cache总行数和块大小，从后往前推，先确定块内地址，再确定行号和组号，最后确定TAG标记

##### 第二类题型：Cache行的完整构成

![](/img/zcjercoai.png)

* 读题时需要关注的条件
  * 物理地址位数
  * Cache总行数
  * Cache块大小
  * 映射方式
  * 写策略
    * 直写法
      * 修改Cache的同时页同步修改主存里的数据
      * 不需要脏位
    * 回写法
      * 先修改Cache里面的副本数据，暂时不会修改主存里的数据，只有当数据块从Cache里面淘汰调回主存的时候，才把整个数据块写回到主存
      * 需要1bit脏位
  * 替换算法
    * 随机算法
      * 不需要替换位
    * 其他
      * 需要替换位，位数取决于替换的范围，2^n个中替换，需要nbit替换位
        * 组相联=log2（路数）
        * 直接映射不需要替换位
      * 先进先出算法（FIFO）
      * 近期最少使用算法（LRU）
      * 最不经常使用算法（LFU)

* 构成
  * TAG
    * Cache地址高标记位
  * 有效位
    * 一定存在
    * 占1bit
    * 如果发生进程切换，有效位会发生巨大的变化，意味着Cache里面这些主存的副本数据是上一个进程的数据，当我们切换一个进程的时候，这个新进程的数据副本和上一个进程肯定是不一样的，因此切换进程的时候需要把Cache的所有有效位置为0
      * 一个软件刚开始的时候比较卡也是因为Cache最开始有效位全位0，Cache当中还没有填充进来，最开始一定会出现Cache缺失
  * 块内数据
    * 根据Cache块大小确定
  * 脏位
    * 写回法1bit
    * 直写法0bit
  * 替换信息位
    * 随机替换0bit
    * 其他 FIFO,LRU取决于范围
      * 直接映射0bit
      * 组相联log2路数bit
      * 全相联log2行数bit
        * 行数=Cache数据区总大小/Cache大小
  * 组号和行号实际上是隐含的，不需要占任何的bit

#### Cache大题实战

##### 2020

![](/img/ciawpeir.png)

* 思路
  * 主存地址32位→PA有32位
  * 8路组相联映射方式
  * 直写法
  * LRU替换算法
  * 主存块大小64B
  * 数据区容量32KB
    * 由主存块和数据区容量可以推出Cache总行数
  * 第一小问：Cache行的完整构成
  * 第二小问：动态分析PA访问序列，Cache命中率
    * 变量k分配在寄存器里面
      * 不用考虑变量k的访存，不涉及Cache的访问
    * 起始地址+数组
      * 告诉即将要访问的地址是哪几个
    * 主存块大小
      * 除了末尾的6bit之外，高位相同意味着这几个地址都从属于同一个Cache块
        * 第一次访问存在Cache缺失，之后Cache块被调入，之后访问同一块数据不会缺失
  * 第三小问：CPU访问Cache的操作
    * 根据映射方式拆分PA
    * 如果是直接映射，找到对应行号，组相联找到对应组号
    * 对比TAG标记位
    * 匹配上后检查有效位
    * 如果上述都匹配，命中
    * 缺失的话会把对应的主存块读到Cache里面，修改Cache行内部的tag标记有效位和LRU替换算法位，还有脏位

##### 2010

![](/img/eahrae.png)

![](/img/awheew.png)

* 条件
  * 主存地址空间大小256MB
    * 28bit
  * 8个Cache行，每个Cache行大小64B
    * 行号3bit，块内地址6bitt
  * 直接映射方式
  * int32位补码表示
    * 4B
  * i、j、sum分配在寄存器中
    * 三个变量不会涉及Cache访存
  * 数组a按行优先方式存放
    * 行遍历顺序
  * 首地址320
* 思路
  * 第一小问：Cache的总容量
  * 第二小问：访问的地址
    * 十进制转二进制，然后取出对应的位数
  * 第三小问：访问命中率

##### 2018

![](/img/opiaow.png)

![](/img/mzceoi.png)

* 条件
  * VA=20+12
  * PA=20+3+5
  * 全相联TLB
  * 二级页表
* 思路
  * VA→PA→Cache
  * PA分成三个部分→要么是组相联，要么是直接映射
  * 一个组号指向两个Cache行→组相联映射

##### 2023

![](/img/aefwc.png)

![](/img/dsafawef.png)

#### TLB的题目如何分析

![](/img/ucpwiqeuor.png)

* 关注
  * VA多少位，虚页号多少位？
    * 页号+页内地址
  * TLB的映射方式
    * 全相联
    * 组相联映射
      * k路
    * 直接相联很容易出现抖动现象，效率低，一般不出现
  * 替换算法
    * 同Cache
    * 可能出现替换信息位
* 所有涉及到TLB的题目，一定要关注虚页号如何拆分的问题
* 每个TLB行（表项）完整构成：
  * TAG
    * 组相联
      * 虚页号除了末尾log2（组数）的最高位
    * 全相联
      * 虚页号
  * 有效位
    * 一定存在1bit
  * 页框号
    * 看页框数量（物理页框，要拼接在页内偏移量前面形成PA的）
  * 替换信息位
    * 看TLB替换算法
      * 随机
        * 0bit
      * 其他
        * 组相联
          * log2（路数）
        * 全相联
          * log2（总行数）

#### TLB大题实战

![](/img/aweebwrrr.png)

* 条件
  * VA30bit
  * 页大小4KB→12bit页内偏移量
  * 总共八组→组号3bit

## 数据的表示和运算

![](/img/vweqwe.png)

![](/img/ngsddfasf.png)

![](/img/dsafwec.png)

* 数据的表示和运算往往还会和指令的运行过程结合起来考察

### 大纲

* 数制与编码

  * 进位计数制及其相互转换
    * 二进制、八进制、十进制、十六进制之间的转换
    * 二、八、十六之间的转换很简单
      * 八→3个bit，十六→4个bit
    * 二转十
      * 根据每位权值展开即可
    * 十转二
      * 好拼凑的
        * 拼凑法
      * 不好拼凑的
        * 整数部分
          * 除基取余法
            * 结果从后往前
        * 小数部分
          * 乘基取整法
            * 结果从前往后
  * 定点数的编码表示
    * 无符号数的表示
      * 重点关注无符号数的“减法“如何实现，以及无符号数加法/减法的溢出判断
        * 无符号数的加法直接加
        * 减法被减数不变，减数按位取反+1
          * A-B都是转为加法，A+(B取反末位+1)
        * CF标志位
    * 带符号整数的表示
      * 原
      * 反
      * 补
        * 重点关注补码的”减法“如何实现，以及补码加法/减法的溢出判断
          * A-B都是转为加法，A+(B取反末位+1)
      * 移
        * 注意偏移量是多少
    * 定点小数
      * 仅用于浮点数尾数，关注加减法即可

* 运算方法和运算电路

  * 基本运算部件

    * 加法器

      * 一位全加器

      ![](/img/202332.jpg)

      * 串行进位加法器

      ![](/img/02631.jpg)

      * 并行进位加法器

      ![](/img/202551.jpg)

      * 带标志加法器

      ![](/img/202510.jpg)

    * 算术逻辑部件（ALU）

    ![](/img/202743.jpg)

  * 加减运算

    * 补码加/减运算器

    * 标志位的生成

      ![](/img/224508.jpg)

      * CF
      * SF
      * ZF
      * OF

  * 乘除运算

    * 乘除运算的基本原理
    * 乘除电路和除法电路的基本结构

* 整数的表示和运算

  * 无符号整数的表示和运算
    * 表示
    * 运算
      * 加、减、乘、除
      * 溢出判断
  * 带符号整数的表示和运算
    * 表示
      * 原、反、补、移
      * 除了浮点数的尾数之外，所有的带符号数肯定都是用补码来表示的
    * 运算（仅关注补码即可）
      * 加减乘除
      * 溢出判断

* 浮点数的表示和运算

  * 浮点数的表示：IEEE754标准（只需要掌握该标准，非IEEE754标准的可以不管了）
    * 结构：符号位+阶码+尾数
    * float：1+8+23
    * double：1+11+52
    * long double ：1+15+64
  * 浮点数的加减运算
    * 对阶：小阶向大阶看齐
    * 尾数加减：原码定点数的加减法
      * 机器级别的实现上最终还是会变成补码的加减运算
    * 规格化：位数规格化为1.xxxx的形式
      * 尾数每左规一位，阶码-1
      * 尾数每右规一位，阶码+1
    * 舍入：尾数右规时，可能导致精度丢失，需考虑舍入问题
    * 判溢出
      * 尾数右规时，阶码超出可表示的最大值，上溢——发生溢出异常
        * 如果浮点数的加减运算有溢出的话，OF标志位会等于1
      * 尾数左规时，阶码低于可表示的最小值，下溢——当做机器0处理

### 考法

* 有符号数和无符号数，长数和短数，整数和浮点数的类型转换
* 结合C语言程序，分析”数据的表示和运算“
  * 常规考法
* 结合机器级代码（通常也会给出对应的C语言程序），分析”数据的标识和运算“在指令运行过程中的作用
  * 加减运算在”条件转移类指令”中的运用

### 大题重点关注

#### 数据的表示

![](/img/04717.jpg)

* C语言常见整数类型
  * 无符号整数
    * unsigned short
    * unsigned int
    * unsigned后面没有跟int还是short就默认int
  * 带符号整数
    * short
    * int
  * 记住16位表示范围
    * 2^16=65536
    * 2^15=32768
    * 带符号short→-32768~32767
    * 无符号unsigned short→0~65535
    * 加减溢出的快速判断
      * 十进制算结果超出表示范围一定溢出
* IEEE754浮点数
  * 结构：符号位+阶码+尾数
    * float：1+8+23
    * double：1+11+52
    * long double：1+15+64
* C语言数据类型转换
  * 整数之间的转换
    * 长短相同
      * 机器数不变，解释方式改变（带符号整数、无符号整数）
    * 短变长
      * 先扩展（无符号整数零扩展、带符号整数符号扩展），再解释
    * 长变短
      * 先截断（留低位），再解释
  * 整数和浮点数之间的转换
    * 整数转浮点数
      * 写出人类视角的科学计数法1.xxxx，再转为浮点数，截断尾部时采用0舍1入原则
      * 注意：精度丢失问题
    * 浮点数转整数
      * 写出二进制小数，去掉小数部分，整数部分保留更低的位数
      * 注意：溢出问题、精度丢失（小数点后的部分）

#### 数据的运算

* 加减法

  ![](/img/12412.jpg)

  * 无符号整数
    * 加法规则
      * 机算
        * 按位相加
      * 手算
        * 代入十进制机算
    * 减法规则
      * 机算
        * 减数按位取反末位加1，减法变加法
      * 手算
        * 代入十进制计算
    * 溢出问题
      * 手算
        * 判断加减法的结果是否超出无符号数合法范围
      * 机算
        * 根据CF标志位判断，CF=最高位产生的进位 ⊕ SUB（减1加0）
  * 带符号整数
    * 加法规则
      * 机算
        * 按位相加
      * 手算
        * 代入十进制计算
    * 减法规则
      * 机算
        * 减数按位取反末尾加一，减法变加法
      * 手算
        * 代入十进制计算
    * 溢出问题
      * 手算
        * 判断加减法的结果是否超出带符号数合法范围
      * 机算
        * 根据OF标志位判断，OF=最高位产生的进位 ⊕ 次高位产生的进位
  * IEEE754浮点数
    * 小题考察居多
  * 什么时候用手算，什么时候用计算
    * 优先手算，溢出的时候机算

* 乘法

  ![](/img/12452.jpg)

  * 无符号整数
    * 机算
      * 注意：可用逻辑左移代替*2
        * 逻辑左移，低位补0，高位直接移出去，逻辑右移，低位直接移出去，高位补0
    * 溢出判断
      * n位*n位，若用2n位保存乘积，则不会溢出
      * n位*n位，若用2n位保存中间结果，最后截取末尾n位作为最终的乘积，可能会溢出
        * 手算判溢出
          * 代入十进制计算乘法结果，判断该结果是否超出了n位“无符号数”所能表示的范围，若超出，则溢出
        * 机器判溢出
          * 两个无符号数乘法：n位*n位，用2n位保存中间结果，仅当前n位都是0时，不溢出
  * 带符号整数
    * 机算
      * 注意：可用算术左移代替*2
        * 算术左移，低位补0，高位直接移出去，算术右移，低位丢弃，高位补符
    * 溢出判断
      * n位*n位，若用2n位保存乘积，则不会溢出
      * n位*n位，若用2n位保存中间结果，最后截取末尾n位作为最终的乘积，可能会溢出
        * 手算判溢出
          * 代入十进制计算乘法结果，判断该结果是否超出了n位“无符号数”所能表示的范围，若超出，则溢出
        * 机器判溢出
          * 两个有符号补码乘法：n位*n位，用2n位保存中间结果。仅当前n+1位全0或者全1时，不溢出

* 除法

  ![](/img/21037.jpg)

  * 无符号整数
    * 机算
      * 可用逻辑右移替代/2
  * 带符号整数
    * 机算
      * 可用算术右移代替/2
  * 408考试中除法不可能溢出，只丢失精度

### 常见的难点

#### 无符号数的加法、减法怎么算

![](/img/059.jpg)

* 在硬件看来，对无符号数的加减法、对有符号补码的加减法都是一样的计算方法

  ![](/img/164452.jpg)

  * 共用同一套电路

* 加法：直接N bit二进制按位相加

* 减法：计算”A-B“可转化为等价的加法——将B的N bit全部按位取反末位+1，然后与A相加

#### 遇到乘法怎么算

![](/img/21108.jpg)

* 通常可代入十进制手算
* 408大纲不要求掌握浮点数乘法

#### 遇到除法怎么算

![](/img/221116.jpg)

* 通常可代入十进制手算
* 408大纲不要求掌握浮点数除法

#### 溢出怎么判断

![](/img/21139.jpg)

* 加法/减法
  * 手算判溢出
    * 代入十进制计算结果，判断该结果是否超出了n位所能表示的范围，若超出，则溢出
  * 机器判溢出
    * 无符号数加/减：运算后若CF=1，则溢出；若CF=0，则不溢出
* 乘法
  * n位*n位，若用2n位保存乘积，则不会溢出
  * n位*n位，用2n位保存中间结果，最后截取末尾n位作为最终的乘积，可能会溢出
    * 手算判溢出
      * 代入十进制计算乘法结果，判断该结果是否超出了n位所能表示的范围，若超出，则溢出
    * 机器判溢出
      * 两个无符号数乘法：n位*n位，用2n位保存中间结果。仅当前n位都是0时，才不溢出
      * 两个有符号补码乘法：n位*n位，用2n位保存中间结果。仅当前n+1位全1或全0时，不溢出

#### 精度丢失怎么判断

![](/img/221153.jpg)

* 浮点数的精度：看尾数的位数
  * 单精度浮点型float
    * 尾数位数位23+1bit。因此数值部分可以表示24bit的精度
  * 双精度浮点型double
    * 尾数位数位52+1bit。因此数值部分可表示53bit的精度
  * 临时浮点数long double
    * 尾数位数位64+1bit。因此数值部分可表示65bit的精度
  * 注：IEEE754标准中，尾数是规格化的，隐含了一个最高位的1
* 定点整数的精度：看数值位的位数
  * 16位short型
    * 数值部分的精度为15bit
  * 32位int型
    * 数值部分的精度为31bit
  * 32位unsigned int型
    * 数值部分精度为32bit
  * 64位long型
    * 数值部分的精度为63bit
* 整数转浮点数
  * 数值部分精度更高的类型，转为数值部分精度更低的类型，就有可能发生精度丢失
  * 如果整数的数值位的位数等于或者小于浮点数尾数位数，精度就不会丢失，如果整数的数值位的位数大于浮点数尾数位数，精度就会丢失
  * 不会溢出
* 浮点数转整数
  * 如果浮点数有小数部分，则可能丢失精度

#### 标志位怎么区分

![](/img/21217.jpg)

* CF
  * 含义：进位/借位标志，表示无符号数的加减法是否发生了进位或借位。当CF=1时，说明无符号数的加减运算发生了进位或借位，也即发生了溢出
  * 硬件的计算方法
    * CF=最高位产生的进位 ⊕ SUB
      * sub=1表示减法
      * sub=1表示加法
  * 注意：CF位对有符号数的加减法无意义
* ZF
  * 含义
    * 表示运算的结果是否为0。ZF=1表示运算结果为0，ZF=0表示运算结果非0
  * 硬件的计算方法
    * 两个数的运算结果为n bit，只有n bit全为0时，ZF=1
* OF
  * 含义
    * 有符号数的加减运算是否发生了溢出。OF=1时，说明发生了溢出
  * 硬件的计算方法
    * OF=最高位产生的进位⊕次高位产生的进位
  * 注意：OF位对无符号数的加减法无意义
* SF
  * 含义
    * 有符号数加减运算结果的正负性，SF=0表示运算结果为正数，SF=1表示运算结果为负数
  * 硬件的计算方法
    * SF=最高位的本位和
  * 注意
    * SF位对无符号数的加减法无意义

## 指令的执行

* 第四章（指令系统）是一堆指令的执行
  * 更加宏观，不同指令之间如何配合工作，因为程序是由指令序列来完成
  * 给一个C语言程序，然后给对应的机器语言指令或汇编语言指令，去分析这些指令序列的工作过程
* 第五章（中央处理器）是一条指令的执行
  * 更为微观，一般来说结合硬件电路去考察，一条指令使用硬件是如何实现的，如何实现这一条指令的功能

### 大纲

* 指令系统的基本概念
* 指令格式
  * 指令的基本格式
    * 操作码
      
      * 指明了动作
      
    * 操作数（可能有0~n个）
      
      * 来源
        * 寄存器
        * 主存
        * 立即数
      * 寻址方式
        * 怎么找到这个操作数
      * 形式地址
        * 形式地址（需转成有效地址EA）
        * 指令运行时需转成有效地址EA
      
    * 根据指令长度是否固定不变，分为两类
      * 定长指令字
        
        * 每次PC+“1”，“1”固定
        
      * 变长指令字
        
        * 每次PC+“1”，“1”不固定
        
      * 十六进制加减快速运算
      
        * 加法转化为十进制，然后逢16进1，拆分为16+x，x就是剩下的位数
        * 减法同理，不够减就借位，然后加上16再减，参考十进制
      
        ![](/img/220530.jpg)
      
        ![](/img/220740.jpg)
  * 定长操作码指令格式
    
    * 操作码的位数固定不变
  * 扩展操作码指令格式
    
    * 操作码的位数可能会改变
* 寻址方式
  * 有效地址的概念
    * EA：最终要访问的地址
  * 要寻找什么？
    * 数据寻址
      * 找数据——找到你要操作的数据
    * 指令寻址
      * 找下一条要执行的指令——取决于PC值
      * 肯定是根据PC值去访问主存，从主存当中找到下一条要执行的指令
  * 常见的寻址方式

![](/img/ffdssdsss.png)

* 需要关注的寻址
  * 立即寻址
  * 直接寻址
  * 寄存器寻址
  * 寄存器间接寻址
  * 相对寻址（PC+偏移量）
    * 要修改PC值的基本都是这种寻址方式，尤其是转移类指令
  * 变址寻址
    * 数组问题（起始地址+偏移量）

* 隐含寻址：一条指令的操作数由硬件直接找到，并没有在指令中明确指出操作数在哪个地方
  * 如return指令
  * 根据这个指令的规则，由硬件自动去找到要找的操作数

* 数据的对齐和大/小端存放方式
  * 数据的对齐
    * 按边界对齐
    * 不按边界对齐
  * 存放方式
    * 大端存储（更符合人类视角）
    * 小端存储
    * 大端和小端只涉及多字节数据（如16bit、32bit、64bit）在内存中的存储顺序，指的是一个数据内部字节的顺序
      * 至于为什么指令格式是操作码+地址码，因为这是CPU指令格式的定义，与大小端存储无关，而且大小端存储针对的是《每个多字节数据》而不是整条指令
* CISC和RISC的基本概念
  * 从机器级代码中可以看到显著区别
    * 指令字是否定长
      * RISC的指令定长，CISC的指令不定长
    * 除了Load、Store之外，是否还有其他的指令可以访存
      * RISC仅有Load、Store类指令，才可以访问主存
      * x86可以用move
* 高级语言程序与机器及代码之间的对应
  * 编译器、汇编器、链接器的基本概念
  * 选择结构语句的机器级表示
  * 循环结构语句的机器级表示
  * 过程（函数）调用对应的机器级表示

### 解题方法

* 先观察汇编语言，是x86还是MIPS？
  * 观察是否有注释
    * 通常来说，真题中x86汇编语言不会给太多注释（考研中默认大家懂x86）
  * 观察指令长度是否固定
    * x86属于CICS，指令长度不固定
    * MIPS属于RISC，指令长度固定
  * 观察寄存器名
    * x86的寄存器名为eax、ebx、ecx、edx
    * MIPS的寄存器名为R[0]、R[1]、R[2]
* x86
  * 先搞懂C语言
    * 一般给出的x86机器级代码，第一列是指令的序号，第二列是指令的虚拟地址，第三列是指令的机器级代码（十六进制表示），第四列是汇编语言
  * 基于C语言的逻辑分析机器指令
    * 有没有分支结构
      * 观察有没有jxxx指令
        * 转移类指令除了操作码之外的部分，在x86语言中，就是偏移量PC的偏移量（注意取出当前指令以后PC要+“1”，偏移量是PC+"1"+偏移量）
        * 如果转移值是负数，要进行符号扩展到虚拟地址的位数，然后进行计算
    * 有没有循环结构
      * 观察有没有jxxx指令
      * 观察有没有loopxxx指令
    * 有没有函数调用
      * 观察有没有call指令
        * call 函数名 函数指令的地址
      * 观察有没有ret指令
    * 需不需要访问函数调用参数？观察在汇编语言中如何访问调用参数
      * 注：函数调用参数一般在[ebp+8]、[ebp+12]等位置
    * 需不需要定义局部变量？观察在汇编语言中如何访问局部变量
      * 注：局部变量的存储地址一般在[ebp-4]、[ebp-8]、[ebp-12]等位置
* MIPS
  * 先搞懂C语言
  * 基于C语言的逻辑分析指令
    * 有没有分支结构
      * 观察有没有bxxx指令
        * 注：MIPS汇编语言中，转移类指令是以b开头的，表示”branch“，即分支。指令原理与x86的jxxx相同
    * 有没有循环结构
      * 观察有没有bxxx指令
    * 有没有函数调用
      * 注：MIPS汇编语言指令通常不考函数调用，重点关注x86的函数调用
  * 考不考流水线
    * 对指令进行分类
      * 五类指令，每一类指令的运行原理要搞清楚
      * 安排指令流水线
      * 分析数据冒险、控制冒险

### 基础知识

* x86汇编指令（重点关注intel格式）

  * 算数、逻辑运算类指令
    * 加减乘除、左移右移等指令
  * 分支结构（if/else)
    * 无条件转移（goto）
      * jmp（无条件转移指令），类似于C原的goto
      * 无条件转移的指令只有 call，return和jmp 指令
    * 条件转移指令（if/else）
      * cmp A,B（本质是A-B，A-B的标志位信息会存放到PSW中）
        * 无符号数减法关注CF、ZF
          * A==B——需满足ZF ==1
          * A!=B——需满足ZF ==0
          * A>=B——需满足CF==0
          * A<=B——需满足CF==1|| ZF ==1
          * A>B——需满足CF==0 && ZF ==0
          * A<B——需满足CF==1
        * 有符号数减法关注OF、SF、ZF
          * A==B——需满足 ZF ==1
          * A!=B——需满足ZF==0
          * A>=B——需满足SF==OF
          * A<=B——需满足SF!=OF || ZF ==1
          * A>B——需满足SF==OF && ZF ==0
          * A<B——需满足SF!=OF && ZF==0
      * jxxx（转移指令）
        * 转移类指令，通常采用相对寻址。用补码表示偏移量。补码的值通常意味着PC要 往前/往后 跳多少个地址（注意：偏移量的单位可能是字节，也可能是指令字长）
        * x86属于CISC，指令字长不固定，因此转移类指令中一定是以”字节“为单位描述PC的偏移量
        * 偏移量一般用补码表示
  * 循环结构（for、while）
    * 条件转移指令jxxx可以用于实现循环
      * 注：在x86汇编语言中，循环结构通常是用jxxx指令实现的，很少使用loopxxx指令
    * loopx指令
      * 原理同转移指令
  * 函数调用/返回
    * 调用指令
      * call< label >
        * 当前PC值压栈保存，再修改PC的值，跳转到< label >
        * 与无条件转移指令jmp的区别
          * call指令会将函数返回地址（当前的PC）入栈
    * 返回指令
      * ret
        * 恢复程序计数器PC，返回原函数

* MIPS汇编指令

  * 常见指令

    * 算数、逻辑运算类指令
      * 加
        * OP：add
      * 减
        * OP：sub
      * 乘
        * OP：mul
      * 除
        * OP：div
      * 左移
        * OP：shl
      * 右移
        * OP：shr
    * 转移类指令
      * bxxx
        * b开头，意思是branch
        * 转移类指令，通常采用相对寻址。用补码表示偏移量。补码的值通常意味着PC要往前/往后跳多少个地址（注意：偏移量的单位可能是字节，也可能是指令字长）
        * MIPS属于RISC，指令字长固定，因此转移类指令中可能会以”指令字长“为单位描述PC的偏移量
    * Load类指令
      * lxxx
        * L开头，意思是load
        * 根据读取长度不同，”xxx“部分可能会变，例如从内存中读取一个字可以使用指令lw，这里的w指”word“
    * store类指令
      * sxxx
        * s开头，意思是store
        * 根据存储长度不同，”xxx“部分可能会变，例如往内存写一个字可以使用指令sw，这里的w指”word“

  * 结合五段式指令流水线考察

    * 数据冒险
      * 什么指令可能导致数据冒险
        * 前面的指令
          * 写某个寄存器
            * WB，第五个段
        * 后面的指令
          * 读（同一个）寄存器
            * ID，第二个段
        * 分析思路
          * 一条一条指令从前往后分析，如果一条指令写了某个寄存器，则观察与之相邻的后3条指令中，有没有哪条指令需要读同一个寄存器
    * 控制冒险
      * 什么指令可能导致控制冒险
        * 转移类指令
          * M，第四个段改变PC值
          * 处理控制冒险的方法：停三个周期，再取下一条指令（IF段），就不会发生控制冒险
        * 注：call、ret也属于转移类指令，也会在M段修改PC值

    ![](/img/ffdaggggg.png)

    ![](/img/194837.jpg)

### x86汇编语言，AT&T和intel格式的区别

* 截至目前，历年真题中都是intel格式

![](/img/zpeoicuoiowrw.png)

## 指令的硬件实现

* 考察具体的某一条指令在执行的过程当中，如何用硬件去实现相应的这些功能

### 大纲

#### CPU的功能和基础结构

* CPU=控制器+数据通路
  * 控制器，即CPU，是指令的控制部件
  * 数据通路，是指令的执行部件，包括运算器、寄存器、数据传输的线路等

#### 指令的执行过程

* 取值、译码
  * 取指令送入IR、PC+"1"
  * CU根据IR译码，确定指令的执行时序
* 执行
  * 取操作数、运算、存结果
  * 异常/终端的检测与处理（如果有的话）

#### 数据通路的功能和基本结构

#### 控制器的功能和基本结构

#### 控制器的功能和工作原理

* 硬布线控制器
* 微程序控制器
* 这部分2022大纲更新后考察权重被弱化

#### 异常和中断机制

* 异常和中断的基本概念
* 异常和中断的分类
* 异常和中断的检测与响应

#### 指令流水线

* 指令流水线的基本概念
* 指令流水线的基本实现
* 结构冒险、数据冒险、控制冒险的处理
* 超标量和动态流水线的基本概念

#### 多处理器基本概念

* SISD、SIMD、MIMD、向量处理器的基本概念
* 硬件多线程的基本概念
* 多核处理器（multi-core）的基本概念
* 共享内存多处理器（SMP）的基本概念

### 解题思路

#### 分析框架

* 思考：一条指令的执行过程
  * 取指阶段（所有指令在取指阶段做的事情都一样）
    * 根据PC从主存中取指令到IR
    * PC+“1”
      * 可以考虑用硬件①、②实现PC+”1“
      * 也可以考虑用硬件⑿实现PC自增
  * 执行阶段（根据指令类别来思考）
    * 数据传送类指令（如：mov、load、store）
      * 关注数据从哪里流动到哪里
        * 主存
        * 寄存器
        * 立即数
    * 运算类指令
      * 加、减
        * 可以考虑用硬件①②
        * 自增++、自减--可以考虑用硬件①②⑿
      * 乘
        * 可以考虑用硬件①③
        * 特殊乘法，乘以2^n，可用⑾左移功能平替，也可以用①ALU的左移功能平替
      * 除
        * 可以考虑用硬件①④
        * 特殊除法，除以2^n，可用⑾右移功能平替，也可用①ALU的右移功能平替
      * 移位运算
        * 可以考虑用硬件①⑾实现
      * 与、或、异或等双操作数逻辑运算
        * 可考虑用硬件①实现
      * 非 运算
        * 可以考虑用硬件①、⒂实现
      * 短数→长数
        * 带符号数位扩展可使用硬件⒀
        * 无符号数位扩展可使用硬件⒁
    * 转移类指令
      * 条件转移
        * 做条件判断时，经常用到减法生成标志位，因此可能会用到硬件①或者②
        * 减法生成的CF、ZF、SF、OF标志位需要用”标志寄存器“存储起来
      * 无条件转移
      * 无论是条件转移还是无条件转移，在计算转移目标地址时，需要将”PC+偏移量”。因此可以考虑使用硬件①或者②实现这个加法运算
* key：指令各阶段的功能，要用什么硬件部件实现？数据应该如何流动？——硬件的控制信号、连线只是实现逻辑的一种外化体现

#### 如何用硬件实现指令功能

* 控制硬件的信号

  * XXXin
    * 允许数据进入
  * XXXout
    * 允许数据出去
  * XXXop
    * 具体的控制信号

* 常见硬件

  * 操作元件（组合逻辑元件）

    * ①算术逻辑单元（ALU）
      * 实现加减乘除等算术运算、与或非等逻辑运算
      * 注意：ALU可以支持“直送”，即不对输入数据做任何处理
      * 控制信号：n bit，取决于ALU支持多少种运算，n bit控制信号，对应2^n种运算
    * ②加法器（Adder）
      * 结合第二章复习，相当于弱鸡版ALU，只能实现加法、减法
      * 控制信号：1bit
        * 0加1减，控制信号的值会影响CF标志位（CF=sub⊕最高位进位）
    * ③乘法器
      * 实现乘法运算
    * ④除法器
      * 实现除法运算
    * ⑤三态门
      * 就是一道门，可开可关
      * 控制信号：1bit，用于控制开/关
    * ⑥多路选择器（MUX）
      * 有2^n路输入，通过n bit控制信号选择让其中的某一路输入通过
      * 控制信号：n bit，取决于有多少路输入，n bit控制信号，对应2^n路
    * ⑦译码器（Decoder）
      * 根据n bit控制信号选择将2^n条输出线路中的某一条信号选通为1
      * 控制信号：n bit。由译码器的n bit输入即可决定选通哪根线

  * 存储元件（时序逻辑元件）

    * ⑧普通寄存器

      * 具有特定用途的寄存器
        * MAR
        * MDR
        * IR
        * PC
        * FR（即标志寄存器，有的系统中称为PSW）
      * 控制信号：允许读、允许写

    * ⑨暂存寄存器

      * 通常会在单总线结构中和ALU配合使用
      * 控制信号：允许读、允许写

    * ⑩通用寄存器组

      * 控制信号1：允许读、允许写
      * 控制信号2：若通用寄存器组共有2^n个寄存器，则需要n bit控制信号选择其中一个寄存器

    * 注意：有的寄存器可能支持特殊功能

      * ⑾带“移位功能“的寄存器
        * 可以实现移位运算（算术左移/右移、逻辑左移/右移）
        * 隐藏技能：用移位运算等价实现”乘/除2^n“
      * ⑿带”自增、自检功能“的寄存器
        * 可实现寄存器的值++、-
        * 常见用途：有的PC寄存器带有自增功能
      * 带其他特殊功能的寄存器
        * ⒀带”符号扩展“功能的寄存器
          * 可以将位数短的带符号数（补码）扩展为位数更长的带符号数（补码）
        * ⒁带”零扩展“功能的寄存器
          * 可以将位数短的无符号数扩展为位数更长的无符号数
          * ⒂带”取反功能“的寄存器
            * 可以实现全部位按位取反

      

#### 如何看懂注释

##### 袁版注释风格（16年以后的真题）

* 数据在通用寄存器组
  * 特点：用R[i]表示，中括号内为寄存器编号
  * eg：R[6] x R[3]→R[2]。将寄存器R6 x R3的内容写入R2
* 数据在某个特殊名字的寄存器
  * 特点：直接用寄存器名字表示
  * eg：R[6]+10→PC。把寄存器R6+10的内容写入PC
  * eg：MDR→PC。把MDR的内容写入PC
* 数据在主存
  * 特点：用M[addr]表示，addr为主存地址
  * eg：R[6]→M[10086]
    * 将R6的内容存入主存地址10086
  * eg：R[3]<<2→M[R[6]]
    * 将R3进行”左移两位“运算，并将结果存入R6所指的主存地址（寄存器间接寻址）
  * eg：M[PC+10]→MDR
    * 将PC+10指向的主存内容取到MDR
* 特点总结
  * 喜欢用”中括号“，中括号里边表示寄存器编号、或主存地址
  * 要使用寄存器里的内容，不用加小括号，直接给寄存器名即可

##### 唐版注释风格（16年以前的真题）

* 数据在通用寄存器组
  * 特点：箭头左边，用寄存器名加小括号，表示寄存器里的值；箭头右边表示存入某个寄存器不加小括号
  * eg：(R6)x(R3)→R2。将寄存器R6xR3的内容写入R2
* 数据在某个特殊名字的寄存器
  * 特点：直接用寄存器名字表示，要使用寄存器里的值需要加小括号
  * eg：(R6)+10→PC。把寄存器R6+10的内容写入PC
  * eg：(MDR)→PC。把MDR的内容写入PC
* 数据在主存
  * 特点：用M(addr)表示，addr为主存地址
  * eg：(R6)→M(10086)
    * 将R6的内容存入主存地址10086（寄存器间接寻址）
  * eg：(R3)<<2→M((R6))
    * 将R3进行”左移两位“运算，并将结果存入R6所指的主存地址（寄存器间接寻址）
  * eg：((PC)+10)→MDR
    * 将PC+10指向的主存内容取到MDR
    * 在箭头的左边表示“访问主存”时，可以不加M，用两层括号表示寄存器间接寻址
* 特点总结
  * 喜欢用“小括号”
  * 箭头左边若要使用某个寄存器里的内容，必须在寄存器名字外面加小括号
  * 箭头右边表示存入某个寄存器，不用加小括号

## 指令流水线

### 考研大纲要求&备考方法

![](/img/dsafdsssggadg.png)

* 结构冒险：由于多条指令在同一时刻争用同一资源而形成的冲突
* 数据冒险：在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，则这两条指令即为数据相关
* 控制冒险：当流水线遇到转移指令和其他改变PC值的指令而造成断流时，会引起控制相关

### 结构冒险及其处理

![](/img/vecxe.png)

* 第一个阶段即取指阶段和第四个阶段访存阶段都需要使用到同一块Cache，因此多条指令连续执行的时候就会出现结构冒险，比如第四个始终，IF取指阶段需要访问Cache，M访存阶段也需要访问Cache

![](/img/awcerwav.png)

* 让后面的一条指令阻塞若干个时钟周期，直到这条指令的执行不会导致结构冒险为止。

![](/img/scdadtvvweac.png)

* 将Cache分为指令Cache和数据Cache，分别存储指令和数据，第四个时钟的时候IF访问指令Cache，M访问数据Cache

#### 真题实战

![](/img/dssss.png)

![](/img/sadfa.png)

* 在考研真题中，只要遇到五段式指令流水线，都可以默认在这个系统当中，它的数据Cache和指令Cache一定是分离的，不需要去考虑结构冒险的问题

### 如何分析数据冒险、控制冒险

![](F:\try\home\themes\fluid\source\img\htydjsrf.png)

* 任何一条指令对寄存器的写操作都一定是在WB这一段
* 任何一条指令对寄存器的读操作一定是在ID这一段
* 会写寄存器的只有load指令和运算类指令，而且一定是在第五个段WB这个段
* 如果前一条指令写了某个寄存器，而后一条指令在前一条指令还没协会之前，就去尝试读同一个寄存器的值，那么就会发生数据冒险
  * 因此在分析题目的时候，需要注意观察load指令和运算类指令有没有写某一个寄存器
  * 如果发现了这种情况，那么接下来就需要观察这两类指令的后面几条指令有没有去读同一个寄存器，如果有的话，就有可能发生数据冒险
* 所有的指令当中，只有转移类的指令有可能会更改PC值

### 数据冒险的分析和处理

### 控制冒险的分析和处理