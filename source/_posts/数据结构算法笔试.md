---
title: æ•°æ®ç»“æ„ç®—æ³•ç¬”è¯•
date: 2025-04-02 18:55:05
tags: 408æ—¥å¸¸
sticky: 259
banner_img: /img/1920x1080 (16).jpg
index_img: /img/1920x1080 (16).jpg
math: true
---

## å¦‚ä½•å¤‡è€ƒæ•°æ®ç»“æ„å¤§é¢˜

![](/img/205513.jpg)

![](/img/cweqjcewq.png)

![](/img/qweewqc.png)

![](/img/weqcwqtvqee.png)

* æ•°æ®ç»“æ„çš„å°é¢˜æœ€å¥½çš„å¤ä¹ æ–¹æ³•æ˜¯æŠŠç‹é“ä¹¦çš„è¯¾åä¹ é¢˜äºŒåˆ·
* å¤šåšé¢˜å°‘å¬è¯¾
* ä¸»åŠ¨å‘ç°è‡ªå·±ä¸è¶³çš„åœ°æ–¹ï¼Œå»æŸ¥ç¼ºè¡¥æ¼è€Œä¸æ˜¯éå†è¯¾æœ¬

### å¤§é¢˜çš„é¢˜å‹

![](/img/205610.jpg)

* åº”ç”¨é¢˜ä¾§é‡äºç®—æ³•çš„é€»è¾‘è€Œä¸æ˜¯ç®—æ³•ä»£ç çš„å®ç°
* å¤§çº²é‡Œé¢åº”ç”¨ç›¸å…³å³å¤§é¢˜è¦è€ƒçš„è€ƒç‚¹
* åº”ç”¨é¢˜å¤‡è€ƒæ€è·¯ï¼š
  * ç”»æ•°æ®ç»“æ„å’Œç®—æ³•è¿è¡Œè¿‡ç¨‹
  * è®­ç»ƒæ•°æ®ç»“æ„å®šä¹‰çš„ç®€å•ä»£ç 
  * åŸºæœ¬æ“ä½œçš„ç®€å•ä»£ç 

### å…«å¤§è€ƒç‚¹

![](/img/05710.jpg)

#### â‘ çº¿æ€§è¡¨çš„åº”ç”¨

#### â‘¡æ ˆçš„åº”ç”¨

#### â‘¢é˜Ÿåˆ—çš„åº”ç”¨

#### â‘£æ•°ç»„çš„åº”ç”¨

#### â‘¤æ ‘ä¸äºŒå‰æ ‘çš„åº”ç”¨

* äºŒå‰æ ‘åŸºæœ¬è€ƒçš„å°±æ˜¯å“ˆå¤«æ›¼æ ‘å’Œå“ˆå¤«æ›¼ç¼–ç ï¼Œå¹¶æŸ¥é›†åŠå…¶åº”ç”¨ã€‚å…¶ä»–çš„é¢˜å‹é€šå¸¸æ˜¯å®šä¹‰æ•°æ®ç»“æ„æˆ–è€…å®ç°åŸºæœ¬æ“ä½œ

#### â‘¥å›¾çš„åŸºæœ¬åº”ç”¨

* æ¯”è¾ƒåŸºæœ¬çš„åº”ç”¨
* åº”ç”¨é¢˜ä¸€èˆ¬ä¸ç”¨å†™ä»£ç ä½†æ˜¯è¦æ‰‹ç®—ï¼Œèƒ½å¤Ÿæ‡‚è¿™äº›ç®—æ³•è¿è¡Œçš„é€»è¾‘

##### æœ€å°ï¼ˆä»£ä»·ï¼‰ç”Ÿæˆæ ‘

* æœ€å°ç”Ÿæˆæ ‘è€ƒå¯Ÿçš„æ˜¯ä¸€ä¸ªå›¾ä¸­åŒ…å«å¤šä¸ªç‚¹çš„æ€»è·¯çº¿ä»£ä»·æœ€çŸ­
  * è€Œå•æºæœ€çŸ­è·¯å¾„åªè€ƒè™‘ä¸¤ç‚¹ä¹‹é—´æœ€çŸ­è·ç¦»çš„è·¯å¾„

##### æœ€çŸ­è·¯å¾„

##### æ‹“æ‰‘æ’åº

##### å…³é”®è·¯å¾„

##### å…¶ä»–

* æ•°æ®ç»“æ„å®šä¹‰
* ç”»å›¾

#### â‘¦æŸ¥æ‰¾ç®—æ³•çš„åˆ†æåŠåº”ç”¨

* äºŒå‰æœç´¢æ ‘ã€å¹³è¡¡äºŒå‰æ ‘å’Œçº¢é»‘æ ‘å¯èƒ½å’Œæ ‘ä¸äºŒå‰æ ‘è€ƒç‚¹è¿›è¡Œæ¯”è¾ƒæ·±åº¦çš„ç»“åˆ
  * æ¯”å¦‚ç»™å‡ºä¸€ä¸ªå…³é”®å­—åºåˆ—ï¼Œä»ä¸€ä¸ªç©ºçš„äºŒå‰æ ‘å¼€å§‹æ’å…¥è¿™äº›å…³é”®å­—ï¼Œç„¶åç”»å‡ºæ’å…¥ä»¥åçš„å¹³è¡¡äºŒå‰æ ‘çš„å½¢æ€ï¼ŒåŒæ—¶ç»™å‡ºè¿™ä¸ªå¹³è¡¡äºŒå‰æ ‘çš„æ•°æ®ç»“æ„å®šä¹‰
  * å¤§æ¦‚ç‡åº”ç”¨é¢˜è€Œä¸æ˜¯ä»£ç 
  * å°¤å…¶æ˜¯å¹³è¡¡äºŒå‰æ ‘å’Œçº¢é»‘æ ‘

* æ•£åˆ—ï¼ˆå“ˆå¸Œï¼‰è¡¨
  * å¤§æ¦‚ç‡åº”ç”¨é¢˜è€Œä¸æ˜¯ä»£ç 
* Bæ ‘åŠå…¶åŸºæœ¬æ“ä½œ
  * ä¸å¤ªå¯èƒ½åœ¨åº”ç”¨é¢˜å½“ä¸­è€ƒå¯Ÿï¼Œåªè€ƒåŸºæœ¬æ¦‚å¿µï¼Œä¸ç”¨ç®¡åŸºæœ¬æ“ä½œï¼Œbæ ‘å°é¢˜é‡Œé¢ä¸€èˆ¬å¯èƒ½è€ƒ
* åˆ†å—æŸ¥æ‰¾
  * åº”ç”¨é¢˜
* å­—ç¬¦ä¸²æ¨¡å¼åŒ¹é…
  * å¤§æ¦‚ç‡åº”ç”¨é¢˜è€Œä¸æ˜¯ä»£ç 
* æŸ¥æ‰¾ç®—æ³•çš„æ€§èƒ½åˆ†æï¼Œåˆ†æå¹³å‡æŸ¥æ‰¾é•¿åº¦ï¼ŒæˆåŠŸçš„ASLå’Œå¤±è´¥çš„ASL

#### â‘§æ’åºç®—æ³•çš„åˆ†æåŠåº”ç”¨

* å¸Œå°”æ’åº
  * æ›´å®¹æ˜“è€ƒå°é¢˜è€Œä¸æ˜¯åº”ç”¨é¢˜
* å †æ’åº
* åŸºæ•°æ’åº
* å¤–éƒ¨æ’åº

### ä¸ƒå¤§è€ƒæ³•

![](/img/205729.jpg)

#### â‘ ç”»å›¾ä½œç­”

* ï¼ˆ1ï¼‰ç”»æ•°æ®ç»“æ„çš„çŠ¶æ€ç¤ºæ„å›¾
  * é‡ä¸­ä¹‹é‡
  * ä¸€èˆ¬æ˜¯è€ƒå¯Ÿæ¯”è¾ƒå¤æ‚çš„æ•°æ®ç»“æ„çš„å›¾ç¤º

#### â‘¡ä»£ç ä½œç­”

* ï¼ˆ1ï¼‰å†™æ•°æ®ç»“æ„å®šä¹‰ã€åŸºæœ¬æ“ä½œä»£ç 
  * ç®€å•çš„ä»£ç 
  * åŸºæœ¬æ“ä½œ/åŠŸèƒ½çš„ä»£ç ç‰‡æ®µï¼Œæ¯”å¦‚åˆ¤æ–­é˜Ÿç©ºæˆ–è€…æ’å…¥
  * æ¯”è¾ƒå¤æ‚çš„æ•°æ®ç»“æ„ä¸ä¼šè€ƒå¾ˆå¤æ‚çš„ç®—æ³•é¢˜ï¼Œä½†å¯èƒ½è€ƒæ•°æ®ç»“æ„çš„ä»£ç å®šä¹‰ä»¥åŠåŸºæœ¬æ“ä½œçš„ä»£ç å®ç°

#### â‘¢æ–‡å­—ç®€ç­”

* ï¼ˆ1ï¼‰æ‰‹ç®—åˆ†æç®—æ³•è¿è¡Œè¿‡ç¨‹/ç»“æœ
* ï¼ˆ2ï¼‰æ•°æ®ç»“æ„ã€ç®—æ³•çš„é€‰æ‹©
  * åŸºäºåº”ç”¨åœºæ™¯é€‰æ‹©ä¸€ç§åˆé€‚çš„æ•°æ®ç»“æ„
  * åŸºäºåº”ç”¨åœºæ™¯é€‰æ‹©ä¸€ç§æ€§èƒ½æ¯”è¾ƒå¥½çš„ç®—æ³•
* ï¼ˆ3ï¼‰ç®—æ³•æ€§è´¨åˆ†æ
  * åˆ†æç®—æ³•çš„æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦
    * æ‰€æœ‰ç®—æ³•éƒ½æœ‰å¯èƒ½è€ƒ
  * æŸ¥æ‰¾ç®—æ³•
    * åˆ†æå¹³å‡æŸ¥æ‰¾é•¿åº¦
    * æˆåŠŸASLå’Œå¤±è´¥ASL
  * æ’åºç®—æ³•
    * åˆ†æå…³é”®å­—çš„å¯¹æ¯”æ¬¡æ•°
      * æŸä¸€è¶Ÿæ’åºå½“ä¸­å…³é”®å­—çš„å¯¹æ¯”æ¬¡æ•°æ˜¯å¤šå°‘
      * æ’å®Œåºå…³é”®å­—çš„æ€»å¯¹æ¯”æ¬¡æ•°æ˜¯å¤šå°‘
    * ç¨³å®šæ€§
* ï¼ˆ4ï¼‰æ–‡å­—æè¿°ç®—æ³•æ€æƒ³/è¿‡ç¨‹
  * å¯ä»¥é€šè¿‡ç¤ºæ„å›¾å»è§£é‡Šç®—æ³•çš„è¿è¡Œè¿‡ç¨‹ï¼Œç”¨æ–‡å­—æè¿°ä¹Ÿå¯ä»¥è§£å’Œç”»å›¾å»åš
  * å°†ç”»æ•°æ®ç»“æ„çš„çŠ¶æ€ç¤ºæ„å›¾å’Œæ‰‹ç®—åˆ†æç®—æ³•è¿è¡Œè¿‡ç¨‹/ç»“æœç»“åˆèµ·æ¥ï¼Œä»è¿™ä¸¤ä¸ªè§’åº¦å»æŠŠå„ä¸ªç®—æ³•çš„è¿è¡Œè¿‡ç¨‹å’Œæ•°æ®ç»“æ„çš„ç¤ºæ„å›¾æ‹æ¸…æ¥š
* ï¼ˆ5ï¼‰æ•°æ®ç»“æ„æ€§è´¨æ¨æ¼”
  * æ ‘å’Œå›¾çš„æ€§è´¨æ¨æ¼”
    * ä¸»è¦æ ¹æ®ç‹é“ä¹¦çš„è¯¾åå°é¢˜æ¥å¤ä¹ 

## åº”ç”¨é¢˜

![](/img/191649.jpg)

* å…ˆæ‰¾åˆ°é¢˜ç›®ä¸­çš„çº¿ç´¢ï¼Œç„¶åéå†ä¸€ä¸‹è¿™ç±»é—®é¢˜çš„åšæ³•

### æ’åºç±»åº”ç”¨é¢˜

![](/img/20043.jpg)

![](/img/170219.jpg)

![](/img/171218.jpg)

![](/img/74000.jpg)

![](/img/174043.jpg)

* æ’å…¥ç±»æ’åºï¼šç›´æ¥æ’å…¥æ’åºã€æŠ˜åŠæ’å…¥æ’åºã€å¸Œå°”æ’åº
  * èƒ½å¤Ÿä¿è¯ç›¸å¯¹å‡åºçš„åºåˆ—ï¼ˆæœ‰å¯èƒ½æ˜¯è·³è·ƒçš„ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯å‰é¢çš„i+1ä¸ª
* é€‰æ‹©ç±»æ’åºï¼šç®€å•é€‰æ‹©æ’åºã€å †æ’åº
  * å †æ’åºï¼šï¼ˆå¤§æ ¹å †ï¼‰æ¯æ¬¡é€‰æ‹©å †é¡¶å…ƒç´ æ”¾åœ¨æœ€åï¼ˆå’Œå †åº•å…ƒç´ äº¤æ¢ï¼‰ï¼Œæ¯æ¬¡å°†æœ€å¤§çš„å…ƒç´ æ”¾åœ¨æœ€åé¢
    * ç¬¬ä¸€è¶Ÿæ’åºæ˜¯å…ˆé¡ºåºå­˜è¿›ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè°ƒæ•´æˆä¸ºä¸€ä¸ªå¤§æ ¹å †ï¼Œå†æŠŠå®ƒé‚£ä¸ªæœ€å¤§çš„å…ƒç´ æ¢åˆ°æœ€åé¢ï¼Œå†æ¬¡è°ƒæ•´ä¸ºå¤§æ ¹å †çš„ç»“æœ
  * æ¯æ¬¡éƒ½æœ‰ä¸€ä¸ªå…ƒç´ è¢«æ”¾åœ¨æœ€ç»ˆä½ç½®
* äº¤æ¢ç±»æ’åºï¼šå†’æ³¡æ’åºã€å¿«é€Ÿæ’åº
  * æ¯æ¬¡æ ¹æ®é€†åºå¯¹è¿›è¡Œäº¤æ¢
  * å¿«é€Ÿæ’åºï¼š
    * æ¢å€¼ä¸€èˆ¬é€‰å–åºåˆ—çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
* ä¸ç¨³å®šæ’åºç®—æ³•çš„ç‰¹ç‚¹
  * å¯¹äºä¸€ç§æ’åºç®—æ³•ï¼Œæˆ‘ä»¬è¦äº¤æ¢å‰ä¸¤ä¸ªä½ç½®çš„æ—¶å€™ï¼Œå¦‚æœå®ƒçœ‹ä¸åˆ°å‰é¢æœ‰ä¸€ä¸ªå’Œä»–ç›¸åŒçš„å…ƒç´ ï¼Œå°±æœ‰å¯èƒ½å‡ºç°ä¸ç¨³å®š

### æŸ¥æ‰¾ç±»åº”ç”¨é¢˜

![](/img/205833.jpg)

* æŠ˜åŠæŸ¥æ‰¾
  * å…ƒç´ æœ‰åºï¼Œé¡ºåºè¡¨
* æ•£åˆ—æŸ¥æ‰¾æŸ¥æ‰¾å¤±è´¥çš„æƒ…å†µ
  * çº¿æ€§æ¢æµ‹æ³•ï¼ŒæŸ¥æ‰¾åˆ°ç©ºä½çš„æ—¶å€™è¯´æ˜æŸ¥æ‰¾å¤±è´¥ï¼Œæ¯”è¾ƒç©ºçš„æ•°ç»„å…ƒç´ ä¼šè®¡å…¥ä¸€æ¬¡æ¯”è¾ƒæ¬¡æ•°
  * é“¾åœ°å€æ³•ï¼Œæ¯”è¾ƒåˆ°ä¸€ä¸ªç©ºæŒ‡é’ˆçš„ä½ç½®æ‰æ˜¯æŸ¥æ‰¾å¤±è´¥ï¼Œä½†æ˜¯è¯¥æ¯”è¾ƒç©ºæŒ‡é’ˆä¸ä¼šç®—è¿›æ¯”è¾ƒæ¬¡æ•°
  * è£…å¡«å› å­åœ¨é“¾åœ°å€æ³•ä¸­å¯ä»¥å¤§äº1ï¼Œä½†æ˜¯å­˜å‚¨æ•ˆç‡ä¸€å®šæ˜¯å°äºç­‰äº100%çš„
  * æŸ¥æ‰¾æˆåŠŸçš„æ—¶å€™åˆ†æ¯æ˜¯å…ƒç´ æ•°é‡ï¼ŒæŸ¥æ‰¾å¤±è´¥çš„æ—¶å€™åˆ†æ¯æ˜¯å–æ¨¡åé¢çš„é‚£ä¸ªæ•°å­—ï¼ˆå› ä¸ºæ— æ³•æ˜ å°„åˆ°å…¶ä»–æ›´å¤§çš„æ•°å­—ï¼‰

![](/img/2213835.jpg)

* é“¾å¼å­˜å‚¨ï¼Œè€ƒè™‘äºŒå‰æœç´¢æ ‘
* é¡ºåºå­˜å‚¨ï¼Œé¡ºåºæŸ¥æ‰¾å’ŒæŠ˜åŠæŸ¥æ‰¾ï¼ˆæ³¨æ„æ’åºï¼‰æ¯”è¾ƒå¸¸è§

### æ ‘ç±»åº”ç”¨é¢˜

### å›¾ç±»åº”ç”¨é¢˜

### çº¿æ€§è¡¨ç±»åº”ç”¨é¢˜

## ç®—æ³•é¢˜

![](/img/fhiwqiyehfih.png)

![](/img/defewfqf.png)

![](/img/hntedehb.png)

* ç®—æ³•é¢˜
  * ä¸€é¢˜å¤šè§£ï¼Œåˆ†æ•°é«˜ä¸­ä½ä¸‰æ¡£
  * å¯ä»¥å…ˆå†™ç¬¬äºŒå°é—®å†å†™ç¬¬ä¸€å°é—®
  * é¡ºåºè¡¨å’Œé“¾è¡¨ä¸€èˆ¬æƒ…å†µä¸‹è¦è€ƒå¯Ÿæ—¶é—´å¤æ‚åº¦
  * æ ‘å’Œå›¾ä¸€èˆ¬ä¸è€ƒæ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦ï¼Œåˆ†æè¦æ±‚ä½ä¸€ç‚¹ï¼Œä½†ä¾æ—§è¦è®°å¾—
    * æ ‘å’Œå›¾èƒ½è§£å†³é—®é¢˜æ¯”é«˜æ•ˆè§£å†³é—®é¢˜æœ€é‡è¦ï¼Œåªè¦èƒ½è§£å†³é—®é¢˜ç¬¨æ–¹æ³•ä¹Ÿå¯ä»¥ï¼Œåªè¦èƒ½æŒæ¡å¸¸è§„ä»£ç å³å¯
* å¤‡è€ƒæ–¹æ³•
  * é˜¶æ®µä¸€ï¼šå®Œæˆå†å¹´çœŸé¢˜
  * é˜¶æ®µäºŒï¼šåˆ†æ¨¡å—è®­ç»ƒ
  * é˜¶æ®µä¸‰ï¼šå°‘é£Ÿå¤šé¤ï¼Œå¢åŠ åšé¢˜é‡
  * é˜¶æ®µå››ï¼šè€ƒå‰ä¿æŒæ‰‹æ„Ÿï¼Œå†åˆ·å†å¹´çœŸé¢˜

### æ’åº

![](/img/20043.jpg)

#### é¡ºåºè¡¨

* å¿«æ’å’Œå †æ’æ˜¯æ‰€æœ‰æ’åºç®—æ³•ä¸­æ•ˆç‡æœ€é«˜çš„ï¼Œä½†æ˜¯å¿«æ’ä»£ç ç®€å•ï¼Œå †æ’ä»£ç å¤æ‚ï¼Œæ‰€ä»¥å¿«æ’æœ€ä¼˜

* è€ƒè¯•æŒ‰ç…§æ—¶é—´å¤æ‚åº¦ç»™åˆ†

  * é€šå¸¸æ¥è¯´ï¼Œ408ç®—æ³•é¢˜ä¸ä¼šé™åˆ¶å…·ä½“ä½¿ç”¨å“ªç§ç®—æ³•
  * 408ç®—æ³•é¢˜é€šå¸¸æŒ‰ç…§å¤æ‚åº¦ç»™åˆ†ï¼Œå¤æ‚åº¦è¶Šä½ï¼Œç»™åˆ†è¶Šé«˜
  * è‹¥é¢˜ç›®æ²¡æœ‰ç‰¹åˆ«è¦æ±‚ï¼Œç­”é¢˜æ—¶å›ç­”â€œå¹³å‡å¤æ‚åº¦â€å³å¯

* å¥—è·¯å‹ç®—æ³•ï¼š

  * å¿«é€Ÿæ’åº
    * èƒ½å¿«æ’å°±å¿«æ’ï¼Œä¸èƒ½ç”¨å¿«æ’çš„å†è€ƒè™‘ç”¨å…¶ä»–æ’åº
    * å¿«æ’åªèƒ½åœ¨é¡ºåºè¡¨å’Œæ•°ç»„ï¼ˆé™æ€é“¾è¡¨ï¼‰ä¸­ä½¿ç”¨ï¼Œé“¾è¡¨å½“ä¸­ä¸èƒ½ç”¨å¿«æ’ï¼Œå› æ­¤å½“æ¶‰åŠé¡ºåºè¡¨ï¼ˆæ•°ç»„ï¼‰çš„é¢˜ç›®ï¼Œè€ƒè™‘èƒ½å¦ä½¿ç”¨åˆ°å¿«é€Ÿæ’åºã€‚
    * å¦‚æœé¢˜ç›®ä¸­ç»™çš„æ˜¯ä¸€ä¸ªä¹±åºæ•°ç»„çš„è¯ï¼Œå¦‚æœæŠŠè¿™ä¸ªä¹±åºæ•°ç»„å˜æˆæœ‰åºï¼Œæˆ‘ä»¬ç”¨å¿«æ’çš„å¥—è·¯ï¼Œå…ˆæŠŠå®ƒå˜æˆæœ‰åºï¼Œèƒ½å¦æ›´åŠ è½»æ¾çš„è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä»è¿™ä¸ªè§’åº¦æ€è€ƒ
    * æ—¶é—´å¤æ‚åº¦O(nlogn)

  ```c++
  void quick_sort(int q[], int l, int r)
  {
  if (l >= r) return;
  int i = l - 1, j = r + 1, x = q[l + r >> 1];
   while (i < j)
     {
          do i ++ ; while (q[i] < x);
          do j -- ; while (q[j] > x);
          if (i < j) swap(q[i], q[j]);
     }
      quick_sort(q, l, j), quick_sort(q, j + 1, r);
  }
  ```

  

  * å½’å¹¶æ’åº
    * æ—¶é—´å¤æ‚åº¦O(nlogn)
    * å¦‚æœæˆ‘ä»¬åœ¨è€ƒé¢˜å½“ä¸­é‡åˆ°æ’åºç±»çš„é¢˜ç›®ï¼Œè¦æ±‚æŠŠä¸€ä¸ªä¹±åºçš„æ•°ç»„æ’æˆä¸€ä¸ªæ›´å¤§çš„æ•°ç»„ï¼Œå¦‚æœè¿™ä¸ªæ•°ç»„æœ¬èº«éƒ¨åˆ†æœ‰åºï¼Œé‚£ä¹ˆæˆ‘ä»¬é‡‡ç”¨å½’å¹¶æ’åºæ¯”å¿«é€Ÿæ’åºæ›´åŠ ä¼˜ç§€

  ```c++
  void merge_sort(int q[], int l, int r)
  {
      if (l >= r) return;
  
      int mid = l + r >> 1;
      merge_sort(q, l, mid);
      merge_sort(q, mid + 1, r);
  
      int k = 0, i = l, j = mid + 1;
      while (i <= mid && j <= r)
          if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
          else tmp[k ++ ] = q[j ++ ];
  
      while (i <= mid) tmp[k ++ ] = q[i ++ ];
      while (j <= r) tmp[k ++ ] = q[j ++ ];
  
      for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
  
  }
  ```

  

  * å¿«é€Ÿæ’åºæ›´æ“…é•¿å°†ä¸€ä¸ªåŸæœ¬ä¹±åºçš„æ•°ç»„æ’æˆæœ‰åº
    * äºŒè·¯å½’å¹¶æ’åºæ›´æ“…é•¿å°†ä¸¤ä¸ªåŸæœ¬æœ‰åºçš„æ•°ç»„åˆå¹¶ä¸ºä¸€ä¸ªï¼Œæ—¶é—´å¤æ‚åº¦ä»…ä¸ºO(n)
    * é€šå¸¸æ¥è¯´ï¼Œå¯¹ä¹±åºæ•°ç»„çš„æ’åºï¼Œç”¨å½’å¹¶ä¸å¦‚ç”¨å¿«æ’
    * å¦‚æœé¢˜ç›®ä¸­ç»™çš„æ˜¯ä¸¤ä¸ªæœ‰åºè¡¨ï¼Œå¹¶ä¸”éœ€è¦å°†ä¸¤ä¸ªæœ‰åºè¡¨åˆå¹¶ä¸ºä¸€ä¸ªï¼Œå¯ä»¥è€ƒè™‘ç”¨å½’å¹¶æ€æƒ³

#### é“¾è¡¨

* ä¸æ”¯æŒéšæœºè®¿é—®ï¼Œç®—æ³•è¾ƒå°‘
* è€ƒå¯Ÿåå‘äºè€ƒåŸºæœ¬åŠŸ
  * æŒ‰ä½åºæŸ¥æ‰¾
  * æŒ‰å…³é”®å­—æ¡ä»¶æŸ¥æ‰¾+åˆ é™¤æŸä¸ªèŠ‚ç‚¹
  * æŒ‰å…³é”®å­—æ¡ä»¶æŸ¥æ‰¾+æ’å…¥æŸä¸ªèŠ‚ç‚¹
  * å¤´æ’æ³•ï¼ˆå¯å®ç°åŸåœ°é€†ç½®ï¼‰
  * å°¾æ’æ³•ï¼ˆä¿æŒåŸåºï¼‰

### æ ‘

* æŒæ¡å‰ä¸­ååºéå†ã€å±‚åºéå†ã€é€’å½’ç®—æ³•
  * éé€’å½’ç®—æ³•ä¸ç”¨æŒæ¡
  * åŸºäºè¿™äº›ç®—æ³•è§£å†³æ€ç»´å¯¼å›¾ä¸­åˆ—å‡ºçš„é—®é¢˜ï¼Œç„¶ååšä¸€ä¸‹ç‹é“ä¹¦çš„å‰©ä½™ç®—æ³•é¢˜

### å›¾

* æ•°æ®ç»“æ„å±‚é¢
  * é‚»æ¥çŸ©é˜µå’Œé‚»æ¥è¡¨çš„éå†
    * é‚»æ¥çŸ©é˜µå¯ä»¥forå¾ªç¯éå†
  * ä½†æ˜¯é‚»æ¥è¡¨åªèƒ½bfsæˆ–è€…dfs
  * é‚»æ¥å¤šé‡è¡¨å’Œåå­—é“¾è¡¨çš„å®šä¹‰
  
* ç®—æ³•å¤‡è€ƒ

  * æ ˆã€é˜Ÿåˆ—çš„æ•°ç»„è¡¨ç¤ºï¼ˆç”¨æ¥ç†è§£ä¸‹é¢çš„ä»£ç ï¼‰

  ```c++
  // ttè¡¨ç¤ºæ ˆé¡¶
  int stk[N], tt = 0;//stkè¡¨ç¤ºæ ˆï¼Œttè¡¨ç¤ºæ ˆé¡¶ä¸‹æ ‡
  
  // å‘æ ˆé¡¶æ’å…¥ä¸€ä¸ªæ•°
  stk[ ++ tt] = x;
  
  // ä»æ ˆé¡¶å¼¹å‡ºä¸€ä¸ªæ•°
  tt -- ;
  
  // æ ˆé¡¶çš„å€¼
  stk[tt];
  
  ```

// åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœ tt > 0ï¼Œåˆ™è¡¨ç¤ºä¸ä¸ºç©º
  if (tt > 0) not empty;
  else empty;

  //æ ˆé¡¶
  stk[tt];
  ```
  
  ```c++
  // hh è¡¨ç¤ºé˜Ÿå¤´ï¼Œttè¡¨ç¤ºé˜Ÿå°¾
  int q[N], hh = 0, tt = -1;
  
  // å‘é˜Ÿå°¾æ’å…¥ä¸€ä¸ªæ•°
  q[ ++ tt] = x;
  
  // ä»é˜Ÿå¤´å¼¹å‡ºä¸€ä¸ªæ•°
  hh ++ ;
  
  // é˜Ÿå¤´çš„å€¼
  q[hh];
  
  //å–å‡ºé˜Ÿå°¾
  q[tt];
  
  // åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœ hh <= ttï¼Œåˆ™è¡¨ç¤ºä¸ä¸ºç©º
  if (hh <= tt) not empty;
      else empty;
  
  ```

  ```c++
  //å¾ªç¯é˜Ÿåˆ—
  // hh è¡¨ç¤ºé˜Ÿå¤´ï¼Œttè¡¨ç¤ºé˜Ÿå°¾çš„åä¸€ä¸ªä½ç½®
  int q[N], hh = 0, tt = 0;
  
  // å‘é˜Ÿå°¾æ’å…¥ä¸€ä¸ªæ•°
  q[tt ++ ] = x;
  if (tt == N) tt = 0;
  
  // ä»é˜Ÿå¤´å¼¹å‡ºä¸€ä¸ªæ•°
  hh ++ ;
  if (hh == N) hh = 0;
  
// é˜Ÿå¤´çš„å€¼
  q[hh];

  // åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœhh != ttï¼Œåˆ™è¡¨ç¤ºä¸ä¸ºç©º
if (hh != tt)
  {
  
  }
  
  ```

  

  * DFSï¼ŒBFS

  ```c++
  bool st[N];
  int dfs(int u)
  {
      st[u] = true; // st[u] è¡¨ç¤ºç‚¹uå·²ç»è¢«éå†è¿‡
  
      for (int i = h[u]; i != -1; i = ne[i])//éå†ç‚¹çš„è¾¹
      {
          int j = e[i];//å­˜å‚¨å½“å‰é“¾è¡¨èŠ‚ç‚¹å¯¹åº”çš„å›¾é‡Œé¢çš„ç‚¹çš„ç¼–å·
          if (!st[j]) dfs(j);//jæ²¡æœ‰è¢«æœåˆ°ï¼Œç»§ç»­æœ
      }
  }
  ```

  ```c++
  queue<int> q;//åˆå§‹åŒ–
  st[1] = true; // è¡¨ç¤º1å·ç‚¹å·²ç»è¢«éå†è¿‡
  q.push(1);
  
  while (q.size())//é˜Ÿåˆ—ä¸ç©º
  {
      int t = q.front();
      q.pop();
  
      for (int i = h[t]; i != -1; i = ne[i])
      {
          int j = e[i];
          if (!st[j])
        {
              st[j] = true; // è¡¨ç¤ºç‚¹jå·²ç»è¢«éå†è¿‡
              q.push(j);
          }
      }
  }
  
  int bfs()
  {
  	int hh =0,tt=0;//å®šä¹‰é˜Ÿå¤´é˜Ÿå°¾
      q[0]=1;//qçš„ç¬¬ä¸€ä¸ªå…ƒç´ èµ·ç‚¹
      memset(d,-1,sizeof d);//åˆå§‹åŒ–è·ç¦»ï¼Œ-1è¡¨ç¤ºæ²¡æœ‰è¢«éå†è¿‡
      d[1]=0;//ç¬¬ä¸€ä¸ªç‚¹éå†
      while(hh<=tt){//é˜Ÿåˆ—ä¸ç©º
          int t=q[hh++]//å–åˆ°é˜Ÿå¤´
              for(int i = h[t];i!=-1;i=e[i])//æ‹“å±•é˜Ÿå¤´
              {
                  int j =e[i];//æ‹“å±•åˆ°é˜Ÿå¤´è¿æ¥çš„ä¸‹ä¸€ä¸ªç‚¹
                 if(d[j]==-1)//d[j]æ²¡æœ‰è¢«æ‹“å±•è¿‡
                 {
                     d[j]=d[t]+1;
                     q[++tt]=j;
                 }
              }
      }
      return 0;
  }
  ```

  

  * æ‹“æ‰‘æ’åº

  ```c++
  int n,m;
  int h[N],e[N],ne[N],idx;
  int d[N],q[N];//d[n]è¡¨ç¤ºå…¥åº¦ï¼Œq[n]æ˜¯æ‹“æ‰‘åºåˆ—
  void add(int a,int b){
      e[idx] = b;
      ne[idx] = h[a];
      h[a]=idx++;
      
  }
  bool topsort()
  {
      int hh = 0, tt = -1;
  
      // d[i] å­˜å‚¨ç‚¹içš„å…¥åº¦
      for (int i = 1; i <= n; i ++ )
          if (!d[i])
              q[ ++ tt] = i;//æ•°ç»„æ¨¡æ‹Ÿå…¥é˜Ÿ
  
      while (hh <= tt)//é˜Ÿåˆ—ä¸ç©º
      {
          int t = q[hh ++ ];//å–å‡ºæ¥é˜Ÿå¤´
  
          for (int i = h[t]; i != -1; i = ne[i])//æšä¸¾tçš„æ‰€æœ‰å‡ºè¾¹t->jï¼Œåˆ æ‰t->j
          {
              int j = e[i];//æ‰¾åˆ°å‡ºè¾¹
             d[j]--;
              if ( d[j] == 0)//å‰é¢çš„æ‰€æœ‰ç‚¹éƒ½å·²ç»æ’å¥½äº†
                  q[ ++ tt] = j;//jå…¥é˜Ÿ
           
          }
      }
  
      // å¦‚æœæ‰€æœ‰ç‚¹éƒ½å…¥é˜Ÿäº†ï¼Œè¯´æ˜å­˜åœ¨æ‹“æ‰‘åºåˆ—ï¼›å¦åˆ™ä¸å­˜åœ¨æ‹“æ‰‘åºåˆ—ã€‚
      return tt == n - 1;
  }
  //å‡ºé˜Ÿçš„é¡ºåºå°±æ˜¯æ‹“æ‰‘åº
  ```

### ä¸€ä¼‘çš„ç®—æ³•é¢˜å»ºè®®

#### è¯„åˆ†ç»†åˆ™

* é¡ºåºè¡¨ã€é“¾è¡¨æ³¨æ„å¤æ‚åº¦
  * åˆ†æ•°å·®åˆ«ä¸»è¦åœ¨äºæ—¶é—´å¤æ‚åº¦
* æ ‘ã€å›¾æ³¨æ„ç»†èŠ‚
  * åˆ†æ•°å·®åˆ«ä¸»è¦åœ¨äºç‰¹æ®Šæƒ…å†µæ˜¯å¦è€ƒè™‘åˆ°
* åºåˆ—å°±æ˜¯æ•°ç»„

#### ç­”é¢˜æŠ€å·§

* é¡ºåºè¡¨å’Œé“¾è¡¨

  * æš´åŠ›è§£
    * æšä¸¾
  * å…¶ä»–è§£
    * æœ‰åº
      * æŠ˜åŠæŸ¥æ‰¾
        * é“¾è¡¨ä¸é€‚ç”¨
        * é€‚ç”¨äºæœ‰åºæ•°ç»„
      * å¤šæŒ‡é’ˆæ³•ï¼ˆå½’å¹¶æ€æƒ³ï¼‰
    * æ— åº
      * æ•£åˆ—è¡¨
        * å…¸å‹åº”ç”¨ï¼šè®¡æ•°å™¨
      * å…ˆæ’åºå†æŒ‰æœ‰åºåš
      * å¿«æ’æ€æƒ³
  * ç›®æ ‡ï¼šå°½é‡ä¼˜åŒ–è‡ªå·±çš„ç®—æ³•ï¼Œè®©è‡ªå·±çš„å¤æ‚åº¦å˜ä½

* æ ‘

  * æ ¸å¿ƒæ˜¯éå†ï¼ˆé€’å½’ï¼‰
    * å…ˆåº
    * ä¸­åº
    * ååº
    * å±‚åº
  * å®é™…ä¸Šç‹é“ä¹¦ä¸Šçš„æ ‘çš„é€’å½’ç®—æ³•å¯ä»¥è·³è¿‡ï¼Œå› ä¸ºä¸åŒçš„å…ˆåºã€ååºã€ä¸­åºç®—æ³•éƒ½æ˜¯ä¸ä¸€æ ·çš„ï¼Œè¿˜æœ‰ä¸ä¸€æ ·çš„å†™æ³•ã€‚
    * å¦‚æœé€’å½’çš„è¯ï¼Œå…ˆä¸­åé€»è¾‘éƒ½æ˜¯ä¸€æ ·çš„ï¼Œå®é™…ä¸Šåªæœ‰ä¸‰è¡Œæ ¸å¿ƒä»£ç 

  ```c++
  //å…ˆåºï¼ˆæ ¹â†’å·¦â†’å³ï¼‰
  void preorder(btnode *p){
      if(p==NULL){
          return;
          visit(p);//å¯¹pç»“ç‚¹è®¿é—®ç­‰ï¼Œè¿™é“é¢˜çœŸæ­£è¦å†™çš„ä¸œè¥¿ï¼Œæ¯”å¦‚é¢˜ç›®è¦æ±‚æˆ‘ä»¬åšä»€ä¹ˆï¼Œæ ‘çš„æ¯é“é¢˜ä¸åŒçš„ç‚¹å°±åœ¨äºè¿™ä¸ªvisit
          preorder(p->lchild);
          preorder(p->rchild);
          //è¿™ä¸‰æ¡è¯­å¥ï¼Œvisitåœ¨å…ˆå°±æ˜¯å…ˆåºï¼Œåœ¨ä¸­å°±æ˜¯ä¸­åºï¼Œåœ¨åå°±æ˜¯ååº
      }
  }
  //ä¸­åºï¼ˆå·¦â†’æ ¹â†’å³ï¼‰
  void inorder(btnode *p){
      if(p==NULL)
          return ;
     inorder(p->lchild);
      visit(p);
      inorder(p->rchild);
  }
  //ååºï¼ˆå·¦â†’å³â†’æ ¹ï¼‰
  void postorder(btnode *p){
      if(p==NULL)
          return;
      postorder(p->lchild);
      postorder(p->rchild);
      visit(p);
  }
  ```

  

* å›¾

  * åŸºæœ¬éå†
  * æœ€å°ç”Ÿæˆæ ‘

  ```c++
  //æ™®åˆ©å§†primç®—æ³•,æ—¶é—´å¤æ‚åº¦O(n^2)
  int n;      // nè¡¨ç¤ºç‚¹æ•°
  int g[N][N];        // é‚»æ¥çŸ©é˜µï¼Œå­˜å‚¨æ‰€æœ‰è¾¹
  int dist[N];        // å­˜å‚¨å…¶ä»–ç‚¹åˆ°å½“å‰æœ€å°ç”Ÿæˆæ ‘çš„è·ç¦»
  bool st[N];     // å­˜å‚¨æ¯ä¸ªç‚¹æ˜¯å¦å·²ç»åœ¨ç”Ÿæˆæ ‘ä¸­
  
  //åˆ°é›†åˆçš„è·ç¦»å°±æ˜¯ä¸€ä¸ªç‚¹è¿æ¥é›†åˆçš„æ‰€æœ‰è¾¹ä¸­æœ€çŸ­çš„é‚£ä¸€æ¡
  // å¦‚æœå›¾ä¸è¿é€šï¼Œåˆ™è¿”å›INF(å€¼æ˜¯0x3f3f3f3f), å¦åˆ™è¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æ ‘è¾¹æƒé‡ä¹‹å’Œ
  int prim()
  {
      memset(dist, 0x3f, sizeof dist);//åˆå§‹åŒ–æœ€çŸ­è·ç¦»
  
      int res = 0;
      for (int i = 0; i < n; i ++ )//næ¬¡è¿­ä»£
      {
          int t = -1;//ä¸åœ¨é›†åˆå½“ä¸­çš„è·ç¦»æœ€å°ç‚¹çš„ç¼–å·
          for (int j = 1; j <= n; j ++ )
              if (!st[j] && (t == -1 || dist[t] > dist[j]))
                  t = j;
  
          if (i && dist[t] == INF) return INF;
  
          if (i) res += dist[t];//åªè¦ä¸æ˜¯ç¬¬ä¸€ä¸ªç‚¹
          st[t] = true;
  
          for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
      }
  
      return res;
  }
  ```

  ```c++
  //å…‹é²æ–¯å¡å°”Kruskalç®—æ³•,æ—¶é—´å¤æ‚åº¦O(mlogn)
  int n, m;       // næ˜¯ç‚¹æ•°ï¼Œmæ˜¯è¾¹æ•°
  int p[N];       // å¹¶æŸ¥é›†çš„çˆ¶èŠ‚ç‚¹æ•°ç»„
  
  struct Edge     // å­˜å‚¨è¾¹
  {
      int a, b, w;
  
      bool operator< (const Edge &W)const//é‡è½½å°äºå·
      {
          return w < W.w;
      }
  }edges[M];
  
  int find(int x)     // å¹¶æŸ¥é›†æ ¸å¿ƒæ“ä½œ
  {
      if (p[x] != x) p[x] = find(p[x]);
      return p[x];
  }
  
  int kruskal()
  {
      sort(edges, edges + m);//æŠŠæ‰€æœ‰è¾¹æ’åº
  
      for (int i = 1; i <= n; i ++ ) p[i] = i;    // åˆå§‹åŒ–å¹¶æŸ¥é›†
  
      int res = 0, cnt = 0;
      for (int i = 0; i < m; i ++ )//ä»å°åˆ°å¤§æšä¸¾æ‰€æœ‰è¾¹
      {
          int a = edges[i].a, b = edges[i].b, w = edges[i].w;
  
          a = find(a), b = find(b);//è®©aï¼Œbåˆ†åˆ«ç­‰äºç¥–å®—èŠ‚ç‚¹
          if (a != b)     // å¦‚æœä¸¤ä¸ªè¿é€šå—ä¸è¿é€šï¼Œåˆ™å°†è¿™ä¸¤ä¸ªè¿é€šå—åˆå¹¶
          {
              p[a] = b;//åˆå¹¶ä¸¤ä¸ªè¿é€šå—
              res += w;//å­˜çš„æ˜¯æœ€å°ç”Ÿæˆæ ‘ä¸­æ‰€æœ‰æ ‘è¾¹çš„æƒé‡ä¹‹å’Œ
              cnt ++ ;//å­˜çš„æ˜¯å½“å‰åŠ å…¥äº†å¤šæ—¶å°‘æ¡è¾¹
          }
      }
  
      if (cnt < n - 1) return INF;//å›¾ä¸æ˜¯è”é€šçš„
      return res;//è¾“å‡ºæ‰€æœ‰æ ‘è¾¹çš„æƒé‡ä¹‹å’Œ
  }
  ```

  * æœ€çŸ­è·¯å¾„

  ```c++
  //æœ´ç´ dijkstraç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦O(n^2)
  int g[N][N];  // å­˜å‚¨æ¯æ¡è¾¹
  int dist[N];  // å­˜å‚¨1å·ç‚¹åˆ°æ¯ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»
  bool st[N];   // å­˜å‚¨æ¯ä¸ªç‚¹çš„æœ€çŸ­è·¯æ˜¯å¦å·²ç»ç¡®å®š
  
  // æ±‚1å·ç‚¹åˆ°nå·ç‚¹çš„æœ€çŸ­è·¯ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å›-1
  int dijkstra()
  {
      memset(dist, 0x3f, sizeof dist);//åˆå§‹åŒ–å…¶ä»–è·ç¦»
      dist[1] = 0;//åˆå§‹åŒ–ç¬¬ä¸€ä¸ªç‚¹çš„è·ç¦»
  
      for (int i = 0; i < n - 1; i ++ )
      {
          int t = -1;     // åœ¨è¿˜æœªç¡®å®šæœ€çŸ­è·¯çš„ç‚¹ä¸­ï¼Œå¯»æ‰¾è·ç¦»æœ€å°çš„ç‚¹
          for (int j = 1; j <= n; j ++ )
              if (!st[j] && (t == -1 || dist[t] > dist[j]))//å½“å‰ç‚¹è¿˜æ²¡æœ‰ç¡®å®šæœ€çŸ­è·¯ï¼›æ²¡æœ‰èµ‹å€¼æˆ–è€…ä¸æ˜¯æœ€çŸ­çš„
                  t = j;//èµ‹å€¼
    // if(t==n)break;//ä¼˜åŒ–å¯ä»¥åŠ ä¸Š
          // ç”¨tæ›´æ–°å…¶ä»–ç‚¹çš„è·ç¦»
          for (int j = 1; j <= n; j ++ )
              dist[j] = min(dist[j], dist[t] + g[t][j]);
  //åˆ¤æ–­é•¿åº¦ï¼Œå¾—å‡ºæœ€å°è·ç¦»å¹¶æ›´æ–°
          st[t] = true;
      }
  
      if (dist[n] == 0x3f3f3f3f) //ä¸è¿é€š
          return -1;
      return dist[n];
  }
  //è¾“å…¥è¾“å‡º
  cin >> n>>m;
  memset(g,0x3f,sizeof g);
  while(m--){
      int a,b,c;
      cin>>a>>b>>c;
      g[a][b]=min(g[a][b],c);
  }
  int t =dijkstra()l
      cout<<t;
  return 0;
  ```

  ```c++
  //å †ä¼˜åŒ–ç‰ˆdijkstraç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦O(mlogn)
  typedef pair<int, int> PII;
  
  int n;      // ç‚¹çš„æ•°é‡
  int h[N], w[N], e[N], ne[N], idx;       // é‚»æ¥è¡¨å­˜å‚¨æ‰€æœ‰è¾¹
  int dist[N];        // å­˜å‚¨æ‰€æœ‰ç‚¹åˆ°1å·ç‚¹çš„è·ç¦»
  bool st[N];     // å­˜å‚¨æ¯ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»æ˜¯å¦å·²ç¡®å®š
  
  void add(int a,int b,int c){
      e[idx]=b,w[idx]= c,ne[idx]=h[a],h[a]=idx++;
  }
  // æ±‚1å·ç‚¹åˆ°nå·ç‚¹çš„æœ€çŸ­è·ç¦»ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œåˆ™è¿”å›-1
  int dijkstra()
  {
      memset(dist, 0x3f, sizeof dist);
      dist[1] = 0;
      priority_queue<PII, vector<PII>, greater<PII>> heap;//å®šä¹‰å°æ ¹å †
      heap.push({0, 1});      // firstå­˜å‚¨è·ç¦»ï¼Œsecondå­˜å‚¨èŠ‚ç‚¹ç¼–å·
  
      while (heap.size())//å †é‡Œé¢éç©º
      {
          auto t = heap.top();
          heap.pop();
  
          int ver = t.second, distance = t.first;//ç¼–å·ï¼›è·ç¦»
  
          if (st[ver]) continue;//å†—ä½™å¤‡ä»½
          st[ver] = true;
  
          for (int i = h[ver]; i != -1; i = ne[i])
          {
              int j = e[i];
              if (dist[j] > distance + w[i])
              {
                  dist[j] = distance + w[i];//æ›´æ–°è·ç¦»
                  heap.push({dist[j], j});//æ”¾å…¥å †
              }
          }
      }
  
      if (dist[n] == 0x3f3f3f3f) return -1;
      return dist[n];
  }
  int main(){
      cin >> n>>m;
      memset(h,-1,sizeof h);
      while(m--){
          int a,b,c;
          cin >> a >> b>>c;
          add(a,b,c);
      }
      int t = dijkstra();
      cout<<t;
      return 0;
  }
  ```

  ```c++
  //Floydç®—æ³•,æ—¶é—´å¤æ‚åº¦O(n^3)
  cosnt int INF=1e9;
  åˆå§‹åŒ–ï¼š
      for (int i = 1; i <= n; i ++ )
          for (int j = 1; j <= n; j ++ )
              if (i == j) d[i][j] = 0;
              else d[i][j] = INF;
  
  // ç®—æ³•ç»“æŸåï¼Œd[a][b]è¡¨ç¤ºaåˆ°bçš„æœ€çŸ­è·ç¦»
  void floyd()
  {
      for (int k = 1; k <= n; k ++ )
          for (int i = 1; i <= n; i ++ )
              for (int j = 1; j <= n; j ++ )
                  d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
  }
  
  ```

  

  * æ‹“æ‰‘æ’åº
  * å…³é”®è·¯å¾„
  * ç›®æ ‡ï¼šè€ƒè™‘ä¸€äº›ç»†èŠ‚æ˜¯å¦åˆ°ä½

* èƒ½ä¸èƒ½ç›´æ¥è°ƒç”¨å‡½æ•°

  * 5è¡Œä»¥ä¸‹çš„éšä¾¿è°ƒç”¨

  ```c++
  pop();
  push();
  swap(a,b);
  abs();
  pow(x,y);//xçš„yæ¬¡å¹‚
  sqrt();//å¹³æ–¹æ ¹
  ```

  

* è¿‡ç¨‹
  
  * è€ƒå‰æœ€å¥½å¤ä¹ ä¸€éå¸¸ç”¨çš„ç®—æ³•æ¨¡æ¿

```c++
//å…ˆå‡è®¾æ‰€ç”¨å‡½æ•°å·²ç»è®¾ç«‹ï¼Œç„¶ååœ¨ä¸»å‡½æ•°é‚£é‡Œç›´æ¥ç”¨ï¼Œç”¨å®Œå†å›å»å†™è¯¥å‡½æ•°
//å¦‚å‡å¦‚è¦ç”¨æŠ˜åŠæŸ¥æ‰¾ï¼Œå…ˆ
int binary(){
//å…ˆç•™ç©ºï¼Œä¸‹é¢çš„anså‡½æ•°å†™å®Œå†å›æ¥å†™
}
int ans(int s[],int n ,int k){
//ç­”æ¡ˆ
}
```

* ç©ºé—´å¤æ‚åº¦çš„åˆ†æ
  * ç”³è¯·äº†å“ªäº›æ•°ç»„
  * ç”³è¯·äº†å“ªäº›ç»“ç‚¹
  * é€’å½’çš„æ—¶å€™æœ‰å¤šå°‘å±‚çš„é€’å½’ï¼ˆæ ‘çš„é«˜åº¦ï¼Œé€’å½’çš„å±‚æ•°ï¼‰

### æ ˆã€é˜Ÿåˆ—çš„ä¸€äº›ä»£ç æ¨¡æ¿

#### æ•°ç»„å®ç°æ ˆ

```c++
//æ•°ç»„å®ç°æ ˆ

//åˆå§‹åŒ–æ ˆ
int stk[N],tt=0;
//å…¥æ ˆ
stk[++tt]=x;
//å¼¹å‡ºæ ˆé¡¶å…ƒç´ ä½†æ˜¯ä¸å‡ºæ ˆ
x=stk[tt];
//å¼¹å‡ºæ ˆé¡¶å…ƒç´ å¹¶ä¸”å‡ºæ ˆ
x=stk[tt--];
//åˆ¤æ–­æ ˆç©º
if(tt==0)
//åˆ¤æ–­æ ˆæ»¡
if(tt==maxsize)
```

#### é“¾è¡¨å®ç°æ ˆ

```c++
//é“¾è¡¨å®ç°æ ˆ

//å®šä¹‰æ ˆç»“ç‚¹
struct Lnode{
    int data;
    Lnode* next;
};
using listack=Lnode*;
//åˆå§‹åŒ–é“¾è¡¨å®ç°æ ˆ
bool initstack(listack &s){
  s=new Lnode;
    s->next=nullptr;
    return true;
}
//æ ˆç©º
bool isempty(listack s){
    if(s->next==nullptr)
        return true;
    else 
        return false;
    
    
}
//å…¥æ ˆ
bool push(listack &s,int x){
    Lnode *p=new Lnode;
    p->data= x;
    p->next=s->next;
    s->next=p;
    return true;
}
//å‡ºæ ˆ
bool pop(listack &s,int &x){
    if(isempty(s)) return false;
    Lnode *p=s->next;
    x=p->data;
    s->next=p->next;
    delete p;
    return true;
}

```

#### åŒå‘é“¾è¡¨å®ç°æ ˆï¼ˆæ ˆé¡¶åœ¨é“¾å°¾ï¼‰

```c++
//åŒé“¾è¡¨å®ç°æ ˆï¼Œæ ˆé¡¶åœ¨é“¾å°¾

//å®šä¹‰åŒé“¾è¡¨ç»“ç‚¹
struct dnode{
    int data;
    dnode*pre,*next;
};
//å®šä¹‰æ ˆ
struct dstack{
    dnode *head,*rear;
};
using stk=dstack*;
//åˆå§‹åŒ–ä¸€ä¸ªé“¾æ ˆï¼ˆåŒé“¾è¡¨å®ç°ï¼Œæ ˆé¡¶åœ¨é“¾å°¾ï¼‰
bool init(stk &s){
    s=new dstack;//åˆå§‹åŒ–ä¸€ä¸ªé“¾æ ˆï¼ŒåŒé“¾è¡¨å®ç°ï¼Œæ ˆé¡¶åœ¨é“¾å°¾ï¼‰
    dnode *p=new dnode;
    p->next=nullptr;
    p->pre=nullptr;
    s->head=p;
    s->rear=p;
    return true;
}
//åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º
bool isempty(stk s){
    if(s->head==s->rear)
        return true;
    else 
        return false;
}
//å…¥æ ˆï¼ˆåœ¨åŒé“¾è¡¨é“¾å°¾æ’å…¥ï¼‰
bool push(stk &s,int x){
    dnode *p=new dnode;
    p->data=x;
    p->next=nullptr;
    p->pre=s->rear;
    s->rear->next=p;
    s->rear=p;
    return true;
}
//å‡ºæ ˆï¼ˆåˆ é™¤åŒé“¾è¡¨é“¾å°¾å…ƒç´ ï¼‰
bool pop(stk &s,int &x){
    if(isempty(s))
        return false;
    dnode *p=s->rear;
    x=p->data;
    s->rear=p->pre;
    s->rear->next=nullptr;
    delete p;
    return true;
}
```

#### æ•°ç»„å®ç°å¾ªç¯é˜Ÿåˆ—

```c++
//æ•°ç»„å®ç°å¾ªç¯é˜Ÿåˆ—

//å®šä¹‰é˜Ÿåˆ—
const int maxsize =100;
struct queue{
    int data[maxsize];
    int rear,head;
};

//åˆå§‹åŒ–é˜Ÿåˆ—
void init(queue &q){
    q.rear=q.head=0;
}

//åˆ¤æ–­é˜Ÿç©º
bool isempty(queue q){
    if(q.head==q.rear)
		return true;
    else 
        return false;
    
}
//åˆ¤æ–­é˜Ÿæ»¡
bool isfull(queue q){
    if((q.rear+1)%maxsize==q.head)
        return true;
    else return false;
}
//å…¥é˜Ÿ
bool inqueue(queue &q,int x){
    if(isfull(q))return false;
    q.data[q.rear]=x;
    q.rear=(q.rear+1)%maxsize;
    return true;
}
//å‡ºé˜Ÿ
bool outqueue(queue &q,int &x){
    if(isempty(q)) return false;
    x=q.data[q.head];
    q.head=(q.head+1)%maxsize;
    return true;
}

```

#### å•é“¾è¡¨å®ç°é˜Ÿåˆ—

```c++
//å•é“¾è¡¨å®ç°é˜Ÿåˆ—

//å®šä¹‰é“¾è¡¨é˜Ÿåˆ—èŠ‚ç‚¹
struct qnode{
    int data;
    qnode *next;  
};

//å®šä¹‰é˜Ÿåˆ—
struct listqueue{
    qnode*head,*rear;
};
using lq=listqueue*;

//åˆå§‹åŒ–é˜Ÿåˆ—
bool init(lq &q){
    q=new listqueue;
    qnode *p=new qnode;
    q->head=p;
    q->rear=p;
    p->next=nullptr;
    return true;
}
//åˆ¤ç©º
bool isempty(lq q){
    return q->head==q->rear;
}

//å…¥é˜Ÿ
bool inqueue(lq &q,int x){
    qnode *p=new qnode;
  	p->data=x;
    p->next=nullptr;
    q->rear->next=p;
    q->rear=p;
    return true;
}

//å‡ºé˜Ÿ
bool outqueue(lq &q,int &x){
    if(isempty(q))return false;
    qnode *p=q->head->next;
    x=p->data;
    q->head->next=p->next;
    if(q->head->next==nullptr)
        q->rear=q->head;
    delete p;
    return true;
    
}
```

### æ ‘çš„ä¸€äº›ä»£ç æ¨¡æ¿

#### æ•°ç»„å®ç°äºŒå‰æ ‘

```c++
//æ•°ç»„å®ç°äºŒå‰æ ‘(ä¸‹æ ‡ä»1å¼€å§‹)

//å®šä¹‰æ ‘ç»“ç‚¹
struct treenode{
	int data;
    bool empty;
};
//åˆå§‹åŒ–äºŒå‰æ ‘
void init(treenode t[],int length){
    for(int i = 0;i<length;i++)
        t[i].empty=true;
}
int main(){
    treenode t[100];
    init(t,100);
}
//åˆ¤ç©ºæ ‘ç»“ç‚¹
bool isempty(treenode t[],int length,int x){
    if(x>=length || x<1) return true;
    return t[x].empty;
}
//æ‰¾åˆ°ç»“ç‚¹çš„å·¦å­©å­
int findlkid(treenode t[],int length,int x){
    int lkid = x*2;
    if(isempty(t,length,lkid))return -1;
    return lkid;
    
}
//æ‰¾åˆ°ç»“ç‚¹çš„å³å­©å­
int findrkid(treenode t[],int length,int x){
    int rkid = x*2+1;
    if(isempty(t,length,rkid))return -1;
    return rkid;
}

//æ‰¾åˆ°ç»“ç‚¹çš„å®¶é•¿ç»“ç‚¹
int findparent(treenode t[],int length,int x){
    if(x==1)return -1;
    int parent=x/2;
    if(isempty(t,length,parent))return -1;
    return parent;
}
```

```c++
//æ•°ç»„å®ç°äºŒå‰æ ‘ï¼ˆä¸‹æ ‡ä»0å¼€å§‹ï¼‰

//å®šä¹‰æ ‘ç»“ç‚¹
struct treenode{
	int data;
	bool empty;
};
//åˆå§‹åŒ–
void init(treenode t[],int length){
	for(int i= 0;i<length;i++)
		t[i].empty=true;
}
int main(){
	treenode t[100];
	init(t,100);
    return 0;
}
//åˆ¤ç©º
bool isempty(treenode t[],int length,int x){
	if(x<0 || x>=length) return true;
	return t[x].empty;
}
//å¯»æ‰¾å®¶é•¿èŠ‚ç‚¹
int findparent(treenode t[],int length,int x){
	if(x==0)return -1;
	int parent=(x-1)>>1;
	if(isempty(t,length,parent))return -1;
	return parent;
}
//å¯»æ‰¾å·¦å­©å­
int findlkid(treenode t[],int length,int x){
	int lkid = x*2+1;
	if(isempty(t,length,lkid))return -1;
	return lkid;
}

//å¯»æ‰¾å³å­©å­
int findrkid(treenode t[],int length,int x){
	int rkid=x*2+2;
	if(isempty(t,length,rkid))return -1;
	return rkid;
}
```



#### äºŒå‰æ ‘çš„å…ˆä¸­ååºéå†

##### å…ˆåºéå†

```c++
void visitnode(treenode &x);
void preorder(treenode t[],int length,int x){
        if(isempty(t,lengt,x))return;   
            visitnode(t[x]);
            preorder(t,length,getlkid(t,length,x));
            preorder(t,length,getrkid(t,length,x));
}
```



##### ä¸­åºéå†

```c++
void visitnode(treenode &x);
void inorder(treenode t[],int length,int x){
    if(isempty(t,length,x)) return;
    inorder(t,length,getlkid(t,length,x));
    visitnode(t[x]);
    inorder(t,length,getrkid(t,length,x));
}
```



##### ååºéå†

```c++
void visitnode(treenode &x);
void postorder(treenode t[],int length,int x){
  if(isempty(t,length,x)) return;
  postorder(t,length,getlkid(t,length,x));
  postorder(t,length,getrkid(t,length,x));
  visitnode(t[x]);
}
```

#### æ ‘çš„å­˜å‚¨ç»“æ„

##### åŒäº²è¡¨ç¤ºæ³•

```c++
//å®šä¹‰æ ‘ç»“ç‚¹
const int maxsize=100;
struct ptnode{
    int data;
    int parent;
};
//å®šä¹‰æ ‘
struct ptree{
    ptnode nodes[maxsize];
    int n;
};
```

##### å­©å­è¡¨ç¤ºæ³•

```c++
//å®šä¹‰å­©å­ç»“ç‚¹
const int maxsize=100;
struct kidnode{
    int index;
    kidnode *next;
};
//å®šä¹‰å®¶é•¿ç»“ç‚¹
struct parentnode{
	int data;
    kidnoe *firstkid;
}tree[maxsize];
```



##### å­©å­å…„å¼Ÿè¡¨ç¤ºæ³•

```c++
//å®šä¹‰ç»“ç‚¹
struct node{
    int data;
    node*firstkid,*nextbrother;
};
using tree=node*;
```

#### å¹¶æŸ¥é›†

```c++
//å®šä¹‰å¹¶æŸ¥é›†
const int N=100;
int size[N],p[N];
//åˆå§‹åŒ–å¹¶æŸ¥é›†
void init(int size[],int p[],int length){
    for(int i= 1;i<=length;i++)
    {
        size[i]=1;
        p[i]=i;
    }
}
//æŸ¥
int find(int x){
    if(p[x]!=x) p[x]=find(p[x]);
    return p[x];
}
//å¹¶
void merge(int a,int b){
    int r1=find(a);
    int r2=find(b);
    if(r1==r2)return;
    if(size[r1]>=size[r2]){
        p[r2]=r1;
        size[r1]+=size[r2];
    }
    else{
        p[r1]=r2;
        size[r2]+=size[r1];
    }
}
```

### å›¾çš„ä¸€äº›ä»£ç æ¨¡æ¿

#### é‚»æ¥çŸ©é˜µå®ç°å›¾çš„é¡ºåºå­˜å‚¨

```c++
//å®šä¹‰é‚»æ¥çŸ©é˜µ
const int N =100;
struct graph{
    int n,e;
    char vex[N];
    int weight[N][N];
};
```



#### é‚»æ¥è¡¨å®ç°å›¾çš„é“¾å¼å­˜å‚¨

```c++
const int N=100;
//å®šä¹‰å¼§ç»“ç‚¹
struct arcnode{
    int adjvex;//å¼§å¤´ç»“ç‚¹çš„ç¼–å·
    arcnode*nextarc;//æŒ‡å‘ä¸‹ä¸€æ¡è¾¹çš„æŒ‡é’ˆ
    int info;//ç”¨æ¥è®°å½•è¾¹çš„æƒå€¼ç­‰ä¿¡æ¯
};
//å®šä¹‰é¡¶ç‚¹ç»“ç‚¹
struct vnode{
    char data;//ç»“ç‚¹æ‰€å­˜å‚¨çš„å­—æ¯
    arcnode *firstarc;//ç»“ç‚¹æŒ‡å‘çš„ç¬¬ä¸€æ¡è¾¹
}
//å®šä¹‰é‚»æ¥è¡¨
struct graph{
    vnode adjlist[N];//é¡¶ç‚¹ç»“ç‚¹æ•°ç»„
    int n,e;//è¾¹å’Œé¡¶ç‚¹çš„æ•°é‡
};
```

#### dijkstraç®—æ³•çš„æ–‡å­—è¿‡ç¨‹æè¿°

```c++
/*
ä»é¡¶ç‚¹x1å‡ºå‘ï¼Œè¿è¡Œdijkstraç®—æ³•çš„è¿‡ç¨‹å¦‚ä¸‹ï¼š
ç¬¬ä¸€è½®ï¼šé¡¶ç‚¹x1åˆ°x2çš„æœ€çŸ­è·¯å¾„ä¸º1â†’2ï¼Œè·ç¦»ä¸ºa
ç¬¬nè®ºï¼šä¸å­˜åœ¨é¡¶ç‚¹x1åˆ°é¡¶ç‚¹x2çš„è·¯å¾„ï¼Œè·ç¦»ä¸ºâˆ
*/
```

#### bfsç®—æ³•çš„æ–‡å­—è¿‡ç¨‹æè¿°

```c++
    A
   / \
  B - C
  |   |
  D - E
       \
        F
//å›¾çš„ç»“æ„
/*
æ–‡å­—æè¿°ï¼šç”¨BFSç®—æ³•æ±‚å•æºæœ€çŸ­è·¯å¾„çš„è¿‡ç¨‹
åˆå§‹åŒ–ï¼šè®¾ç½®ä¸€ä¸ªé˜Ÿåˆ—queueï¼Œç”¨æ¥å­˜å‚¨è¦è®¿é—®çš„ç»“ç‚¹ï¼Œä»¥Aä¸ºèµ·ç‚¹ï¼Œèµ·ç‚¹Aå…¥é˜Ÿï¼Œvisit[A]=1,dist[A]=0

ç¬¬ä¸€è½®ï¼šé˜Ÿå¤´æ˜¯Aï¼Œå‡ºé˜Ÿï¼Œå°†Açš„ç›¸é‚»ç»“ç‚¹Bå’ŒCå…¥é˜Ÿï¼Œæ›´æ–°dist[B]=1,dist[C]=1,visit[B]=1,visit[C]=1

ç¬¬äºŒè½®ï¼šé˜Ÿå¤´æ˜¯Bï¼Œå‡ºé˜Ÿï¼Œå°†Bçš„ç›¸é‚»æœªè®¿é—®èŠ‚ç‚¹Då…¥é˜Ÿï¼Œdist[D]=2;visit[D]=1

ç¬¬ä¸‰è½®ï¼šé˜Ÿå¤´æ˜¯Cï¼Œå‡ºé˜Ÿï¼Œå°†Cçš„ç›¸é‚»æœªè®¿é—®ç»“ç‚¹Eå…¥é˜Ÿï¼Œdist[E]=2ï¼›visit[E]=1

ç¬¬å››è½®ï¼šé˜Ÿå¤´æ˜¯Dï¼Œå‡ºé˜Ÿï¼ŒDæ— ç›¸é‚»æœªè®¿é—®èŠ‚ç‚¹

ç¬¬äº”è½®ï¼šé˜Ÿå¤´æ˜¯Eï¼Œå‡ºé˜Ÿï¼Œå°†Eçš„ç›¸é‚»æœªè®¿é—®èŠ‚ç‚¹Få…¥é˜Ÿï¼Œdist[F]=3;visit[F]=1;
*/
```

#### æ‹“æ‰‘æ’åºçš„æ–‡å­—è¿‡ç¨‹æè¿°

```c++
/*
æ‹“æ‰‘æ’åºï¼š
1ã€ä»AOVç½‘ä¸­é€‰æ‹©ä»»æ„ä¸€ä¸ªå…¥åº¦ä¸º0çš„ç‚¹ï¼Œå¹¶å°†å…¶åŠ å…¥æ‹“æ‰‘åºåˆ—
2ã€åœ¨AOVç½‘ä¸­åˆ é™¤è¯¥ç‚¹å’Œä»¥è¯¥ç‚¹ä¸ºèµ·ç‚¹çš„æœ‰å‘è¾¹
3ã€é‡å¤ä¸Šè¿°è¿‡ç¨‹ç›´åˆ°AOVç½‘ä¸ºç©º

é€†æ‹“æ‰‘æ’åºï¼š
1ã€ä»AOVç½‘ä¸­é€‰æ‹©ä»»æ„ä¸€ä¸ªå‡ºåº¦ä¸º0çš„ç‚¹ï¼Œå¹¶å°†å…¶åŠ å…¥æ‹“æ‰‘åºåˆ—
2ã€åœ¨AOVç½‘ä¸­åˆ é™¤è¯¥ç‚¹å’Œä»¥è¯¥ç‚¹ä¸ºèµ·ç‚¹çš„æœ‰å‘è¾¹
3ã€é‡å¤ä¸Šè¿°è¿‡ç¨‹ç›´åˆ°AOVç½‘ä¸ºç©º
*/
```

#### å…³é”®é•¿åº¦çš„æ„ä¹‰

```c++
/*AOEç½‘çš„é¡¶ç‚¹ä»£è¡¨æ—¶é—´ï¼Œå¸¦æƒè¾¹ä»£è¡¨æ´»åŠ¨ï¼Œå…³é”®è·¯å¾„çš„é•¿åº¦ä»£è¡¨çš„æ˜¯
ä¸€ä¸ªé¡¹ç›®ä»å¼€å§‹åˆ°ç»“æŸè‡³å°‘éœ€è¦å¤šé•¿æ—¶é—´
```

#### æœ´ç´ ç‰ˆprimç®—æ³•

```c++
//
const int N=1000;
int n;
int g[N][N];
int dist[N];
bool st[N];
int prim(){
    int res=0;
    memset(dist,0x3f,sizeof(dist));
    for(int i = 0;i<n;i++){
        int t=-1;
        for(int j = 1;j<=n;j++)
            if(!st[j]&&(t==-1 || dist[t]>dist[j]))
                t=j;
        if(i && dist[t]==INF)return INF;
        if(i) res+=dist[t];
        st[t]=true;
        for(int j  = 1;j<=n;j++)
            dist[j]=min(dist[j],g[t][j]);
    }
    return res;
}
```

#### 408å›¾è®ºç®—æ³•å¤æ‚åº¦+é€‚ç”¨åœºæ™¯ï¼ˆå«è´Ÿæƒè¾¹/è´Ÿç¯ï¼‰

| ç®—æ³• / å­˜å‚¨ç»“æ„                   | æ—¶é—´å¤æ‚åº¦            | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯                                                     | è¯´æ˜                                      |
| --------------------------------- | --------------------- | ---------- | ------------------------------------------------------------ | ----------------------------------------- |
| **é‚»æ¥çŸ©é˜µ**                      | â€”â€”                    | **O(VÂ²)**  | ç¨ å¯†å›¾                                                       | æŸ¥è¯¢è¾¹æ˜¯å¦å­˜åœ¨å¿« O(1)ï¼Œéå†æ…¢ O(V)        |
| **é‚»æ¥è¡¨**                        | â€”â€”                    | **O(V+E)** | ç¨€ç–å›¾                                                       | éå†å¿« O(V+E)ï¼ŒæŸ¥è¯¢è¾¹æ˜¯å¦å­˜åœ¨æ…¢ O(deg(v)) |
| **åå­—é“¾è¡¨**ï¼ˆæœ‰å‘å›¾ï¼‰            | â€”â€”                    | **O(V+E)** | éœ€è¦åŒæ—¶é«˜æ•ˆå¤„ç†å‡ºåº¦å’Œå…¥åº¦çš„æœ‰å‘å›¾                           | æ¯æ¡è¾¹å­˜ä¸¤æ¬¡å¼•ç”¨                          |
| **é‚»æ¥å¤šé‡è¡¨**ï¼ˆæ— å‘å›¾ï¼‰          | â€”â€”                    | **O(V+E)** | éœ€è¦é¿å…æ— å‘è¾¹é‡å¤å­˜å‚¨                                       | æ¯æ¡è¾¹åªå­˜ä¸€æ¬¡ç»“ç‚¹                        |
| **DFSï¼ˆé‚»æ¥è¡¨ï¼‰**                 | O(V+E)                | O(V+E)     | éå†æ‰€æœ‰é¡¶ç‚¹ä¸è¾¹ï¼›æ‹“æ‰‘æ’åºï¼›è¿é€šåˆ†é‡ï¼›æ£€æµ‹ç¯                 | æ·±åº¦ä¼˜å…ˆæœç´¢                              |
| **DFSï¼ˆé‚»æ¥çŸ©é˜µï¼‰**               | O(VÂ²)                 | O(VÂ²)      | å°è§„æ¨¡ç¨ å¯†å›¾éå†                                             | éå†é‚»æ¥ç‚¹éœ€æ‰«ä¸€è¡Œ                        |
| **BFSï¼ˆé‚»æ¥è¡¨ï¼‰**                 | O(V+E)                | O(V+E)     | æ— æƒå›¾æœ€çŸ­è·¯å¾„ï¼›åˆ†å±‚éå†ï¼›è¿é€šåˆ†é‡                           | å¹¿åº¦ä¼˜å…ˆæœç´¢                              |
| **BFSï¼ˆé‚»æ¥çŸ©é˜µï¼‰**               | O(VÂ²)                 | O(VÂ²)      | å°è§„æ¨¡ç¨ å¯†å›¾éå†                                             |                                           |
| **Prim ç®—æ³•ï¼ˆæœ´ç´ ç‰ˆï¼Œé‚»æ¥çŸ©é˜µï¼‰** | O(VÂ²)                 | O(VÂ²)      | ç¨ å¯†å›¾æœ€å°ç”Ÿæˆæ ‘                                             | æ¯æ¬¡æ‰«ææ‰€æœ‰é¡¶ç‚¹é€‰æœ€å°è¾¹                  |
| **Prim ç®—æ³•ï¼ˆå †ä¼˜åŒ–ç‰ˆï¼Œé‚»æ¥è¡¨ï¼‰** | O(E log V)            | O(V+E)     | ç¨€ç–å›¾æœ€å°ç”Ÿæˆæ ‘                                             | ç”¨ä¼˜å…ˆé˜Ÿåˆ—ç»´æŠ¤å€™é€‰è¾¹                      |
| **Kruskal ç®—æ³•**                  | O(E log E)â‰ˆO(E log V) | O(V+E)     | ç¨€ç–å›¾æœ€å°ç”Ÿæˆæ ‘                                             | è¾¹æ’åº + å¹¶æŸ¥é›†                           |
| **Dijkstraï¼ˆæœ´ç´ ç‰ˆï¼Œé‚»æ¥çŸ©é˜µï¼‰**  | O(VÂ²)                 | O(VÂ²)      | ç¨ å¯†å›¾ï¼Œå•æºæœ€çŸ­è·¯å¾„ï¼ˆ**ä¸å…è®¸è´Ÿæƒè¾¹**ï¼‰                     | æ¯æ¬¡æ‰¾æœ€è¿‘ç‚¹ O(V)                         |
| **Dijkstraï¼ˆå †ä¼˜åŒ–ï¼Œé‚»æ¥è¡¨ï¼‰**    | O(E log V)            | O(V+E)     | ç¨€ç–å›¾ï¼Œå•æºæœ€çŸ­è·¯å¾„ï¼ˆ**ä¸å…è®¸è´Ÿæƒè¾¹**ï¼‰                     | ç”¨å †ç»´æŠ¤æœ€çŸ­è·ç¦»                          |
| **Floyd ç®—æ³•**                    | O(VÂ³)                 | O(VÂ²)      | å¤šæºæœ€çŸ­è·¯å¾„ï¼Œå°è§„æ¨¡ç¨ å¯†å›¾ï¼Œ**å…è®¸è´Ÿæƒè¾¹**ï¼›å¯æ£€æµ‹è´Ÿç¯ï¼ˆ`dist[i][i]<0`ï¼‰ | è‹¥æœ‰è´Ÿç¯åˆ™æ— è§£                            |
| **Bellman-Ford ç®—æ³•**             | O(VE)                 | O(V+E)     | å•æºæœ€çŸ­è·¯å¾„ï¼Œ**å…è®¸è´Ÿæƒè¾¹**ï¼›å¯æ£€æµ‹è´Ÿç¯ï¼ˆæ¾å¼› V æ¬¡åä»å˜åŒ–ï¼‰ | è‹¥æœ‰è´Ÿç¯åˆ™æ— è§£                            |
| **SPFA ç®—æ³•**                     | å¹³å‡ O(E)ï¼Œæœ€å O(VE) | O(V+E)     | å•æºæœ€çŸ­è·¯å¾„ï¼Œ**å…è®¸è´Ÿæƒè¾¹**ï¼›å¯æ£€æµ‹è´Ÿç¯ï¼ˆæŸç‚¹å…¥é˜Ÿ â‰¥ V æ¬¡ï¼‰  | è‹¥æœ‰è´Ÿç¯åˆ™æ— è§£                            |

| ç®—æ³• / å­˜å‚¨ç»“æ„                   | æ—¶é—´å¤æ‚åº¦            | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯                                                     | è¯´æ˜                                      |
| --------------------------------- | --------------------- | ---------- | ------------------------------------------------------------ | ----------------------------------------- |
| **é‚»æ¥çŸ©é˜µ**                      | â€”â€”                    | **O(VÂ²)**  | ç¨ å¯†å›¾                                                       | æŸ¥è¯¢è¾¹æ˜¯å¦å­˜åœ¨å¿« O(1)ï¼Œéå†æ…¢ O(V)        |
| **é‚»æ¥è¡¨**                        | â€”â€”                    | **O(V+E)** | ç¨€ç–å›¾                                                       | éå†å¿« O(V+E)ï¼ŒæŸ¥è¯¢è¾¹æ˜¯å¦å­˜åœ¨æ…¢ O(deg(v)) |
| **åå­—é“¾è¡¨**ï¼ˆæœ‰å‘å›¾ï¼‰            | â€”â€”                    | **O(V+E)** | éœ€è¦åŒæ—¶é«˜æ•ˆå¤„ç†å‡ºåº¦å’Œå…¥åº¦çš„æœ‰å‘å›¾                           | æ¯æ¡è¾¹å­˜ä¸¤æ¬¡å¼•ç”¨                          |
| **é‚»æ¥å¤šé‡è¡¨**ï¼ˆæ— å‘å›¾ï¼‰          | â€”â€”                    | **O(V+E)** | éœ€è¦é¿å…æ— å‘è¾¹é‡å¤å­˜å‚¨                                       | æ¯æ¡è¾¹åªå­˜ä¸€æ¬¡ç»“ç‚¹                        |
| **DFSï¼ˆé‚»æ¥è¡¨ï¼‰**                 | O(V+E)                | O(V+E)     | éå†æ‰€æœ‰é¡¶ç‚¹ä¸è¾¹ï¼›æ‹“æ‰‘æ’åºï¼›è¿é€šåˆ†é‡ï¼›æ£€æµ‹ç¯                 | æ·±åº¦ä¼˜å…ˆæœç´¢                              |
| **DFSï¼ˆé‚»æ¥çŸ©é˜µï¼‰**               | O(VÂ²)                 | O(VÂ²)      | å°è§„æ¨¡ç¨ å¯†å›¾éå†                                             | éå†é‚»æ¥ç‚¹éœ€æ‰«ä¸€è¡Œ                        |
| **BFSï¼ˆé‚»æ¥è¡¨ï¼‰**                 | O(V+E)                | O(V+E)     | æ— æƒå›¾æœ€çŸ­è·¯å¾„ï¼›åˆ†å±‚éå†ï¼›è¿é€šåˆ†é‡                           | é˜Ÿåˆ—å®ç°                                  |
| **BFSï¼ˆé‚»æ¥çŸ©é˜µï¼‰**               | O(VÂ²)                 | O(VÂ²)      | å°è§„æ¨¡ç¨ å¯†å›¾éå†                                             |                                           |
| **æ‹“æ‰‘æ’åºï¼ˆé‚»æ¥è¡¨ï¼‰**            | O(V+E)                | O(V+E)     | **DAG çš„çº¿æ€§åº**ï¼›ä»»åŠ¡è°ƒåº¦ï¼›ç¼–è¯‘ä¾èµ–                         | å¸¸ç”¨ Kahn ç®—æ³•ï¼ˆé˜Ÿåˆ—ï¼‰æˆ– DFS              |
| **æ‹“æ‰‘æ’åºï¼ˆé‚»æ¥çŸ©é˜µï¼‰**          | O(VÂ²)                 | O(VÂ²)      | å°è§„æ¨¡ç¨ å¯†å›¾                                                 | æ¯æ¬¡æ‰¾å…¥åº¦=0 éœ€æ‰«ä¸€åˆ—                     |
| **Prim ç®—æ³•ï¼ˆæœ´ç´ ç‰ˆï¼Œé‚»æ¥çŸ©é˜µï¼‰** | O(VÂ²)                 | O(VÂ²)      | ç¨ å¯†å›¾æœ€å°ç”Ÿæˆæ ‘                                             | æ¯æ¬¡æ‰«ææ‰€æœ‰é¡¶ç‚¹é€‰æœ€å°è¾¹                  |
| **Prim ç®—æ³•ï¼ˆå †ä¼˜åŒ–ç‰ˆï¼Œé‚»æ¥è¡¨ï¼‰** | O(E log V)            | O(V+E)     | ç¨€ç–å›¾æœ€å°ç”Ÿæˆæ ‘                                             | ç”¨ä¼˜å…ˆé˜Ÿåˆ—ç»´æŠ¤å€™é€‰è¾¹                      |
| **Kruskal ç®—æ³•**                  | O(E log E)â‰ˆO(E log V) | O(V+E)     | ç¨€ç–å›¾æœ€å°ç”Ÿæˆæ ‘                                             | è¾¹æ’åº + å¹¶æŸ¥é›†                           |
| **Dijkstraï¼ˆæœ´ç´ ç‰ˆï¼Œé‚»æ¥çŸ©é˜µï¼‰**  | O(VÂ²)                 | O(VÂ²)      | ç¨ å¯†å›¾ï¼Œå•æºæœ€çŸ­è·¯å¾„ï¼ˆ**ä¸å…è®¸è´Ÿæƒè¾¹**ï¼‰                     | æ¯æ¬¡æ‰¾æœ€è¿‘ç‚¹ O(V)                         |
| **Dijkstraï¼ˆå †ä¼˜åŒ–ï¼Œé‚»æ¥è¡¨ï¼‰**    | O(E log V)            | O(V+E)     | ç¨€ç–å›¾ï¼Œå•æºæœ€çŸ­è·¯å¾„ï¼ˆ**ä¸å…è®¸è´Ÿæƒè¾¹**ï¼‰                     | ç”¨å †ç»´æŠ¤æœ€çŸ­è·ç¦»                          |
| **Floyd ç®—æ³•**                    | O(VÂ³)                 | O(VÂ²)      | å¤šæºæœ€çŸ­è·¯å¾„ï¼Œå°è§„æ¨¡ç¨ å¯†å›¾ï¼Œ**å…è®¸è´Ÿæƒè¾¹**ï¼›å¯æ£€æµ‹è´Ÿç¯ï¼ˆ`dist[i][i]<0`ï¼‰ | è‹¥æœ‰è´Ÿç¯åˆ™æ— è§£                            |
| **Bellman-Ford ç®—æ³•**             | O(VE)                 | O(V+E)     | å•æºæœ€çŸ­è·¯å¾„ï¼Œ**å…è®¸è´Ÿæƒè¾¹**ï¼›å¯æ£€æµ‹è´Ÿç¯ï¼ˆæ¾å¼› V æ¬¡åä»å˜åŒ–ï¼‰ | è‹¥æœ‰è´Ÿç¯åˆ™æ— è§£                            |
| **SPFA ç®—æ³•**                     | å¹³å‡ O(E)ï¼Œæœ€å O(VE) | O(V+E)     | å•æºæœ€çŸ­è·¯å¾„ï¼Œ**å…è®¸è´Ÿæƒè¾¹**ï¼›å¯æ£€æµ‹è´Ÿç¯ï¼ˆæŸç‚¹å…¥é˜Ÿ â‰¥ V æ¬¡ï¼‰  | è‹¥æœ‰è´Ÿç¯åˆ™æ— è§£                            |

### æ’åºçš„ä¸€äº›ä»£ç æ¨¡æ¿

#### å¿«é€Ÿæ’åº

```c++
void quick_sort(int q[],int l,int r){
    if(l>=r)return ;
    int i  =  l-1,j=r+1,x=q[l+r>>1]
    while(i<j){
        do i++;while(q[i]<x);
        do j--;while(q[j]>x);
        if(i<j)swap(q[i],q[j]);
    }
    quick_sort(q,l,j),quick_sort(q,j+1,r);
}
```

#### å½’å¹¶æ’åº

```c++
void merge_sort(int q[],int l,int r){
	if(l>=r)return ;
    merge_sort(q,l,mid);
    merge_sort(q,mid+1,r);
    int k = 0,i = l , j = mid+1;
    while(i<=mid && j <=r){
        if(q[i]<=q[j])tmp[k++]=q[i++];
        else tmp[k++]=q[j++];
    }
    while(i<=mid)tmp[k++]=q[i++];
    while(j<=r)tmp[k++]=q[j++];
    for(j = 0,i=l;i<=r;i++,j++)
        q[i]=tmp[j];
    
}
```



### æŸ¥æ‰¾çš„ä¸€äº›ä»£ç æ¨¡æ¿

#### äºŒåˆ†æŸ¥æ‰¾

```c++

```

## é”™é¢˜æœ¬

### 2010 çº¿æ€§è¡¨ ä¸‰æ¬¡ç¿»è½¬

![](F:\try\home\themes\fluid\source\img\194921.jpg)

```c++
//è‡ªå·±çš„
void moveleft(int q[],int p,int n){
    int tmp[n];
    for(int i = 0;i<n;i++)
        tmp[(i+n-p)%n]=q[i];
    for(int i = 0 ;i<n;i++)
        q[i]=tmp[i];
    
    
}
```

```c++
//æ ‡ç­”
void reverse(int q[],int l,int r){
    if(l>=r)return;
    while(l<r){
        swap(q[l],q[r]);
        l++,r--;
    }
}
void moveleft(int q[],int n,int p){
    reverse(q,0,p-1);
    reverse(q,p,n-1);
    reverse(q,0,n-1);
}

```

### 2011 çº¿æ€§è¡¨ äºŒåˆ†æœç´¢

```c++
//è‡ªå·±çš„
/*ç®—æ³•çš„åŸºæœ¬è®¾è®¡æ€æƒ³ï¼š
ä¸­ä½æ•°çš„ä½ç½®æ˜¯å¯ä»¥è®¡ç®—å‡ºçš„ï¼Œä¹Ÿå°±æ˜¯ä¸¤ä¸ªæ•°åˆ—åˆå¹¶åå¤„äºL/2ä½ç½®çš„æ•°ï¼Œåˆ©ç”¨ä¸¤ä¸ªæŒ‡é’ˆijåˆ†åˆ«æŒ‡å‘æ•°ç»„A,Bï¼Œç„¶åæ‰¾åˆ°ç¬¬L/2å¤§çš„æ•°å³ä¸­ä½æ•°*/
int findmid(int a[],int b[],int l){
    int i = 0,j=0;
    while(i+j<l-1){
        if(a[i]>=b[j])j++;
        else i++;
    }
    return min(a[i],b[j]);
}
//14åˆ†
```

```c++
//æ ‡ç­”
int findMid(int a[], int b[], int n) {
    int l = 0, r = n;
    while (l < r) {
        int i = (l + r) / 2;
        int j = n - i;
        if (i < n && b[j - 1] > a[i]) l = i + 1;
        else if (i > 0 && a[i - 1] > b[j]) r = i - 1;
        else {
            int leftMax = 0;
            if (i == 0) leftMax = b[j - 1];
            else if (j == 0) leftMax = a[i - 1];
            else leftMax = std::max(a[i - 1], b[j - 1]);
            return leftMax;
        }
    }

    int i = l, j = n - l;
    if (i == 0) return b[j - 1];
    if (j == 0) return a[i - 1];
    return std::max(a[i - 1], b[j - 1]);
}
//15åˆ†
```

### 2013 çº¿æ€§è¡¨ æ‘©å°”æŠ•ç¥¨æ³•

```c++
//è‡ªå·±çš„
//è®¾è®¡æ€æƒ³ï¼šå¦‚æœä¸€ä¸ªæ•°çš„å‡ºç°æ¬¡æ•°å¤§äºn/2ï¼Œé‚£ä¹ˆä»–ä¸€å®šæ˜¯è¿™ä¸€ç»„æ•°é¡ºåºåºåˆ—çš„ä¸­ä½æ•°ï¼Œç„¶åæ‰¾åˆ°æ¯”å®ƒå°çš„ç¬¬ä¸€ä¸ªæ•°å’Œæ¯”ä»–å¤§çš„ç¬¬ä¸€ä¸ªæ•°ï¼Œä¸¤è€…çš„ä½ç½®å·®å°±æ˜¯è¯¥æ•°å‡ºç°çš„æ¬¡æ•°ã€‚
void quick_sort(int q[],int l,int r){
    if(l>=r)return ;
    int x=q[l+r>>1],i=l-1,j=r+1;
    while(i<j){
        do i++;while(q[i]<x);
        do j--;while(q[j]>x);
        if(i<j)swap(q[i],q[j]);
    }
    quick_sort(q,l,j),quick_sort(q,j+1,r);
}
int bsl(int l,int r,int x,int q[]){
    while(l<r){
        int mid=l+r+1>>1;
        if(q[mid]<x)l=mid;
        else r=mid-1;
    }
    return l;
}
int bsh(int l,int r,int x,int q[]){
    while(l<r){
        int mid = l+r>>1;
        if(q[mid]>x)r=mid;
        else l  = mid+1;
    }
    return l;
}
int findmain(int a[],int n){
    quick_sort(a,0,n-1);
    int result = a[n-1>>1];
    int left=bsl(0,n-1,result,a);
    int right=bsh(0,n-1,result,a);
    if(right-left-1>(n>>1))return result;
    else return -1;
}

```

```c++
//æ‘©å°”æŠ•ç¥¨æ³•ï¼Œæ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(1)
int find_main(int a[], int n) {
    int candidate = -1, count = 0;

    // ç¬¬ä¸€è½®ï¼šæ‰¾å‡ºå¯èƒ½çš„ä¸»å…ƒç´ 
    for (int i = 0; i < n; i++) {
        if (count == 0) {
            candidate = a[i]; // æ¢äºº
            count = 1;
        } else if (a[i] == candidate) {
            count++; // åŒç±»+1
        } else {
            count--; // å¼‚ç±»-1
        }
    }

    // ç¬¬äºŒè½®ï¼šéªŒè¯æ˜¯å¦çœŸçš„æ˜¯ä¸»å…ƒç´ ï¼ˆå¿…é¡»è¶…è¿‡ä¸€åŠï¼‰
    count = 0;
    for (int i = 0; i < n; i++) {
        if (a[i] == candidate) count++;
    }

    return (count > n / 2) ? candidate : -1;
}
```

ğŸ­ è¿™ä¸ªç®—æ³•å…¶å®æ˜¯åœ¨æ¨¡æ‹Ÿâ€œæŠ•ç¥¨å¤§æˆ˜â€ï¼

æƒ³è±¡ä½ ç°åœ¨æœ‰ä¸€ç¾¤äººï¼Œæ¯äººä»£è¡¨ä¸€ä¸ªæ•°ã€‚ä½ çš„ç›®æ ‡æ˜¯æ‰¾å‡º **æœ‰æ²¡æœ‰æŸä¸ªæ•°åœ¨è¿™ç¾¤äººé‡Œå å¤šæ•°ï¼ˆè¶…è¿‡ä¸€åŠï¼‰**ã€‚

------

ğŸ¥Š æ‘©å°”æŠ•ç¥¨çš„é€»è¾‘æ˜¯ï¼š

- ä½ ä¸€å¼€å§‹ä¸çŸ¥é“è°æ˜¯ä¸»è§’ï¼Œæ‰€ä»¥ä»ç¬¬ä¸€ä¸ªäººå¼€å§‹çŒœï¼›
- å¦‚æœåæ¥é‡åˆ°å’Œå½“å‰çŒœæµ‹ä¸€æ ·çš„äººï¼ˆç«™ä½ è¿™è¾¹ï¼‰ï¼Œä½ å°±ä¿¡å¿ƒ +1ï¼›
- å¦‚æœé‡åˆ°å’Œä½ çŒœçš„ä¸ä¸€æ ·çš„äººï¼ˆåå¯¹ä½ ï¼‰ï¼Œä½ å°±ä¿¡å¿ƒ -1ï¼›
- å¦‚æœä¿¡å¿ƒæ‰åˆ° 0ï¼Œå°±è¯´æ˜ä½ ç°åœ¨è¿™ä¸ªå€™é€‰äººæ”¯æŒå’Œåå¯¹æ‰“å¹³äº†ï¼Œéœ€è¦æ¢äººé‡æ–°å¼€å§‹ï¼›
- æœ€åå‰©ä¸‹æ¥çš„â€œèµ¢å®¶â€æœ‰å¯èƒ½æ˜¯ä¸»è§’ï¼Œä½†å¾—å†æ•°ä¸€éç¡®è®¤ä¸€ä¸‹å®ƒæ˜¯ä¸æ˜¯çœŸçš„è¶…è¿‡ä¸€åŠã€‚

------

ğŸ¯ é‚£ä¸ºä»€ä¹ˆ `count--` æ˜¯å¿…è¦çš„ï¼Ÿ

å› ä¸ºæ¯é‡åˆ°ä¸€ä¸ªâ€œä¸åŒâ€çš„æ•°ï¼Œå°±æ˜¯â€œä¸»å…ƒç´ â€çš„ä¸€ä¸ªåå¯¹ç¥¨ã€‚

å¦‚æœä¸»å…ƒç´ çœŸçš„è¶…è¿‡ä¸€åŠï¼Œé‚£å…¶ä»–æ‰€æœ‰æ•°éƒ½ä¸å¤ŸæŠŠå®ƒæŠµæ¶ˆæ‰ï¼Œå®ƒä¸€å®šèƒ½æ’‘åˆ°æœ€åï¼

æ¯”å¦‚æ•°ç»„ï¼š

```
csharp


å¤åˆ¶ç¼–è¾‘
[5, 5, 3, 5, 7, 5, 5, 1]
```

- ä¸»å…ƒç´ æ˜¯ 5ï¼Œå®ƒæœ‰ 5 ç¥¨ï¼›
- å‰©ä¸‹çš„ 3ã€7ã€1 åªæœ‰ 3 ç¥¨ï¼›
- å³ä½¿è¿™ 3 ç¥¨å…¨éƒ½æ‹¿æ¥åå¯¹ 5ï¼Œ**5 è¿˜æ˜¯èµ¢äº†ï¼**

æ‰€ä»¥ä½ åœ¨æ¯é‡åˆ°ä¸€ä¸ªâ€œå¼‚ç±»â€æ—¶ï¼Œ**å°±ç­‰äºä¸»è§’è¢«åå¯¹äº†ä¸€æ¬¡ï¼Œè¦ `count--`**ã€‚

------

âœ… æ€»ç»“ä¸€å¥è¯ï¼š

> `count--` æ˜¯ä¸ºäº†è®©åå¯¹çš„å£°éŸ³æŠµæ¶ˆæ‰ä¸»å…ƒç´ çš„ç¥¨æ•°ï¼Œçœ‹å®ƒèƒ½ä¸èƒ½æœ€ç»ˆå‰©ä¸‹æ¥ã€‚

### 2018 çº¿æ€§è¡¨ åŸåœ°å“ˆå¸Œæ³•

```c++
//è‡ªå·±çš„
//è®¾è®¡æ€è·¯ï¼šå°†æ•°ç»„å˜ä¸ºæœ‰åºæ•°ç»„ï¼Œä»æœ€å°çš„æ­£æ•´æ•°1å¼€å§‹åˆ¤æ–­æ•°ç»„ä¸­æ˜¯å¦å‡ºç°ï¼Œç„¶åé€’å¢æ‰¾åˆ°æœ€å°çš„æœªå‡ºç°æ­£æ•´æ•°
void quick_sort(int a[],int l,int r){
    if(l>=r)return;
    int x=a[l+r>>1],i=l-1,j=r+1;
    while(i<j){
        do i++ ;while(a[i]<x);
        do j--;while(a[j]>x);
        if(i<j)swap(a[i],a[j]);
    }
    quick_sort(a,l,j),quick_sort(a,j+1,r);
}
int findmin(int a[],int n){
    int mini = 1;
    quick_sort(a,0,n-1);
    for(int i = 0 ; i<n;i++){
        if(a[i]==mini) mini++;
    }
    return mini;
}
//æ—¶é—´å¤æ‚åº¦O(nlogn)ç©ºé—´å¤æ‚åº¦O(logn)

```

```c++
//è¯¾æœ¬ä¸Šçš„ç­”æ¡ˆ æ—¶é—´å¤æ‚åº¦O(n),ç©ºé—´å¤æ‚åº¦O(n)
int findmin(int a[],int n){
    int tmp[n];
    memset(tmp,0,sizeof(tmp));
    for(int i = 0;i<n;i++){
        if(a[i]>0&&a[i]<=n)tmp[a[i]-1]=1;

    }
    for(int i = 0;i<n;i++)
        if(!tmp[i])return i+1;
}
```

```c++
//æ›´å¥½çš„ç­”æ¡ˆï¼ˆåŸåœ°å“ˆå¸Œæ³•ï¼‰æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(1)
int findmin(int a[],int n){
    for(int i = 0 ;i<n;i++)
        while(a[i]>0 && a[i]<=n &&a[a[i]-1]!=a[i])
          swap(a[a[i]-1],a[i]);
    for(int i = 0;i<n;i++)
        if(a[i]!=i+1)return i+1;
}
```

```c++
//yæ€»ç‰ˆæœ¬
int findmissmin(vector<int>&nums){
		int n = nums.size();
		vector<bool>hash(n+1);
		for(int x:nums)
			if(x>=1 && x<=n)
				hash[x]=true;
    	for(int i = 1;i<=n;i++)
            if(!hash[i])
                return i;
    	return n+1;
                
}
```



### 2020 çº¿æ€§è¡¨

```c++
//ç­”æ¡ˆ
const int maxint = 0x3f3f3f3f
bool ismin(int a,int b,int c){
    return a<=b&&a<=c;
}
int distance(int a[],int n1,int b[],int n2,int c[],int n3){
    int i = 0 ,j=0,k = 0,dmin = maxint;
     	while(i<n1  && j<n2&& k <n3 &&d>0){
            int d = abs(a[i]-b[j])+abs(a[i]-c[k])+abs(b[j]-c[k]);
            if(d<dmin) dmin=d;
            if(ismin(a[i],b[j],c[k]))i++;
            else if(b[j],a[i],c[k]) j++;
            else k++;
        }
    return  dmin;
}

```

### 2009 å•é“¾è¡¨

```c++
//è‡ªå·±çš„
#include <iostream>
using namespace std;
struct lnode{
    int data;
    lnode *next;
};
using linklist = lnode*;
int getlength(lnode* head){
    int length=0;
    lnode *p=head->next;
    while(p){
        length++;
        p=p->next;
    }
    return length;
}
int findnum(lnode *head,int k){
        int length=getlength(head);
        int n=length-k+1;
        lnode *p=head->next;
        for(int i = 1;i<n;i++){
                p=p->next;
                if(!p)return 0;
        }
        cout<<p->data<<endl;
        return 1;
}
    //æè¿°ç®—æ³•çš„åŸºæœ¬è®¾è®¡æ€æƒ³ï¼šç¬¬ä¸€éé¡ºåºæŸ¥æ‰¾éå†ä¸€éé“¾è¡¨ï¼Œè·å–é“¾è¡¨é•¿åº¦ï¼Œç„¶åè®¡ç®—å€’æ•°kä¸ªä½ç½®å¯¹åº”çš„æ˜¯æ­£æ•°ç¬¬n-k+1ä¸ªä½ç½®ï¼Œç¬¬äºŒéé¡ºåºæŸ¥æ‰¾åˆ°ç¬¬n-k+1ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æœå­˜åœ¨ï¼Œè¾“å‡ºå¯¹åº”çš„å€¼å¹¶è¿”å›1ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å›0
```

```c++
//ç­”æ¡ˆçš„
/*æ€è·¯
1)ç®—æ³•çš„åŸºæœ¬è®¾è®¡æ€æƒ³ï¼š
é—®é¢˜çš„å…³é”®æ˜¯è®¾è®¡ä¸€ä¸ªå°½å¯èƒ½é«˜æ•ˆçš„ç®—æ³•ï¼Œé€šè¿‡é“¾è¡¨çš„ä¸€æ¬¡éå†ï¼Œæ‰¾åˆ°å€’æ•°ç¬¬kä¸ªç»“ç‚¹çš„ä½ç½®ã€‚å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆå˜é‡på’Œq,åˆå§‹æ—¶å‡æŒ‡å‘å¤´ç»“ç‚¹çš„ä¸‹ä¸€ä¸ªç»“ç‚¹(é“¾è¡¨çš„ç¬¬ä¸€ä¸ªç»“ç‚¹),pæŒ‡é’ˆæ²¿é“¾è¡¨ç§»åŠ¨ï¼›å½“pæŒ‡é’ˆç§»åŠ¨åˆ°ç¬¬kä¸ªç»“ç‚¹æ—¶ï¼ŒqæŒ‡é’ˆå¼€å§‹ä¸pæŒ‡é’ˆåŒæ­¥ç§»åŠ¨ï¼›å½“pæŒ‡é’ˆç§»åŠ¨åˆ°æœ€åä¸€ä¸ªç»“ç‚¹æ—¶ï¼ŒqæŒ‡é’ˆæ‰€æŒ‡ç¤ºç»“ç‚¹ä¸ºå€’æ•°ç¬¬kä¸ªç»“ç‚¹ã€‚ä»¥ä¸Šè¿‡ç¨‹å¯¹é“¾è¡¨ä»…è¿›è¡Œä¸€éæ‰«æã€‚
2)ç®—æ³•çš„è¯¦ç»†å®ç°æ­¥éª¤å¦‚ä¸‹ï¼š
1ã€count=0,på’ŒqæŒ‡å‘é“¾è¡¨è¡¨å¤´ç»“ç‚¹çš„ä¸‹ä¸€ä¸ªç»“ç‚¹ã€‚
2ã€è‹¥pä¸ºç©ºï¼Œè½¬5ã€‚
3ã€è‹¥countç­‰äºk,åˆ™qæŒ‡å‘ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼›å¦åˆ™ï¼Œcount=count+1ã€‚
4ã€pæŒ‡å‘ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œè½¬2ã€‚
5ã€è‹¥countç­‰äºk,åˆ™æŸ¥æ‰¾æˆåŠŸï¼Œè¾“å‡ºè¯¥ç»“ç‚¹çš„dataåŸŸçš„å€¼ï¼Œè¿”å›1;å¦åˆ™ï¼Œè¯´æ˜kå€¼è¶…è¿‡äº†çº¿æ€§è¡¨çš„é•¿åº¦ï¼ŒæŸ¥æ‰¾å¤±è´¥ï¼Œè¿”å›0ã€‚ç®—æ³•ç»“æŸã€‚
*/
#include <iostream>
using namespace std;
struct lnode
{
    int data;
    lnode *next;
};
int findnum(lnode *list,int k){
    lnode *p=list->next;
    lnode *q=list->next;
    int count = k;
    while(count--){
        if(p==nullptr)return 0;
        p=p->next;

    }
    while(p){
        p=p->next;
        q=q->next;
    }
    if(q==nullptr) return 0;
       
    cout<<q->data<<endl;
    return 1;

}
```

### 2012 å•é“¾è¡¨

```c++
//è‡ªå·±çš„
#include <iostream>
using namespace std;
struct lnode
{
    char data;
    lnode *next;
    bool ispass=0;
};
using linklist=lnode *;
linklist findpoint(lnode *str1,lnode *str2){
    while(str1){
        str1->ispass=1;
        str1=str1->next;    
    }
    while(str2){
        if(!(str2->ispass)){
            str2->ispass=1;
            str2=str2->next;
        }
        else break;
    }
    lnode *p=str2;
    return p;
}
//æ€è·¯ï¼šå…ˆéå†ä¸€éstr1ï¼Œæ ‡è®°å·²ç»éå†è¿‡çš„èŠ‚ç‚¹ï¼Œç„¶åå†éå†ä¸€éstr2ï¼Œå½“str2éå†åˆ°å·²ç»æ ‡è®°è¿‡çš„èŠ‚ç‚¹ï¼Œè¯´æ˜å…¶æ˜¯äºŒè€…å…±åŒåç¼€çš„èµ·å§‹ä½ç½®ã€‚æ—¶é—´å¤æ‚åº¦ä¸ºO(n)

```

```c++
//ç­”æ¡ˆ
#include <iostream>
using namespace std;
struct node
{
    char data;
    node *next;
};
int listlen(node *head){
    int len=0;
    while(head->next!=nullptr){
        len++;
        head=head->next;
    }
    return len;
}
//æ‰¾å‡ºå…±åŒåç¼€çš„èµ·å§‹åœ°å€
node * findlist(node *str1,node *str2){
    int m,n;
    node *p,*q;
    m=listlen(str1);
    n=listlen(str2);
    for(p=str1;m>n;m--)p=p->next;
    for(q=str2;m<n;n--)q=q->next;
    while (p->next!=nullptr&&p->next!=q->next)
    {
        p=p->next;
        q=q->next;
    }
    return p->next;
}
```

é¡ºåºéå†ä¸¤ä¸ªé“¾è¡¨åˆ°å°¾ç»“ç‚¹æ—¶ï¼Œå¹¶ä¸èƒ½ä¿è¯ä¸¤ä¸ªé“¾è¡¨åŒæ—¶åˆ°è¾¾å°¾ç»“ç‚¹ã€‚è¿™æ˜¯å› ä¸ºä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ä¸åŒã€‚å‡è®¾ä¸€ä¸ªé“¾è¡¨æ¯”å¦ä¸€ä¸ªé“¾è¡¨é•¿kä¸ªç»“ç‚¹ï¼Œæˆ‘ä»¬å…ˆåœ¨é•¿é“¾è¡¨ä¸Šéå†kä¸ªç»“ç‚¹ï¼Œä¹‹ååŒæ­¥éå†ä¸¤ä¸ªé“¾è¡¨ï¼Œè¿™æ ·å°±èƒ½å¤Ÿä¿è¯å®ƒä»¬åŒæ—¶åˆ°è¾¾æœ€åä¸€ä¸ªç»“ç‚¹ã€‚å› ä¸ºä¸¤ä¸ªé“¾è¡¨ä»ç¬¬ä¸€ä¸ªå…¬å…±ç»“ç‚¹åˆ°é“¾è¡¨çš„å°¾ç»“ç‚¹éƒ½æ˜¯é‡åˆçš„ï¼Œæ‰€ä»¥å®ƒä»¬è‚¯å®šåŒæ—¶åˆ°è¾¾ç¬¬ä¸€ä¸ªå…¬å…±ç»“ç‚¹ã€‚
1)ç®—æ³•çš„åŸºæœ¬è®¾è®¡æ€æƒ³ï¼š
â‘ åˆ†åˆ«æ±‚å‡ºstr1å’Œstr2æ‰€æŒ‡çš„ä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦må’Œnã€‚
â‘¡å°†ä¸¤ä¸ªé“¾è¡¨ä»¥è¡¨å°¾å¯¹é½ï¼šä»¤æŒ‡é’ˆpã€qåˆ†åˆ«æŒ‡å‘str1å’Œstr2çš„å¤´ç»“ç‚¹ï¼Œè‹¥mâ‰¥n,åˆ™æŒ‡é’ˆpå…ˆèµ°ï¼Œä½¿pæŒ‡å‘é“¾è¡¨ä¸­çš„ç¬¬m-n+1ä¸ªç»“ç‚¹ï¼›è‹¥m<n,åˆ™ä½¿qæŒ‡å‘é“¾è¡¨ä¸­çš„ç¬¬n-m+1ä¸ªç»“ç‚¹ï¼Œå³ä½¿æŒ‡é’ˆpå’Œqæ‰€æŒ‡çš„ç»“ç‚¹åˆ°è¡¨å°¾çš„é•¿åº¦ç›¸ç­‰ã€‚
â‘¢åå¤å°†æŒ‡é’ˆpå’ŒqåŒæ­¥å‘åç§»åŠ¨ï¼Œå¹¶åˆ¤æ–­å®ƒä»¬æ˜¯å¦æŒ‡å‘åŒä¸€ç»“ç‚¹ã€‚å½“pã€qæŒ‡å‘åŒä¸€ç»“ç‚¹ï¼Œåˆ™è¯¥ç‚¹å³æ‰€æ±‚çš„å…±åŒåç¼€çš„èµ·å§‹ä½ç½®ã€‚

```c++
//yxc
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *findFirstCommonNode(ListNode *headA, ListNode *headB) {
        auto p = headA, q = headB;
        while (p != q) {
            p = p ? p->next : headB;
            q = q ? q->next : headA;
        }
        return p;
    }
};

```

![](/img/200356.jpg)

### 2015 å•é“¾è¡¨

```c++
//è‡ªå·±çš„
#include <iostream>
#include <cmath>
#include <cstring>
using namespace std;
struct node
{
    int data;
    node*link;  
};
void delnode(node *p){//åˆ é™¤è¯¥èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        node *q=p->link;
        p->link=q->link;
        free(q);
}
void nosame(node *head,int m,int n){
    bool ispass[n+1];
    memset(ispass,0,sizeof(ispass));
    node *p=head->link;
    while (p)//åŒæ—¶ä¿å­˜ä¸¤ä¸ªç‚¹ï¼Œä¸€ä¸ªæ˜¯å½“å‰èŠ‚ç‚¹çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹å³headæ‰€æŒ‡å‘çš„ï¼Œä¸€ä¸ªæ˜¯å½“å‰èŠ‚ç‚¹å³p
    {
        if(!(ispass[abs(p->data)])){
            ispass[abs(p->data)]=1;
            p=p->link;
            head=head->link;
        }
        else{
            delnode(head);
            p=head->link;
        }
    }
    
}
/*æ€è·¯ï¼šç”¨ä¸€ä¸ªboolæ•°ç»„è®°å½•æŸä¸ªæ•°æ›¾ç»å‡ºç°è¿‡ï¼Œ
å¦‚æœéå†åˆ°æŸä¸ªç‚¹çš„æ—¶å€™å‘ç°ä»–çš„ç»å¯¹å€¼å‡ºç°è¿‡ï¼Œåˆ™åˆ é™¤è¯¥ç‚¹ã€‚æ—¶é—´å¤æ‚åº¦ä¸ºO(m)*/
```

```c++
//ç­”æ¡ˆ
åŒæ ·
```

```c++
//YXC
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* filterList(ListNode* head) {
        bool st[10001] = {};
        st[abs(head->val)] = true;
        for (auto p = head; p->next;) {
            int x = abs(p->next->val);
            if (st[x]) {
                auto q = p->next;
                p->next = q->next;
                delete q;
            } else {
                p = p->next;
                st[x] = true;
            }
        }
        return head;
    }
};
```



### 2019 å•é“¾è¡¨ å¿«æ…¢æŒ‡é’ˆæ‰¾é“¾è¡¨ä¸­ç‚¹

```c++
//è‡ªå·±çš„
#include <iostream>
#include <cmath>
#include <cstring>
using namespace std;


/*
æ€è·¯ï¼šæ ¹æ®é¢˜ç›®å¯çŸ¥ï¼Œä¼šè¢«æ’å…¥çš„èŠ‚ç‚¹æœ‰n-1/2ï¼ˆä¸‹å–æ•´ï¼‰ä¸ªï¼Œå³ä»n-(n-1/2)åé¢éƒ½æ˜¯è¦æ’å…¥å‰é¢åºåˆ—çš„èŠ‚ç‚¹
ä»è¯¥ç‚¹å¼€å§‹å¯¹åé¢çš„é‡‡ç”¨å¤´æ’æ³•äºŒæ¬¡æ’å…¥ï¼Œå½¢æˆä¸€ä¸ªåéƒ¨é€†åºï¼Œç„¶åä»å¤´å¼€å§‹éš”æ¬¡æ’å…¥ï¼Œå³å¯å¾—åˆ°é¢˜ç›®è¦æ±‚çš„ç»“æœ
*/
struct node
{
    int data;
    node *next;
};
int getlength(node *head){
    node *p=head->next;
    int length=0;
    while(p){
        length++;
        p=p->next;
    }
    return length;
}

void insertlist(node *head){
    int n=getlength(head);
    int k = n-(n-1>>1);
    node *h=head->next;
    for(int i = 1;i<k;i++){
            h=h->next;//è·³å‡ºå¾ªç¯åpæŒ‡å‘çš„æ˜¯ç¬¬kä¸ªèŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯ä¸éœ€è¦å€’æ’çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹,ç›¸å½“äºå€’ç½®é“¾è¡¨çš„å¤´ç»“ç‚¹
    }
    int m = n-1>>1;
    node *p=h->next;
    node *tmp=p->next;
    p->next=nullptr;
    p=tmp;
    //ä»ç¬¬ä¸€ä¸ªç‚¹å¼€å§‹å¤´æ’ï¼Œç”¨ä¸€ä¸ªæŒ‡é’ˆä¿å­˜å‰©ä¸‹çš„é“¾è¡¨çš„å¼€å¤´
    for(int i = 1;i<=m;i++){
        node *tmp=p->next;//å‰©ä¸‹å¾…æ’å…¥çš„é“¾è¡¨çš„èµ·ç‚¹
        p->next=h->next;
        h->next=p;
        p=tmp;     
    }//å½¢æˆå€’æ’åºåˆ—
    node *p=h->next;
        node *q=head->next;
        int count= n;
        node *rear=head;
    while (count)
    {//nä¸ªæ•°é‡ç»„
       //é¡ºåºé“¾è¡¨å–æ•°
       node *tmp=q->next;
       rear->next=q;
       rear=q;
       q=tmp;
       count--;
       //é€†åºé“¾è¡¨å–æ•°
        node *tmp=p->next;
        rear->next=p;
        rear=p;
        p=tmp;
        count--;
    }
    rear->next=nullptr;
}
```

```c++
//ç­”æ¡ˆ
#include <iostream>
#include <cmath>
#include <cstring>
using namespace std;


/*
æ€è·¯ï¼šæ ¹æ®é¢˜ç›®å¯çŸ¥ï¼Œä¼šè¢«æ’å…¥çš„èŠ‚ç‚¹æœ‰n-1/2ï¼ˆä¸‹å–æ•´ï¼‰ä¸ªï¼Œå³ä»n-(n-1/2)åé¢éƒ½æ˜¯è¦æ’å…¥å‰é¢åºåˆ—çš„èŠ‚ç‚¹
ä»è¯¥ç‚¹å¼€å§‹å¯¹åé¢çš„é‡‡ç”¨å¤´æ’æ³•äºŒæ¬¡æ’å…¥ï¼Œå½¢æˆä¸€ä¸ªåéƒ¨é€†åºï¼Œç„¶åä»å¤´å¼€å§‹éš”æ¬¡æ’å…¥ï¼Œå³å¯å¾—åˆ°é¢˜ç›®è¦æ±‚çš„ç»“æœ
*/
struct node
{
    int data;
    node *next;
};
void changelist(node *h){
    node *p,*q,*r,*s;
    p=q=h;
    while (q->next!=nullptr)//å¯»æ‰¾ä¸­é—´èŠ‚ç‚¹
    {
        p=p->next;
        q=q->next;
        if(q->next!=nullptr) q=q->next;
    }
    q=p->next;//pæ‰€æŒ‡èŠ‚ç‚¹ä¸ºä¸­é—´èŠ‚ç‚¹ï¼Œqä¸ºååŠæ®µé“¾è¡¨çš„é¦–èŠ‚ç‚¹
    p->next=nullptr;//pä¸ºä¸­é—´èŠ‚ç‚¹ï¼Œå°†ä¸­é—´èŠ‚ç‚¹æŒ‡å‘çš„èŠ‚ç‚¹å˜ä¸ºnullptr
    while (q!=nullptr)
    {
        //å°†é“¾è¡¨ååŠæ®µé€†ç½®,p(ä¸­é—´èŠ‚ç‚¹)å……å½“äº†å¤´ç»“ç‚¹çš„åœ°ä½ï¼Œqæˆä¸ºäº†å¾…æ’å…¥é“¾è¡¨çš„èµ·ç‚¹
        r=q->next;//rç”¨æ¥å­˜å‚¨ä¸‹ä¸€ä¸ªè¦æ’å…¥çš„èŠ‚ç‚¹
        q->next=p->next;//å¤´æ’æ³•ï¼ŒqæŒ‡å‘åŸå¤´ç»“ç‚¹æŒ‡å‘çš„èŠ‚ç‚¹
        p->next=q;//qæˆä¸ºå¤´ç»“ç‚¹æŒ‡å‘çš„èŠ‚ç‚¹
        q=r;//qæˆä¸ºä¸‹ä¸€ä¸ªè¦æ’å…¥çš„èŠ‚ç‚¹
    }
    s=h->next;//sæŒ‡å‘å‰åŠæ®µçš„ç¬¬ä¸€ä¸ªæ•°æ®èŠ‚ç‚¹ï¼Œå³æ’å…¥ç‚¹
    q=p->next;//qæŒ‡å‘ååŠæ®µçš„ç¬¬ä¸€ä¸ªæ•°æ®èŠ‚ç‚¹
    p->next=nullptr;//pè¦æˆä¸ºé“¾è¡¨çš„
    while (q!=nullptr)//å°†é“¾è¡¨ååŠæ®µçš„èŠ‚ç‚¹æ’å…¥åˆ°æŒ‡å®šä½ç½®
    {
        r=q->next;//ræŒ‡å‘ååŠæ®µçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        q->next=s->next;//å°†qæ‰€ç›´æ¥ç‚¹æ’å…¥åˆ°sæ‰€æŒ‡ç»“ç‚¹ä¹‹å
        s->next=q;
        s=q->next;//sæŒ‡å‘å‰åŠæ®µçš„ä¸‹ä¸€ä¸ªæ’å…¥ç‚¹
        q=r;//qå˜ä¸ºååŠæ®µè¦æ’å…¥çš„ç‚¹
    }
    

    
}
```

ä½ é—®ï¼šâ€œä¸ºä»€ä¹ˆå¿«æŒ‡é’ˆ q èµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆ p èµ°ä¸€æ­¥ï¼Œæœ€å q åˆ°è¾¾é“¾å°¾æ—¶ p æ­£å¥½åœ¨é“¾è¡¨ä¸­é—´ï¼Ÿâ€

è¿™ä¸ªå…¶å®æ˜¯**å¿«æ…¢æŒ‡é’ˆï¼ˆé¾Ÿå…”èµ›è·‘ï¼‰æ‰¾é“¾è¡¨ä¸­ç‚¹çš„ç»å…¸åŸç†**ï¼Œæˆ‘ç»™ä½ è¯¦ç»†è§£é‡Šä¸€ä¸‹ï¼š

---

åŸç†è¯´æ˜

* è®¾é“¾è¡¨é•¿åº¦ä¸º nã€‚
* æ…¢æŒ‡é’ˆ p æ¯æ¬¡èµ°ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆ qæ¯æ¬¡èµ°ä¸¤æ­¥ã€‚
* å½“å¿«æŒ‡é’ˆ q åˆ°è¾¾é“¾è¡¨æœ«å°¾ï¼ˆæˆ–è¶Šè¿‡æœ«å°¾ï¼‰æ—¶ï¼Œæ…¢æŒ‡é’ˆ p æ‰€æŒ‡èŠ‚ç‚¹å°±æ˜¯é“¾è¡¨çš„ä¸­ç‚¹ã€‚

---

ä¸ºä»€ä¹ˆæˆç«‹ï¼Ÿ

* ç”±äº qé€Ÿåº¦æ˜¯ pçš„ä¸¤å€ï¼Œå‡è®¾ pèµ°äº† k æ­¥ï¼Œé‚£ä¹ˆ qèµ°äº† $2k$ æ­¥ã€‚

* å½“ q åˆ°é“¾å°¾æ—¶ï¼Œé“¾è¡¨æ€»é•¿åº¦æ˜¯ nï¼Œå› æ­¤ï¼š

  $$
  2k \approx n \implies k \approx \frac{n}{2}
  $$

* å³æ…¢æŒ‡é’ˆ p èµ°äº†é“¾è¡¨é•¿åº¦ä¸€åŠçš„æ­¥æ•°ï¼Œåœåœ¨ä¸­ç‚¹ã€‚

---

ç›´è§‚ç¤ºä¾‹

| é“¾è¡¨é•¿åº¦ | qèµ°çš„æ­¥æ•° | p èµ°çš„æ­¥æ•° | p ä½ç½®            |
| -------- | --------- | ---------- | ----------------- |
| 5        | 4\~5      | 2\~3       | ç¬¬3ä¸ªèŠ‚ç‚¹ï¼ˆä¸­é—´ï¼‰ |
| 6        | 6         | 3          | ç¬¬4ä¸ªèŠ‚ç‚¹ï¼ˆä¸­é—´ï¼‰ |

---

ä»£ç ç¤ºä¾‹

```cpp
node* findMiddle(node* head) {
    node* p = head;
    node* q = head;
    while (q != nullptr && q->next != nullptr) {
        p = p->next;
        q = q->next->next;
    }
    return p; // p æŒ‡å‘ä¸­ç‚¹
}
```

---

æ€»ç»“

* å¿«æŒ‡é’ˆä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆä¸€æ­¥ã€‚
* å¿«æŒ‡é’ˆåˆ°æœ«å°¾æ—¶ï¼Œæ…¢æŒ‡é’ˆåˆšå¥½èµ°ä¸€åŠï¼ŒæŒ‡å‘ä¸­ç‚¹ã€‚
* è¿™æ˜¯é“¾è¡¨ä¸­ç‚¹æŸ¥æ‰¾çš„æœ€å¸¸ç”¨æŠ€å·§ã€‚

---

å½¢è±¡æ–‡å­—å›¾

```
lesså¤åˆ¶ç¼–è¾‘èŠ‚ç‚¹ï¼š 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6 â†’ 7 â†’ nullptr

p:        â†‘     â†‘     â†‘     â†‘
         1     2     3     4

q:        â†‘           â†‘           â†‘
         1           3           5           7
```

- æ¯æ¬¡å¾ªç¯ï¼Œpå‘å³èµ°ä¸€ä¸ªèŠ‚ç‚¹ï¼Œqå‘å³èµ°ä¸¤ä¸ªèŠ‚ç‚¹ã€‚
- å½“qåˆ°è¾¾é“¾å°¾æˆ–è¶…å‡ºé“¾å°¾æ—¶ï¼Œpæ‰€åœ¨çš„ä½ç½®å°±æ˜¯ä¸­ç‚¹ã€‚

```c++
//YXC
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void rearrangedList(ListNode* head) {
        if (!head->next) return;
        int n = 0;
        for (auto p = head; p; p = p->next) n ++ ;
        int left = (n + 1) / 2;  // å‰åŠæ®µçš„èŠ‚ç‚¹æ•°
        auto a = head;
        for (int i = 0; i < left - 1; i ++ ) a = a->next;
        auto b = a->next, c = b->next;

        a->next = b->next = NULL;
        while (c) {
            auto p = c->next;
            c->next = b;
            b = c, c = p;
        }

        for (auto p = head, q = b; q;) {
            auto o = q->next;
            q->next = p->next;
            p->next = q;
            p = p->next->next;
            q = o;
        }
    }
};

```



### 2022 äºŒå‰æœç´¢æ ‘

```c++
//è‡ªå·±çš„
#include <iostream>
using namespace std;
/*
æ€è·¯ï¼šéå†æ•°ç»„çš„æ¯ä¸ªç‚¹ï¼Œåˆ¤æ–­å„ç‚¹æ˜¯å¦ç¬¦åˆäºŒå‰æœç´¢æ ‘çš„æƒ…å†µï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(n)
*/
const int max_size =10000;
struct sqbitree{
    int sqbitnode[max_size];
    int Elenum;
};
bool isbst(sqbitree a){
        int n = a.Elenum;
        for(int i = 0;i<n;i++){
            int x=a.sqbitnode[i];
            int lk=a.sqbitnode[i*2+1];
            int rk=a.sqbitnode[i*2+2];
            if(x==-1)continue;
            if(x>=lk &&x<=rk)continue;
            else return false;
        }
        return true;
}
```

```c++
//ç­”æ¡ˆ
```

### 2023 é‚»æ¥çŸ©é˜µ

```c++
//æˆ‘çš„
#include <iostream>
#include <cstring>
using namespace std;
const int MAXV=1000;
struct MGraph
{
    int numVertices,numEdges;
    char VerticesList[MAXV];
    int Edge[MAXV][MAXV];
};
/*
æ€è·¯ï¼šéå†é‚»æ¥çŸ©é˜µï¼Œå½“Edge[a][b]æœ‰å€¼çš„æ—¶å€™è¯´æ˜å­˜åœ¨ä¸€æ¡a->bçš„è¾¹ï¼Œä¹Ÿå°±æ˜¯açš„å‡ºåº¦+1ï¼Œbçš„å…¥åº¦+1ï¼Œ
éå†å®Œæ•´ä¸ªé‚»æ¥çŸ©é˜µåå³å¯å¾—åˆ°æ‰€æœ‰ç‚¹çš„å…¥åº¦å’Œå‡ºåº¦ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(VÂ²)
*/

int printVertices(MGraph G){
    int n = G.numVertices;//ç‚¹çš„æ•°é‡
    int m = G.numEdges;//è¾¹çš„æ•°é‡
    int innum[n];//è®°å½•æ¯ä¸ªé¡¶ç‚¹çš„å…¥åº¦
    int outnum[n];//è®°å½•æ¯ä¸ªé¡¶ç‚¹çš„å‡ºåº¦
    memset(innum,0,sizeof(innum));
    memset(outnum,0,sizeof(outnum));
    for(int i = 0;i<n;i++){
        for(int j = 0 ;j<n;j++)
          {
            if(m<=0) break;//å‰ªæ
            if(G.Edge[i][j]) {
                innum[j]++;//jä¸ºç»ˆç‚¹ï¼Œå…¥åº¦+1
                outnum[i]++;//iä¸ºèµ·ç‚¹ï¼Œå‡ºåº¦+1
                m--;//éå†å®Œä¸€æ¡è¾¹
            } 
          }
    }
    int count=0;
    for(int i= 0;i<n;i++){
        if(outnum[i]>innum[i]){
            cout<<char(i+97);
            count++;
        }
    }
    return count;
}
```

### 2021 é‚»æ¥çŸ©é˜µ

```c++
//è‡ªå·±çš„
#include <iostream>
#include <cstring>
#define INF 0x3f3f3f3f
using namespace std;
const int MAXV=1000;
struct MGraph
{
    int numVertices,numEdges;
    char VerticesList[MAXV];
    int Edge[MAXV][MAXV];
};
/*
æ€è·¯ï¼šä¸å¤§äº2çš„å¶æ•°ï¼Œå³0æˆ–è€…2ï¼Œæˆ‘ä»¬å¯ä»¥éå†æ•´ä¸ªæ•°ç»„ï¼Œè®¡ç®—æ¯ä¸ªé¡¶ç‚¹çš„åº¦ï¼Œç„¶åå†éå†ä¸€éå­˜å‚¨åº¦çš„æ•°ç»„ï¼Œ
å½“åº¦ä¸ºå¥‡æ•°çš„é¡¶ç‚¹ä¸ªæ•°è¶…è¿‡2å°±return 0ï¼Œå¦‚æœæœ€åç»“æœæ˜¯2æˆ–è€…0å°±breakï¼›åŒæ—¶ç”±äºæ˜¯æ— å‘å›¾ï¼Œæ•°ç»„ä¸ºå¯¹ç§°çŸ©é˜µï¼Œ
å¯ä»¥é‡‡ç”¨å‹ç¼©å­˜å‚¨çš„æ€è·¯å‡å°‘éå†çš„æ•°ç»„å…ƒç´ 
æ—¶é—´å¤æ‚åº¦O(vÂ²)ç©ºé—´å¤æ‚åº¦O(V);
*/
int IsExistEL(MGraph G){//å‡è®¾ä¸å­˜åœ¨
        int n = G.numVertices,m=G.numEdges;//ç”¨nå­˜å‚¨é¡¶ç‚¹æ•°ï¼Œmå­˜å‚¨è¾¹æ•°
        int dexnum[n];
        memset(dexnum,0,sizeof dexnum);
        for(int i = 0;i<n;i++){
            for(int j = 0 ;j<i+1;j++){
                if(m == 0) break;
                if(G.Edge[i][j] && G.Edge[i][j]!=INF) {
                    dexnum[i]++;
                    dexnum[j]++;
                    m--;
                }
            }
        }
        int count = 0;
        for(int i = 0;i<n;i++){
                if(count >2) return 0;
                if(dexnum[i]%2) count++;
        }
        if(count ==0 || count == 2)return 1;
        else return 0;
        
}

```

```c++
//ç­”æ¡ˆ
#include <iostream>
#include <cstring>
#define INF 0x3f3f3f3f
using namespace std;
const int MAXV=1000;
struct MGraph
{
    int numVertices,numEdges;
    char VerticesList[MAXV];
    int Edge[MAXV][MAXV];
};
int IsExistEL(MGraph G){//å‡è®¾ä¸å­˜åœ¨
        int degree;
        int count = 0;
        for(int i = 0;i<G.numVertices;i++){
            degree =0;
            for(int j = 0;j<G.numVertices;j++)
                degree+=G.Edge[i][j];
            if(degree%2) count ++;
        }
        if(count==0 ||count==2)return 1;
        else return 0;
        
}

```

### 2024 æ‹“æ‰‘åºåˆ—

```c++
//è‡ªå·±çš„
æ—¶é—´å¤æ‚åº¦O(nÂ²)ç©ºé—´å¤æ‚åº¦O(1)
#include <iostream>
#include <cstring>
using namespace std;
const int MAXV=1000;
struct MGraph
{
    int numVertices,numEdges;//å›¾çš„é¡¶ç‚¹æ•°å’Œæœ‰å‘è¾¹æ•°
    char VerticesList  [MAXV];//é¡¶ç‚¹è¡¨
    int Edge[MAXV][MAXV];//é‚»æ¥çŸ©é˜µï¼Œæ— æƒå›¾
};
/*
æ€è·¯ï¼šæ‹“æ‰‘åºåˆ—å”¯ä¸€ï¼Œè¯´æ˜æ¯æ¬¡å¯ä»¥åŠ å…¥æ‹“æ‰‘åºåˆ—çš„å…¥åº¦ä¸º0çš„ç‚¹æ˜¯å”¯ä¸€çš„ï¼Œç„¶ååŒæ—¶è¯´æ˜æ‹“æ‰‘åºåˆ—å­˜åœ¨ï¼Œ
å› æ­¤åªéœ€è¦åˆ¤æ–­æ¯æ¬¡å…¥åº¦ä¸º0çš„ç‚¹æ˜¯å¦å”¯ä¸€ï¼Œä¸”å½“å…¥åº¦ä¸º0çš„ç‚¹ä¸º0çš„æ—¶å€™ï¼Œæ˜¯å¦è¿˜æœ‰é¡¶ç‚¹æ²¡æœ‰åŠ å…¥æ‹“æ‰‘åºåˆ—ï¼Œå¦‚æœå…¨éƒ¨åŠ å…¥ï¼Œ
åˆ™å­˜åœ¨å”¯ä¸€çš„æ‹“æ‰‘åºåˆ—
*/
int uniquely(MGraph G){
    int n =G.numVertices;
    int d[n];//å­˜å‚¨æ¯ä¸ªé¡¶ç‚¹çš„å…¥åº¦
    memset(d,0,sizeof d);
    for(int j = 0;j<n;j++)//éå†æ¯ä¸ªé¡¶ç‚¹
        for(int i = 0;i<n;i++)//æ¯ä¸ªé¡¶ç‚¹å’Œå…¶ä»–é¡¶ç‚¹æ˜¯å¦æœ‰å…¥è¾¹
            d[j]+=G.Edge[i][j]; 
        //æ‰¾åˆ°å…¥åº¦ä¸º0çš„ç‚¹
    int hh=-1;
    for(int k = 0;k<n;k++){//nä¸ªç‚¹å¾ªç¯næ¬¡
        int dot ;
        for(int i = 0;i<n;i++){//æ‰¾åˆ°å…¥åº¦ä¸º0çš„ç‚¹åŠ å…¥æ‹“æ‰‘åºåˆ—
            if(!d[i])
            {
                ++hh;//åŠ å…¥æ‹“æ‰‘åºåˆ—
                dot = i;
                d[i]=-1;//ä»å›¾ä¸­åˆ é™¤ç‚¹i
            }
           } 
            if(hh!=k) return 0;//æŒ‰ç†æ¥è¯´ä¸€æ¬¡åŠ å…¥ä¸€ä¸ªå…¥åº¦ä¸º0çš„ç‚¹ï¼Œä»è€Œæ‹“æ‰‘åºåˆ—å”¯ä¸€ï¼Œå¦‚æœåŠ å…¥ä¸¤ä¸ªï¼Œè¯´æ˜ä¸å”¯ä¸€
        for(int j = 0;j<n;j++)
            if(G.Edge[dot][j]) d[j]--;//ä»å›¾ä¸­åˆ é™¤è¯¥ç‚¹ä¸ºèµ·ç‚¹çš„è¾¹
    }
    if(hh==(n-1)) return 1;//æ¯ä¸ªç‚¹éƒ½åŠ å…¥äº†æ‹“æ‰‘åºåˆ—
    else return 0;//æœ‰ç‚¹æ²¡æœ‰åŠ å…¥æ‹“æ‰‘åºåˆ—


}

```

### 2016 æ’åº

```c++
//è‡ªå·±çš„
#include <iostream>
using namespace std;
/*
æ€è·¯ï¼šå°†é›†åˆæ’åºï¼Œç„¶åå°†è¾ƒå°çš„ä¸€åŠå½“ä½œA1ï¼Œè¾ƒå¤§çš„ä¸€èˆ¬å½“ä½œA2ï¼Œå³ç¬¦åˆé¢˜ç›®çš„è¦æ±‚,æ—¶é—´å¤æ‚åº¦O(nlogn)ï¼Œç©ºé—´å¤æ‚åº¦O(n)
*/
void quick_sort(int a[],int l,int r){
    if(l>=r)return ;
    int i = l-1,j=r+1;
    int x = a[l+r>>1];
    while (i<j)
    {
        do i++;while(a[i]<x);
        do j--;while(a[j]>x);
        if(i<j)swap(a[i],a[j]);
    }
    quick_sort(a,l,j),quick_sort(a,j+1,r);
    
}
void grouping(int n,int a[]){
        quick_sort(a,0,n-1);
        int n1=n>>1;//å°åŠè¾¹
        int n2=n-n1;//å¤§åŠè¾¹
        int a1[n1];//å°
        int a2[n2];//å¤§
        for(int i = 0;i<n1;i++) a1[i]=a[i];//å°
        for(int i = n1,j=0;i<n;i++,j++)a2[j]=a[i];
}
```

```c++
//ç­”æ¡ˆ
#include <iostream>
using namespace std;
/*
æ€è·¯ï¼šå°†é›†åˆæ’åºï¼Œç„¶åå°†è¾ƒå°çš„ä¸€åŠå½“ä½œA1ï¼Œè¾ƒå¤§çš„ä¸€èˆ¬å½“ä½œA2ï¼Œå³ç¬¦åˆé¢˜ç›®çš„è¦æ±‚,æ—¶é—´å¤æ‚åº¦O(nlogn)ï¼Œç©ºé—´å¤æ‚åº¦O(n)
*/
int setPartition(int a[],int n){
    int pivot,low = 0,low1=0,high=n-1,high1=n-1,flag=1,k=n>>1,i;
    //æ¢çº½å€¼ï¼Œç¬¬ä¸€ç»„çš„èµ·ç‚¹å’Œç»ˆç‚¹ï¼Œç¬¬äºŒç»„çš„èµ·ç‚¹å’Œç»ˆç‚¹ï¼Œåˆ¤æ–­æ˜¯å¦é€€å‡ºå¾ªç¯ï¼Œä¸­é—´å€¼çš„ä½ç½®
    int s1=0,s2=0;//å¤§å°ä¸¤ä¸ªç»„çš„å’Œ
    while (flag)
    {
        pivot=a[low];//ç¬¬ä¸€ä¸ªå€¼ä¸ºæ¢çº½
        while(low<high){//åŒæŒ‡é’ˆåˆ†ç»„
            while(low<high && a[high]>=pivot) --high;
            if(low!=high) a[low]=a[high];
            while(low<high && a[low]<=pivot) ++low;
            if(low!=high) a[high]=a[low];
        }
        a[low]=pivot;//æŠŠæ¢è½´å€¼æ”¾åˆ°æ­£ç¡®ä½ç½®
        if(low == k-1)//å¦‚æœæ•°å‘¨æ˜¯ç¬¬n/2å°çš„ä½ç½®ï¼Œåˆ’åˆ†æˆåŠŸ
            flag =0;
        else{
            if(low <k-1)//è¯´æ˜è¯¥æ¢çº½å€¼å±äºè¾ƒå°çš„ä¸€è¾¹,ç»§ç»­åˆ’åˆ†å³åŠéƒ¨åˆ†
               {
                 low1=++low;//å³åŠéƒ¨åˆ†ä»æ¢è½´å³ç«¯å¼€å§‹ï¼ˆå‚è€ƒäºŒåˆ†ï¼‰
                high=high1;//å³åŠéƒ¨åˆ†çš„å³ç«¯æ˜¯n
               }
            else{//è¯´æ˜æ¢è½´å±äºè¾ƒå¤§çš„ä¸€è¾¹ï¼Œç»§ç»­åˆ’åˆ†å·¦åŠéƒ¨åˆ†
                low = low1;
                high1=--high;
            }
            
        }
    }
    for(int i = 0;i<k;i++)s1+=a[i];
    for(int i = k;i<n;i++)s2+=a[i];
    return s2-s1;    

}
```

## YXCç‰ˆå¼ºåŒ–

### æ—¶é—´å¤æ‚åº¦ã€çŸ©é˜µå±•å¼€ï¼›æ’åºã€è¿›ä½åˆ¶

#### æ—¶é—´ã€ç©ºé—´å¤æ‚åº¦

* åªè€ƒè™‘æ¬¡æ•°ä¸è€ƒè™‘å¸¸æ•°
* å¸¸è§å¤æ‚åº¦
  * O(1)
  * O(n)
  * O(n^k)
  * O(logn)
  * O(nlogn)
  * O(æ ¹å·n)

#### ç‰¹æ®ŠçŸ©é˜µçš„å±•å¼€

* ç»™å‡ºå±•å¼€æ–¹å¼ï¼Œæ±‚ä¸‹æ ‡ä½ç½®

![](/img/202505.jpg)

* **å¯ä»¥å…ˆåˆ—å‡ºæ¯è¡Œçš„å…ƒç´ ä¸ªæ•°ï¼Œç„¶åæ±‚å’Œï¼Œæ˜¯ç¬¬å‡ ä¸ªå…ƒç´ ï¼Œç„¶åä»0å¼€å§‹å°±-1**

![](/img/202732.jpg)

![](/img/203257.jpg)

### çº¿æ€§è¡¨

```c++
//å®šä¹‰é“¾è¡¨ç»“ç‚¹
struct Node{
    int val;
    Node *next;//åŒé“¾è¡¨è¿˜è¦åŠ *pre
}
//åˆ›å»ºé“¾è¡¨
Node * head = new Node();
//éå†é“¾è¡¨
void print(Node * head)
{
    for(auto p = head;p;p=p->next)
        cout<<p->val <<' ';
    cout<<endl;
}
//headä¸æ˜¯ä¸€ä¸ªç»“ç‚¹ï¼Œheadå­˜çš„æ˜¯ç¬¬ä¸€ä¸ªç»“ç‚¹çš„åœ°å€
```

### æ ˆä¸é˜Ÿåˆ—

* æ ˆçš„é“¾å¼å­˜å‚¨

  * å¤´ç»“ç‚¹å½“æ ˆé¡¶ï¼Œå°¾ç»“ç‚¹å½“æ ˆåº•ï¼Œå¤´æ’æ³•ï¼Œå¤´åˆ 

* é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨

  ```c++
  //é˜Ÿå°¾æŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªè¦å­˜çš„ä½ç½®
  node *front = new Node(),*rear=front;
  rear->val=1;
  rear->next=new node();
  rear=rear->next;
  ```

* åªæœ‰éœ€è¦å›åˆ°ä¸Šä¸€å±‚æ‰éœ€è¦ç”¨åˆ°æ ˆï¼Œå°¾é€’å½’ä¸æ¶‰åŠæ ˆ
* æ ˆdfsï¼Œé˜Ÿåˆ—bfs
* è¡¨è¾¾å¼æ±‚å€¼
  * ä¸¤ä¸ªæ ˆï¼Œä¸€ä¸ªç”¨æ¥å­˜æ“ä½œæ•°ï¼Œä¸€ä¸ªå­˜æ“ä½œç¬¦
  * æ•°æ ˆé‡åˆ°æ•°åˆ™å‹æ ˆ
    * è¿ç®—ç¬¦æ ˆé‡åˆ°ï¼ˆå‹æ ˆï¼Œé‡åˆ°ï¼‰æ“ä½œåˆ°ï¼ˆ
    * +-*/æ“ä½œåˆ°é‡åˆ°ï¼ˆæˆ–è€…æ ˆé¡¶ä¼˜å…ˆçº§<å½“å‰
    * æ“ä½œå®Œè¿ç®—ç¬¦æ ˆï¼Œæ•°æ ˆæ ˆé¡¶å°±æ˜¯ç­”æ¡ˆ

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unordered_map>
#include <stack>

using namespace std;

stack<char> op;
stack<int> num;

void eval()
{
    auto b = num.top(); num.pop();
    auto a = num.top(); num.pop();
    auto c = op.top(); op.pop();

    int x;
    if (c == '+') x = a + b;
    else if (c == '-') x = a - b;
    else if (c == '*') x = a * b;
    else x = a / b;
    num.push(x);
}

int main()
{
    string s;
    cin >> s;

    unordered_map<char, int> pr{{'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}};
    for (int i = 0; i < s.size(); i ++ )
    {
        if (isdigit(s[i]))
        {
            int j = i, x = 0;
            while (j < s.size() && isdigit(s[j]))
                x = x * 10 + s[j ++ ] - '0';//æŠŠè¿ç»­çš„æ•°å­—å­—ç¬¦è½¬æˆæ•´æ•°
            num.push(x);
            i = j - 1;
        }
        else if (s[i] == '(') op.push(s[i]);
        else if (s[i] == ')')
        {
            while (op.top() != '(') eval();
            op.pop();
        }
        else
        {
            while (op.size() && op.top() != '(' && pr[op.top()] >= pr[s[i]])
                eval();
            op.push(s[i]);
        }
    }

    while (op.size()) eval();
    cout << num.top() << endl;

    return 0;
}
```

### æ ‘

* äºŒå‰æ ‘èŠ‚ç‚¹è®¡ç®—çš„å¸¸ç”¨æ–¹æ³•ï¼š
  * æ•°å­¦å½’çº³æ³•
  
  * é€’æ¨
  
    ![](/img/21357.jpg)
  
  * è§£æ–¹ç¨‹/ç­‰å¼ä»£æ¢
  
    * å…ˆæ±‚ç‚¹æ•°å†æ±‚è¾¹æ•°
    * è¾¹æ•°=ç‚¹æ•°-1
  
* å‰é©±ï¼šä¸­åºéå†çš„å‰ä¸€ä¸ªç‚¹

* åç»§ï¼šä¸­åºéå†çš„åä¸€ä¸ªç‚¹

* æ ‘ä¸äºŒå‰æ ‘çš„è½¬æ¢ï¼šåŸæ ‘ä¸­å¶å­èŠ‚ç‚¹æ•°=è½¬æ¢åçš„æ ‘ä¸­æœ‰å³å­©å­çš„ç»“ç‚¹æ•°+1

  * åŸæ ‘ä¸­å¶å­èŠ‚ç‚¹ä¸ªæ•° = è½¬æ¢åçš„æ ‘ä¸­æœ‰å³å„¿å­çš„èŠ‚ç‚¹æ•° + 1

  * åŸæ ‘ä¸­åˆ†æ”¯èŠ‚ç‚¹ä¸ªæ•° = è½¬æ¢åçš„æ ‘ä¸­æ— å³å„¿å­çš„èŠ‚ç‚¹æ•° - 1

  * è½¬æ¢åçš„æ ‘ä¸­æœ‰å³å„¿å­çš„èŠ‚ç‚¹æ•° = åŸæ ‘ä¸­æœ‰å³å…„å¼Ÿçš„èŠ‚ç‚¹æ•°

  * èŠ‚ç‚¹æ€»æ•° = åŸæ ‘ä¸­åŸæ ‘ä¸­å¶å­èŠ‚ç‚¹ä¸ªæ•° + åŸæ ‘ä¸­åŸæ ‘ä¸­åˆ†

    æ”¯èŠ‚ç‚¹ä¸ªæ•° = è½¬æ¢åçš„æ ‘ä¸­æœ‰å³å„¿å­çš„èŠ‚ç‚¹æ•° + è½¬æ¢åçš„æ ‘ä¸­æ— å³å„¿å­çš„èŠ‚ç‚¹æ•°

* æ£®æ—ä¸äºŒå‰æ ‘çš„è½¬æ¢

  * æ£®æ—ä¸­çš„å¶èŠ‚ç‚¹ä¸ªæ•°=è½¬æ¢åäºŒå‰æ ‘ä¸­æœ‰å³å­©å­çš„ç»“ç‚¹æ•°+æ£®æ—çš„é¢—æ ‘

* æ£®æ—çš„å‰åºéå†å°±æ˜¯æ ‘äºŒå‰æ ‘çš„å‰åºéå†

* æ£®æ—çš„ååºéå†å°±æ˜¯äºŒå‰æ ‘çš„ä¸­åºéå†

  * å› ä¸ºåªæœ‰äºŒå‰æ ‘èƒ½æ‰¾åˆ°å·¦å³ï¼Œæ£®æ—åˆ†ä¸å‡ºå·¦å³åªèƒ½åˆ†å­æ ‘å’Œæ ¹

* æ‰€æœ‰èŠ‚ç‚¹éƒ½æœ‰0ä¸ªå­©å­æˆ–è€…2ä¸ªå­©å­çš„æ—¶å€™ï¼Œå‰åºéå†å’Œååºéå†å¯ä»¥å”¯ä¸€ç¡®å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œä½†æ˜¯å½“æœ‰ç»“ç‚¹åªæœ‰1ä¸ªå­©å­çš„æ—¶å€™ï¼Œå‰åºéå†å’Œååºéå†ä¸å¯ä»¥å”¯ä¸€ç¡®å®šä¸€ä¸ªäºŒå‰æ ‘

* äºŒå‰æœç´¢æ ‘(BST)ï¼šä¸­åºéå†æœ‰åºçš„äºŒå‰æ ‘

  * æ’å…¥
    * O(logn)
    * æ¯æ¬¡æ’å…¥å¿…ç„¶æ’å…¥åˆ°å¶å­èŠ‚ç‚¹
  * åˆ é™¤
    * O(logn)
    * å¶å­èŠ‚ç‚¹ç›´æ¥åˆ é™¤
    * åªæœ‰å·¦å­æ ‘æˆ–è€…å³å­æ ‘ï¼Œç”¨å·¦å­æ ‘æˆ–è€…å³å­æ ‘çš„æ ¹èŠ‚ç‚¹æ›¿æ¢æ‰åˆ é™¤çš„ç»“ç‚¹
    * å·¦å³å­æ ‘çš†æœ‰ï¼Œç”¨ä¸­åºéå†å‰é©±æ›¿ä»£åˆ é™¤çš„ç‚¹
  * æŸ¥æ‰¾
    * O(logn)

```c++
//äºŒå‰æœç´¢æ ‘
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int INF = 1e8;

struct TreeNode
{
    int val;
    TreeNode *left, *right;
    TreeNode(int _val): val(_val), left(NULL), right(NULL) {}
}*root;

void insert(TreeNode* &root, int x)
{
    if (!root) root = new TreeNode(x);
    else if (x < root->val) insert(root->left, x);
    else insert(root->right, x);
}

void remove(TreeNode* &root, int x)
{
    if (!root) return;
    if (x < root->val) remove(root->left, x);
    else if (x > root->val) remove(root->right, x);
    else
    {
        if (!root->left && !root->right) root = NULL;
        else if (!root->left) root = root->right;
        else if (!root->right) root = root->left;
        else
        {
            auto p = root->left;
            while (p->right) p = p->right;
            root->val = p->val;
            remove(root->left, p->val);
        }
    }
}

int get_pre(TreeNode* root, int x)
{
    if (!root) return -INF;
    if (root->val >= x) return get_pre(root->left, x);
    return max(root->val, get_pre(root->right, x));
}

int get_suc(TreeNode* root, int x)
{
    if (!root) return INF;
    if (root->val <= x) return get_suc(root->right, x);
    return min(root->val, get_suc(root->left, x));
}

int main()
{
    int n;
    cin >> n;
    while (n -- )
    {
        int t, x;
        cin >> t >> x;
        if (t == 1) insert(root, x);
        else if (t == 2) remove(root, x);
        else if (t == 3) cout << get_pre(root, x) << endl;
        else cout << get_suc(root, x) << endl;
    }

    return 0;
}

```

* å¹³è¡¡äºŒå‰æ ‘

  * å¹³è¡¡å› å­ï¼š**å·¦-å³**
  * å·¦æ—‹å³æ—‹åªæ”¹å˜é«˜åº¦ä¸æ”¹å˜ä¸­åºéå†é¡ºåº

  ![](/img/215829.jpg)

* è¡¨è¾¾å¼æ ‘æ˜¯äºŒå‰æ ‘ï¼Œåˆ†æ”¯èŠ‚ç‚¹éƒ½æ˜¯è¿ç®—ç¬¦ï¼Œå¶å­èŠ‚ç‚¹éƒ½æ˜¯æ•°å­—/å­—ç¬¦

  * ä»å·¦åˆ°å³ï¼ŒæŒ‰ç…§é¡ºåºæ„é€ 
  * å‰ç¼€è¡¨è¾¾å¼ï¼šè¡¨è¾¾å¼æ ‘çš„å‰åºéå†
  * åç¼€è¡¨è¾¾å¼ï¼šè¡¨è¾¾å¼æ ‘çš„ååºéå†

* å¦‚ä½•åˆ¤æ–­å…³é”®å­—åºåˆ—èƒ½å¦æ„æˆäºŒå‰æ’åºæ ‘ä¸­çš„æŸ¥æ‰¾è·¯å¾„

  * ç”»å‡ºåºåˆ—æ„æˆçš„äºŒå‰æ ‘ï¼Œç„¶åè¿›è¡Œä¸­åºéå†çœ‹æ˜¯å¦æœ‰åº
  
* å“ˆå¤«æ›¼æ ‘

  * å‰ç¼€ç¼–ç â†’æ‰€æœ‰ç¼–ç å‡å¯¹åº”å¶èŠ‚ç‚¹
  * ä»ä¸‹å¾€ä¸Šæ„é€ ä¸€æ£µæ ‘ï¼Œæ¯æ¬¡åˆå¹¶æ ¹èŠ‚ç‚¹å€¼æœ€å°çš„å­æ ‘
  * æ‰€æœ‰ç‚¹çš„åº¦æ•°ä¸ä¸º1
  * ä¸€å®šæœ‰ä¸€ä¸ªæœ€ä¼˜è§£ï¼Œä½¿å¾—æƒå€¼æœ€å°çš„ä¸¤ä¸ªç‚¹äº’ä¸ºå…„å¼Ÿ
  
* å¹¶æŸ¥é›†

  * æŒ‰ç§©åˆå¹¶å°±æ˜¯æŒ‰ç…§å¤§å°ï¼Œå°æ ‘åˆåˆ°å¤§æ ‘

### å›¾

* é‚»æ¥å¤šé‡è¡¨**ç†è®ºä¸Š**æ‰¾æ— å‘å›¾çš„åå‘è¾¹æ¯”é‚»æ¥è¡¨æ–¹ä¾¿
* åå­—é“¾è¡¨æ˜¯å¯¹é‚»æ¥çŸ©é˜µçš„ä¼˜åŒ–ï¼Œå®é™…ä¸Šä¹Ÿå¯ä»¥å­˜æ— å‘å›¾
* é‚»æ¥çŸ©é˜µå’Œåå­—é“¾è¡¨æ— æ³•å­˜é‡è¾¹ï¼Œé‚»æ¥è¡¨å’Œé‚»æ¥å¤šé‡è¡¨å¯ä»¥å­˜é‡è¾¹
* ä¸‰å…ƒç»„è¡¨ä¹Ÿèƒ½å­˜é‡è¾¹
* åˆ¤æ–­dijkstraç®—æ³•æœ€çŸ­è·¯å¾„çš„å¿«æ·æ–¹æ³•
  * ç›´æ¥çœ‹æ¯ä¸ªç‚¹åˆ°èµ·ç‚¹çš„è·ç¦»ï¼Œç„¶åä»å°åˆ°å¤§æ’åº

### æŸ¥æ‰¾

#### æœ‰åºçº¿æ€§è¡¨çš„æŸ¥æ‰¾

![](/img/215722.jpg)

#### äºŒåˆ†æŸ¥æ‰¾

* (low+high)/2ä¸‹å–æ•´
* (low+high+1)/2ä¸Šå–æ•´
  * äºŒåˆ†è¦ä¿æŒä¸€è‡´ï¼Œä¸Šå–æ•´å°±ä¸€ç›´ä¸Šå–æ•´ï¼Œä¸‹å–æ•´å°±ä¸€ç›´ä¸‹å–æ•´
  * å°äºåˆ™å³ç«¯ç‚¹=mid-1ï¼Œå¤§äºåˆ™å³ç«¯ç‚¹=mid+1
  * **å¹³å‡æˆåŠŸæŸ¥æ‰¾é•¿åº¦=log(n+1)-1**
* **æŠ˜åŠæŸ¥æ‰¾ä¸­åºéå†æœ‰åº**
* åˆ¤å®šæŠ˜åŠæŸ¥æ‰¾åˆ¤å®šæ ‘ï¼šçœ‹ä¸Šä¸‹å–æ•´æ˜¯å¦ä¸€è‡´ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸Šå–æ•´è¦ä¸€ç›´ä¸Šå–æ•´ï¼Œä¸‹å–æ•´è¦ä¸€ç›´ä¸‹å–æ•´
  * **å¿«é€Ÿåˆ¤å®šï¼šè¦ä¹ˆå·¦è¾¹ä¸€ç›´æ¯”å³è¾¹èŠ‚ç‚¹å¤šï¼Œè¦ä¹ˆå³å­æ ‘ä¸€ç›´æ¯”å·¦å­æ ‘ç»“ç‚¹å¤š**

#### åˆ†å—æŸ¥æ‰¾

![](/img/221442.jpg)

![](/img/221707.jpg)

#### Bæ ‘å’ŒB+æ ‘

* ä¸»è¦ç”¨äºç¡¬ç›˜æˆ–è€…æ–‡ä»¶ç³»ç»Ÿç®¡ç†ã€æ•°æ®åº“
  * è¯»å†™æ…¢
  * æ–‡ä»¶å¤§
* Bæ ‘ä¸­é—´çš„ç‚¹æœ‰ä¿¡æ¯
* è€ŒB+æ ‘ä¸­é—´çš„ç‚¹ä»…ä½œåŒºåˆ†åˆ†ç±»ç”¨ï¼Œä¸ä¿ç•™ä¿¡æ¯ï¼Œä¿¡æ¯å…¨éƒ¨å­˜å‚¨åœ¨æ ¹èŠ‚ç‚¹
  * å…¨éƒ¨æ”¾åœ¨å¶èŠ‚ç‚¹ï¼Œå±€éƒ¨æ€§å¾ˆå¥½ï¼Œæ–¹ä¾¿ä¸€å—è¯»ï¼Œå…¨åœ¨åŒä¸€å±‚
* ä¸Šå–æ•´ï¼ˆm/2ï¼‰-1=m/2ä¸‹å–æ•´

![](/img/223952.jpg)

* Bæ ‘å‘ä¸Šåˆ†è£‚çš„æ—¶å€™ï¼Œä¸­é—´èŠ‚ç‚¹å­˜åœ¨ä¸Šä¸€å±‚çš„ç»“ç‚¹ï¼Œä½†æ˜¯B+æ ‘å‘ä¸Šåˆ†è£‚çš„æ—¶å€™ï¼Œç”±äºæ‰€æœ‰ä¿¡æ¯å­˜å‚¨åœ¨å¶èŠ‚ç‚¹ï¼Œæ‰€ä»¥ä¸Šé¢åˆ†ç¦»å‡ºå»çš„åªæ˜¯ç´¢å¼•èŠ‚ç‚¹ï¼Œè€Œåˆ†è£‚å‡ºæ¥çš„ä¸¤ç»„å¶èŠ‚ç‚¹ä¸­ï¼ŒåŒäº²ç»“ç‚¹çš„ä¿¡æ¯å­˜å‚¨åœ¨å³è¾¹é‚£ä¸€ç»„
  * å¦‚æœåˆ†è£‚çš„æ˜¯ç´¢å¼•èŠ‚ç‚¹ï¼Œåˆ™ç›´æ¥åˆ†è£‚ä¸ç”¨å­˜å¤šæ¬¡
  * **ç´¢å¼•èŠ‚ç‚¹ä¸éœ€è¦é‡å¤**
  * B+æ ‘æ¯æ¬¡æ•°æ®æŸ¥è¯¢çš„æ¬¡æ•°éƒ½ä¸€æ ·ï¼Œå› ä¸ºéƒ½æ˜¯æŸ¥æ‰¾åˆ°å¶èŠ‚ç‚¹

#### å“ˆå¸Œè¡¨

* **æ‹‰é“¾æ³•**åˆç§°ä¸º**å¼€æ•£åˆ—æ³•**
* **å¼€æ”¾å¯»å€æ³•**åˆç§°ä¸º**é—­æ•£åˆ—æ³•**
* è´Ÿè½½å› å­=**å·²æœ‰å…ƒç´ æ•°/æ•°ç»„é•¿åº¦**
  * **è´Ÿè½½å› å­è¶Šä½ï¼Œæ•ˆç‡è¶Šé«˜**
* å“ˆå¸Œå‡½æ•°
  * ä¹˜ä½™å–æ•´æ³•ï¼šn*(A * xçš„å°æ•°éƒ¨åˆ†)ï¼ŒAæ˜¯0-1ä¹‹é—´çš„æ•°
  * å¹³æ–¹å–ä¸­æ³•ï¼šå…ˆå¹³æ–¹ï¼Œç„¶åå–ä¸­é—´å‡ ä½
  * åŸºæ•°è½¬æ¢æ³•ï¼šæ¢æˆå…¶ä»–è¿›åˆ¶ï¼Œç„¶åå–å…¶ä¸­å‡ ä½
* çº¿æ€§æ¢æµ‹æ³•ã€äºŒæ¬¡æ¢æŸ¥æ³•ã€éšå³æ¢æŸ¥æ³•ï¼Œéƒ½å®¹æ˜“äº§ç”ŸäºŒçº§èšé›†é—®é¢˜
* æŸ¥æ‰¾æ•ˆç‡æŒ‡çš„æ˜¯æ—¶é—´ï¼Œå­˜å‚¨æ•ˆç‡æŒ‡çš„æ˜¯ç©ºé—´
* **å“ˆå¸Œè¡¨çš„æŸ¥æ‰¾å¤±è´¥é•¿åº¦æ˜¯é’ˆå¯¹æ•´æ•°åŸŸæ¥è®²çš„ï¼Œä¹Ÿå°±æ˜¯è¯´key%Mï¼Œåˆ†æ¯å°±æ˜¯1/Mï¼Œåˆ†å­0~M-1çš„å¯¹åº”å¤±è´¥æŸ¥æ‰¾æ¬¡æ•°ï¼Œè¦æŸ¥åˆ°ç©ºæ‰åœæ­¢

#### çº¢é»‘æ ‘

* **æ‰€æœ‰æ ¹èŠ‚ç‚¹éƒ½æ˜¯é»‘è‰²ä¸æ˜¯æŒ‡çš„å®ç»“ç‚¹ï¼Œè€Œæ˜¯æŒ‡çš„ç©ºé»‘å¶èŠ‚ç‚¹**
* **é»‘è·¯åŒ**ï¼Œå€¼å¾—ä¹Ÿæ˜¯ä»ä»»æ„èŠ‚ç‚¹å‡ºå‘ï¼Œåˆ°è¾¾ä»»ä¸€**ç©ºå¶èŠ‚ç‚¹**çš„è·¯å¾„ä¸Š**ç»è¿‡çš„é»‘èŠ‚ç‚¹æ•°é‡ç›¸åŒï¼ˆåŒ…æ‹¬é»‘ç©ºå¶èŠ‚ç‚¹ï¼‰**
* æ‰€æœ‰æ“ä½œçš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯**log(n)**
* **çº¢é»‘æ ‘çš„åˆ é™¤ï¼šå•å­æ ‘ç›´æ¥åˆ ï¼ŒåŒå­æ ‘ç”¨åç»§æ›¿ä»£ï¼Œæ¥ç€é€’å½’è°ƒæ•´ç›´åˆ°ç¬¦åˆçº¢é»‘æ ‘çš„æ€§è´¨**

## ç®—æ³•é¢˜åˆ·é¢˜

é¢˜è¡¨ï¼š

* [408ä»£ç é¢˜åˆ·é¢˜è®¡åˆ’.pdf](https://file.notion.so/f/f/fbff4ca3-9f79-4552-9e30-89914ac1f5ca/2b9f0791-bdaa-4067-8b08-838e4eff8e01/408ä»£ç é¢˜åˆ·é¢˜è®¡åˆ’.pdf?table=block&id=1c8b5125-721b-80c6-80cb-c5cf68d434ab&spaceId=fbff4ca3-9f79-4552-9e30-89914ac1f5ca&expirationTimestamp=1754784000000&signature=sPsFFeOIi2NC9QCGVJ6EnOpultV2o_SjKxSKUJo3a8Y&downloadName=408ä»£ç é¢˜åˆ·é¢˜è®¡åˆ’.pdf)
* [408é¢˜å• - åŠ›æ‰£ï¼ˆLeetCodeï¼‰å…¨çƒæå®¢æŒšçˆ±çš„æŠ€æœ¯æˆé•¿å¹³å°](https://leetcode.cn/problem-list/sUj8ubkb/)

æ•£é¢˜ï¼š

* [1451. å•é“¾è¡¨å¿«é€Ÿæ’åº - AcWingé¢˜åº“](https://www.acwing.com/problem/content/1453/)
* [34. é“¾è¡¨ä¸­ç¯çš„å…¥å£ç»“ç‚¹ - AcWingé¢˜åº“](https://www.acwing.com/problem/content/86/)
* [1636. æŒ‰ç…§é¢‘ç‡å°†æ•°ç»„å‡åºæ’åº - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/sort-array-by-increasing-frequency/description/)
* [179. æœ€å¤§æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/largest-number/description/)
* [977. æœ‰åºæ•°ç»„çš„å¹³æ–¹ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)
* [268. ä¸¢å¤±çš„æ•°å­— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/missing-number/description/)
* [1877. æ•°ç»„ä¸­æœ€å¤§æ•°å¯¹å’Œçš„æœ€å°å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/minimize-maximum-pair-sum-in-array/description/)
* [950. æŒ‰é€’å¢é¡ºåºæ˜¾ç¤ºå¡ç‰Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/reveal-cards-in-increasing-order/description/)
* [785. å¿«é€Ÿæ’åº - AcWingé¢˜åº“](https://www.acwing.com/problem/content/787/)
* [786. ç¬¬kä¸ªæ•° - AcWingé¢˜åº“](https://www.acwing.com/problem/content/description/788/)
* https://leetcode.cn/tag/linked-list/problemset/åŠ›æ‰£é“¾è¡¨é¢˜é›†
* https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list/
* [408ä¹‹2023å¹´ç®—æ³•é¢˜é¢„æµ‹ - çŸ¥ä¹](https://zhuanlan.zhihu.com/p/587248719)
* https://leetcode.cn/problems/reverse-nodes-in-k-group/
* [3302. è¡¨è¾¾å¼æ±‚å€¼ - AcWingé¢˜åº“](https://www.acwing.com/problem/content/3305/)
* [206. åè½¬é“¾è¡¨ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/reverse-linked-list/description/)
* [20. æœ‰æ•ˆçš„æ‹¬å· - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/valid-parentheses/description/)
* [18. é‡å»ºäºŒå‰æ ‘ - AcWingé¢˜åº“](https://www.acwing.com/problem/content/23/)
* [104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)
* [111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)
* [112. è·¯å¾„æ€»å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/path-sum/description/)
* [113. è·¯å¾„æ€»å’Œ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/path-sum-ii/description/)
* [129. æ±‚æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/)
* [257. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/binary-tree-paths/description/)
* [100. ç›¸åŒçš„æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/same-tree/solutions/2015056/ru-he-ling-huo-yun-yong-di-gui-lai-kan-s-empk/)
* [101. å¯¹ç§°äºŒå‰æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/symmetric-tree/solutions/2015063/ru-he-ling-huo-yun-yong-di-gui-lai-kan-s-6dq5/)
* [110. å¹³è¡¡äºŒå‰æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/balanced-binary-tree/solutions/2015068/ru-he-ling-huo-yun-yong-di-gui-lai-kan-s-c3wj/)
* [199. äºŒå‰æ ‘çš„å³è§†å›¾ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/binary-tree-right-side-view/solutions/2015061/ru-he-ling-huo-yun-yong-di-gui-lai-kan-s-r1nc/)
* [226. ç¿»è½¬äºŒå‰æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/invert-binary-tree/description/)
* [1026. èŠ‚ç‚¹ä¸å…¶ç¥–å…ˆä¹‹é—´çš„æœ€å¤§å·®å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/description/)
* [1080. æ ¹åˆ°å¶è·¯å¾„ä¸Šçš„ä¸è¶³èŠ‚ç‚¹ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/description/)
* [1110. åˆ ç‚¹æˆæ— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/delete-nodes-and-return-forest/description/)
* [1372. äºŒå‰æ ‘ä¸­çš„æœ€é•¿äº¤é”™è·¯å¾„ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/description/)
* [98. éªŒè¯äºŒå‰æœç´¢æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/validate-binary-search-tree/solutions/2020306/qian-xu-zhong-xu-hou-xu-san-chong-fang-f-yxvh/)
* [230. äºŒå‰æœç´¢æ ‘ä¸­ç¬¬ K å°çš„å…ƒç´  - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/)
* [501. äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/)
* [700. äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/search-in-a-binary-search-tree/description/)
* [1373. äºŒå‰æœç´¢å­æ ‘çš„æœ€å¤§é”®å€¼å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/description/)
* [236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solutions/2023872/fen-lei-tao-lun-luan-ru-ma-yi-ge-shi-pin-2r95/)
* [235. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/solutions/2023873/zui-jin-gong-gong-zu-xian-yi-ge-shi-pin-8h2zc/)
* [102. äºŒå‰æ ‘çš„å±‚åºéå† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/binary-tree-level-order-traversal/solutions/2049807/bfs-wei-shi-yao-yao-yong-dui-lie-yi-ge-s-xlpz/)
* [103. äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/solutions/2049827/bfs-wei-shi-yao-yao-yong-dui-lie-yi-ge-s-xlv3/)
* [513. æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/find-bottom-left-tree-value/solutions/2049776/bfs-wei-shi-yao-yao-yong-dui-lie-yi-ge-s-f34y/)
* [104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)
* [111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)
* [199. äºŒå‰æ ‘çš„å³è§†å›¾ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/binary-tree-right-side-view/solutions/2015061/ru-he-ling-huo-yun-yong-di-gui-lai-kan-s-r1nc/)
* [144. äºŒå‰æ ‘çš„å‰åºéå† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)
* [94. äºŒå‰æ ‘çš„ä¸­åºéå† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)
* [145. äºŒå‰æ ‘çš„ååºéå† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)
* [107. äºŒå‰æ ‘çš„å±‚åºéå† II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/)
* [404. å·¦å¶å­ä¹‹å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/sum-of-left-leaves/description/)
* [108. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/)
* [958. äºŒå‰æ ‘çš„å®Œå…¨æ€§æ£€éªŒ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/check-completeness-of-a-binary-tree/description/)
* [109. æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/description/)
* [1334. é˜ˆå€¼è·ç¦»å†…é‚»å±…æœ€å°‘çš„åŸå¸‚ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/)
* [210. è¯¾ç¨‹è¡¨ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/course-schedule-ii/description/)
* 

## ç®—æ³•ç§¯ç´¯

### ä»æ— åºé¡ºåºè¡¨ä¸­åˆ é™¤æ‰€æœ‰å€¼ä¸ºxçš„å…ƒç´ 

* æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(1)

![](/img/230639.jpg)

```c++
void delete_x(vector<int>&nums,int x){
    int i;
    int j;
    for(i = 0;i<num.size();i++){
        if(nums[i]!=x){
            nums[j]=nums[i];
            j++;
        }
    }
}
```

### æ— åºè¡¨åˆ é™¤å€¼ä¸ºsåˆ°tä¹‹é—´çš„æ‰€æœ‰å…ƒç´ 

* æ€è·¯ï¼šå¿«æ…¢æŒ‡é’ˆ

![](/img/184846.jpg)

```c++
void delte_s_t(seqlist & l,int s,int t){
	for(int i = 0,j=0;i<l.length;i++){
        if(l.data[i]<s ||l.data[i]>t)
            l.data[j++]=l.data[i];
    }
    l.length=j;
}
```

### æœ‰åºè¡¨ä¸­åˆ é™¤å€¼ä¸ºsåˆ°tä¹‹é—´çš„æ‰€æœ‰å…ƒç´ 

* æ€è·¯ï¼šæ‰¾åˆ°ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªå€¼å¤„äºè¯¥åŒºé—´çš„å…ƒç´ ä¸‹æ ‡ï¼Œç„¶åå°†è¯¥åŒºé—´çš„åé¢çš„å…ƒç´ ä¾æ¬¡å‰ç§»å³å¯ã€‚

```c++
void delete(seqlist &l,int s,int t){
    int i =0;
    int j = length-1;
    while(l.data[i]<s &&i<length)
        	i++;
    while(l.data[j]>t &&j>=0)
        	j--;
    if(i<j){
        int d= j-i+1;
        j++;
        while(j<nums.size()){
			l.data[i++]=l.data[j];
            j++;
        }
        l.length -=d;
    }
    else{
        return;
    }
}
```

### åˆ é™¤é‡å¤å…ƒç´ 

```c++
int remove(seqlist &l){
    if(l.length == 0)return 0;
    int fast = 1,slow =1;
    while(fast<length){
        if(l.data[fast]!=l.data[fast-1]){
            l.data[slow]=l.data[fast];
        ++slow;
        }
        ++fast;
    }
    length =slow;
    return length;
}
```

### æ•°ç»„é€†ç½®

```c++
void reverse(vector<int> &nums){
    int i =0,j=nums.size()-1,tmp;
    while(i<j){
        tmp=nums[i];
        nums[i]=nums[j];
        nums[j]=tmp;
        ++i,--j;
    }
}
```

### åˆ é™¤å€’æ•°ç¬¬kä¸ªæ•°

* å¿«æ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆå…ˆè¿è¡Œkæ­¥

```c++
listnode* remove(listnode *head,int n)
{
    listnode *left=head,*right=head;
    while(n--){
        right=right->next;
    }
    while(right->next){
        left=left->next;
        right=right->next;
    }
    left->next=left->next->next;
    return head;
}
```

### å¸¦æœ‰å¤´ç»“ç‚¹çš„é“¾è¡¨é€†åºè¾“å‡ºæ¯ä¸ªèŠ‚ç‚¹çš„å€¼

```c++
void print(Lnode *L){
    if(L->next=nullptr){
        cout<<L->data<<" ";//é€’å½’å‡ºå£
    }
    print(L->next);
}
void printlist(Lnode *head){
    print(head->next);
}
```

### åè½¬é“¾è¡¨

* å¤´æ’æ³•

```c++
Lnode* reverse(Lnode *&L){
    Lnode *p=L->next,*r;
    L->next=nullptr;
    while(p){
        r=p->next;
        p->next=L->next;
        L->next=p;
        p=r;
    }
    return L;
}//æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(1)
```

* è¿­ä»£æ³•

```c++
Lnode* reverse(Lnode *&L){
    Lnode *pre=nullptr,*cur = L;
    while(cur){
        Lnode *next=cur->next;
        cur->next=pre;
        pre=cur;
        cur=next;
    }
    return pre;
}
Lnode *reverselist(Lnode *&L){
    L->next=reverse(L->next);
    return L;
}//æ—¶é—´å¤æ‚åº¦O(n),ç©ºé—´å¤æ‚åº¦O(1)
//åè½¬ç»“æŸåï¼Œä»åŸé“¾è¡¨ä¸Šçœ‹ï¼ŒpreæŒ‡å‘åè½¬è¿™ä¸€æ®µçš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼ŒcuræŒ‡å‘åè½¬è¿™ä¸€æ®µååºçš„ä¸‹ä¸€ä¸ªç»“ç‚¹ã€‚
```

### åè½¬éƒ¨åˆ†é“¾è¡¨

```c++
Lnode* reverselist(Lnode *&head,int left,int right){
    Lnode *p0=head;
    for(int i = 0;i<left-1;++i){
        p0=p0->next;//æ‰¾åˆ°é“¾è¡¨ä¸­å¾…åè½¬éƒ¨åˆ†çš„å‰ä¸€ä¸ªç»“ç‚¹
    }
    Lnode *pre =nullptr,*cur = p0->next;
    for(int i = 0;i<right-left+1;i++){
        Lnode *next = cur->next;
        cur->next=re;
        pre=cur;
        cur=next;
    }
    //ä¸­é—´åè½¬å®Œæ¯•ï¼Œå’ŒåŸé“¾è¡¨è¿æ¥
    p0->next->next=cur;//ä¸­é—´éƒ¨åˆ†åè½¬å®Œæ¯•åcuræŒ‡å‘ä¸­é—´éƒ¨åˆ†çš„æœ€åä¸€ä¸ªç»“ç‚¹ï¼Œæ­¤å¤„è¿›è¡Œæœ€åä¸€æ¬¡åè½¬
    p0->next=pre;//åè½¬å®Œä¹‹åä»åŸé“¾è¡¨è§†è§’çœ‹ï¼ŒpreæŒ‡å‘å¾…åè½¬é“¾è¡¨çš„æœ€åä¸€ä¸ªç»“ç‚¹ï¼Œä¹Ÿå°±æ˜¯åè½¬åçš„ç¬¬ä¸€ä¸ªç»“ç‚¹
    return head;
}
```

### å¿«æ…¢æŒ‡é’ˆåº”ç”¨

#### é“¾è¡¨ä¸­é—´ç»“ç‚¹

```c++
Lnode* middlenode(Lnode *head){
  Lnode *fast,*slow;
    fast=slow=head->next;
    while(fast && fast->next){
        fast = fast ->next->next;
        slow = slow->next;
        
    }
    return slow;
}
```

#### åˆ é™¤é“¾è¡¨ä¸­é—´ç»“ç‚¹

```c++
Lnode * deletemiddle(Lnode *head){
    if(head->next)return nullptr;
    Lnode *fast=head->next,*slow=head->next,*pre=head->next;
    while(fast &&fast->next){
        pre=slow;
        slow=slow->next;
        fast=fast->next->next;
    }
    pre->next=slow->next;
    delete(slow);
    return head;
}
```

#### åˆ¤æ–­é“¾è¡¨ä¸­æ˜¯å¦å­˜åœ¨ç¯

```c++
//å•çº¯åˆ¤æ–­é“¾è¡¨ä¸­æ˜¯å¦å­˜åœ¨ç¯
bool hascycle(Lnode *head){
    Lnode *fast=head->next,*slow =head->next;
    while(fast && fast->next){
        fast=fast->next->next;
        slow =slow->next;
        if(fast==slow){
            return true;
        }
    }
    return false;
}
//è¿”å›å¼€å§‹è¿›å…¥ç¯çš„ç¬¬ä¸€ä¸ªç»“ç‚¹
Lnode *detectcycle(Lnode *head){
    Lnode *fast=head->next,*slow=head->next;
    while(fast && fast->next){
        fast=fast->next->next;
        slow=slow->next;
        if(fast==slow){
            Lnode *p=head->next;
            while(p!=slow){//å¦‚æœpæŒ‡é’ˆå’Œæ…¢æŒ‡é’ˆç›¸é‡ï¼Œè¯´æ˜æ¬¡æ•°äºŒè€…éƒ½åˆ°äº†ç¯çš„å…¥å£å¤„
                p=p->next;
                slow=slow->next;
            }
            return slow;
        }
    }
    return nullptr;
}
//æ±‚è§£ç¯çš„é•¿åº¦
int lengthcycle(Lnode *head){
    Lnode *fast=head->next,*slow=head->next;
    while(fast && fast->next){
        fast=fast->next->next;
        slow=slow->next;
        if(fast==slow){//ç¬¬ä¸€æ¬¡ç›¸é‡       
            slow=slow->next;
            int length =1;
            while(fast!=slow){
                slow=slow->next;
                length++;
            }
            return length;//ç¬¬äºŒæ¬¡ç›¸é‡ï¼Œè·³å‡ºå¾ªç¯
            
        }
    }
}
```

![](/img/857203b5-4aaa-4212-8e52-42ae6c159b09.png)

### é‡æ’é“¾è¡¨ï¼ˆå¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­é—´èŠ‚ç‚¹/åè½¬é“¾è¡¨/é“¾è¡¨çš„äº¤å‰è¿æ¥ï¼‰

```c++
Lnode* findmiddle(Lnode *&head){
    Lnode *fast=head->next;
    Lnode *slow=head->next;
    while(fast&&fast->next){
        fast=fast->next->next;
        slow=slow->next;
    }
    return slow;
}
Lnode* reverse(Lnode *&head){
    Lnode * pre=nullptr;
    Lnode * cur=head;
    while(cur){
        Lnode* next=cur->next;
        cur->next=pre;
        pre=cur;
        cur=next;
    }
    return pre;
}

void reverselist(Lnode *&head){
    Lnode* middle=findmiddle(head);
    Lnode* head2=reverse(middle);
    Lnode*head1=head->next;
    while(head2){
        Lnode*tmp1=head1->next;
        Lnode*tmp2=head2->next;
        head1->next=head2;
        head2->next=tmp1;
        head1=tmp1;
        head2=tmp2;
    }
}
```

### å›æ–‡é“¾è¡¨

```c++
lnode *findmiddle(lnode *head){
    lnode*fast=head->next;
    lnode*slow=head->next;
    while(fast &&fast->next){
        fast=fast->next->next;
        slow=slow->next;
    }
    return slow;
}//æ‰¾ä¸­é—´èŠ‚ç‚¹æ¨¡æ¿
lnode *reverselist(lnode *&head){
    lnode *pre=nullptr;
    lnode *cur=head;
    while(cur){
        lnode *next=cur->next;
        cur->next=pre;
        pre=cur;
        cur=next;
    }
    return pre;
}

bool isloop(lnode *head){
    lnode *mid=findmiddle(head);
    lnode *p=reverselist(mid);
    lnode*head1=head->next;
    while(p){
        if(p->data!=head1->data)
            return false;
        p=p->next;
        head1=head1->next;
    }
    return true;
}
```

### é“¾è¡¨æ’åº

```c++
lnode *sortlist(listnode *head){
    return mergesort(head);
}
lnode *mergesort(lnode *head){
    if(head==nullptr||head->next==nullptr)return head;
    lnode*fast=head,*slow=head;
    while(fast &&fast->next){
        fast=fast->next->next;
        slow=slow->next;
        pre=slow;
    }
    r=mergesort(slow);
    pre->next=nullptr;
    l=mergesort(head);
    return mergetwolist(l,r);
}
lnode*mergetwolist(lnode * list1,lnode* list2){
    lnode*dummy =new lnode(0,nullptr);
    lnode *p=list1,*q=list2,*cur=dummy;
    while(p&&q){
        if(p->val<q->val){
            cur->next=p;
            cur=cur->next;
            p=p->next;
        }
        else{
            cur->next=q;
            cur=cur->next;
            q=q->next;
        }
    }
    if(q==nullptr) cur->next=q;
    else{
        cur->next=q;
    }
    return dummy->next;
}
```

### åˆå¹¶å‡åºé“¾è¡¨

```c++
lnode *mergelist(lnode*list1,lnode*list2){
	if(list1->next==nullptr)return list2;
    if(list2->next==nullptr)return list1;
    lnode *l=new lnode(0,nullptr);//åˆ›å»ºä¸€ä¸ªæ–°é“¾è¡¨
    lnode *head1=list1->next;lnode*head2=list2->next;
    lnode*tail=l;
    while(head1&&head2){
        if(head1->data<head2->data){
            tail->next=head1;
            tail=head1;
            head1=head1->next;
        }
        else{
            tail->next=head2;
            tail=head2;
            head2=head2->next;
            
            
        }
    }
	tail->next=(head1==nullptr)? head2:head1;//è€³ç›®è¿ç®—ç¬¦ï¼Œå¦‚æœè·³å‡ºå¾ªç¯ålist1ä¸ºç©ºï¼Œå°†list2å‰©ä½™éƒ¨åˆ†æ¥åˆ°curåé¢ï¼Œå¦åˆ™æ¥å¦ä¸€æ¡çš„å‰©ä½™éƒ¨åˆ†ï¼›
    return L;
}
```

### è¡¨è¾¾å¼æ±‚å€¼

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unordered_map>
#include <stack>

using namespace std;

stack<char> op;
stack<int> num;

void eval()
{
    auto b = num.top(); num.pop();
    auto a = num.top(); num.pop();
    auto c = op.top(); op.pop();

    int x;
    if (c == '+') x = a + b;
    else if (c == '-') x = a - b;
    else if (c == '*') x = a * b;
    else x = a / b;
    num.push(x);
}

int main()
{
    string s;
    cin >> s;

    unordered_map<char, int> pr{{'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}};
    for (int i = 0; i < s.size(); i ++ )
    {
        if (isdigit(s[i]))
        {
            int j = i, x = 0;
            while (j < s.size() && isdigit(s[j]))
                x = x * 10 + s[j ++ ] - '0';//æŠŠè¿ç»­çš„æ•°å­—å­—ç¬¦è½¬æˆæ•´æ•°
            num.push(x);
            i = j - 1;
        }
        else if (s[i] == '(') op.push(s[i]);
        else if (s[i] == ')')
        {
            while (op.top() != '(') eval();
            op.pop();
        }
        else
        {
            while (op.size() && op.top() != '(' && pr[op.top()] >= pr[s[i]])
                eval();
            op.push(s[i]);
        }
    }

    while (op.size()) eval();
    cout << num.top() << endl;

    return 0;
}

```

### ä¸­ç¼€è¡¨è¾¾å¼è½¬åç¼€è¡¨è¾¾å¼

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unordered_map>
#include <stack>

using namespace std;

stack<char> op;

void eval()
{
    auto c = op.top(); op.pop();
    cout << c << ' ';
}

int main()
{
    string s;
    cin >> s;

    unordered_map<char, int> pr{{'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}};
    for (int i = 0; i < s.size(); i ++ )
    {
        if (isdigit(s[i]))
        {
            int j = i, x = 0;
            while (j < s.size() && isdigit(s[j]))
                x = x * 10 + s[j ++ ] - '0';
            cout << x << ' ';
            i = j - 1;
        }
        else if (s[i] == '(') op.push(s[i]);
        else if (s[i] == ')')
        {
            while (op.top() != '(') eval();
            op.pop();
        }
        else
        {
            while (op.size() && op.top() != '(' && pr[op.top()] >= pr[s[i]])
                eval();
            op.push(s[i]);
        }
    }

    while (op.size()) eval();

    return 0;
}
```

### è¡¨è¾¾å¼æ ‘

```c++
//O(nÂ²)
//
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     string valï¼›
 *     TreeNode *left;
 *     TreeNode *right;
 * };
 */
class Solution {
public:
    string dfs(TreeNode* root) {
        if (!root) return "";
        if (!root->left && !root->right) return root->val;
        return '(' + dfs(root->left) + root->val + dfs(root->right) + ')';
    }

    string expressionTree(TreeNode* root) {
        return dfs(root->left) + root->val + dfs(root->right);
    }
};

//O(n)
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     string valï¼›
 *     TreeNode *left;
 *     TreeNode *right;
 * };
 */
class Solution {
public:
    string ans;

    void dfs(TreeNode* root) {
        if (!root) return;
        if (!root->left && !root->right) ans += root->val;
        else
        {
            ans += '(';
            dfs(root->left);
            ans += root->val;
            dfs(root->right);
            ans += ')';
        }
    }

    string expressionTree(TreeNode* root) {
        dfs(root->left), ans += root->val, dfs(root->right);
        return ans;
    }
};
```

### å“ˆå¤«æ›¼æ ‘

```c++
//O(nlogn)
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

int main()
{
    int n;
    scanf("%d", &n);

    priority_queue<int, vector<int>, greater<int>> heap;
    while (n -- )
    {
        int x;
        scanf("%d", &x);
        heap.push(x);
    }

    int res = 0;
    while (heap.size() > 1)
    {
        int a = heap.top(); heap.pop();
        int b = heap.top(); heap.pop();
        res += a + b;
        heap.push(a + b);
    }

    printf("%d\n", res);
    return 0;
}

```



## å®šä¹‰å’ŒåŸºæœ¬æ“ä½œæ¨¡æ¿

### å•é“¾è¡¨

#### å•é“¾è¡¨ç»“ç‚¹çš„å®šä¹‰

```c++
struct Lnode{
    int data;
    Lnode *next;
};
```

#### å•é“¾è¡¨çš„åˆå§‹åŒ–

```c++
//æœ‰å¤´ç»“ç‚¹çš„å•é“¾è¡¨çš„åˆå§‹åŒ–
Lnode init(){
    Lnode *head = new Lnode;
    head->next=nullptr;
    head->data=0;
    return head;
}
//æ— å¤´ç»“ç‚¹çš„å•é“¾è¡¨çš„åˆå§‹åŒ–
Lnode init(){
    Lnode *head =nullptr;
    return head;
}
```

#### å•é“¾è¡¨æ±‚è¡¨é•¿ï¼ˆä¸å«å¤´ç»“ç‚¹ï¼‰

```c++
int listlength(Lnode *l){
    Lnode p = l->next;//æŒ‡å‘ç¬¬ä¸€ä¸ªç»“ç‚¹
    int length = 0;
    while(p!=nullptr){
        ++length;
        p=p->next;
    }
    return length;
}//æ—¶é—´å¤æ‚åº¦O(n)
```

#### å•é“¾è¡¨çš„æŒ‰ä½æŸ¥æ‰¾

```c++
Lnode* getElem(Lnode *L,int i){
    Lnode p = L->next;
    if(i==0)return L;
    else if(i<0)return nullptr;
    else{
        while(p!=nullptr &&i!=0){
            p=p->next;
            i--;
        }
        return p;
    }
}
```

#### å•é“¾è¡¨çš„æŒ‰å€¼æŸ¥æ‰¾

```c++
Lnode * locateElem(Lnode *l,int target){
    Lnode p=l->next;
    while(p!=nullptr &&p->data !=target)
        p=p->next;
    return p;
}
```

#### å¤´æ’æ³•å»ºç«‹å•é“¾è¡¨

```c++
Lnode *list_head_insert(Lnode *&l){
    Lnode *newnode;
    int x;
    L = new Lnode;
    L->next=nullptr;
    cin>>x;
    while(x!=-1){
        newnode = new Lnode;
        newnode ->data=x;
        newnode->next=l->next;
        l->next=newnode;
    }
    return L;
}//æ—¶é—´å¤æ‚åº¦O(n)
```

#### å°¾æ’æ³•å»ºç«‹å•é“¾è¡¨

```c++
Lnode * list_tail_insert(Lnode *&L){
    Lnode *newnode,tail=L;
    int x;
    L =new Lnode;
    L->next=nullptr;
    cin >>x;
    while(x!=1){
        newnode = new Lnode;
        newnode ->data=x;
        newnode ->next=nullptr;
        tail->next=newnode;
        tail=tail->next;
    }
    return L;
}//æ—¶é—´å¤æ‚åº¦ä¸ºO(n)
```

#### æ’å…¥èŠ‚ç‚¹æ“ä½œ

```c++
bool insertnode(Lnode *&L){
    Lnode *newnode,*prenode,*curnode;
    int x;
    if(i<=0)return false;
    prenode =getElem(L,i-1);
    if(prenode ==nullptr)return false;
    curnode =prenode->next;
    newnode =new Lnode;
    newnode->data=x;
    newnode ->next=curnode;
    prenode->next=newnode;
    return true;
}//æ—¶é—´å¤æ‚åº¦O(n)
```

#### åˆ é™¤èŠ‚ç‚¹æ“ä½œ

```c++
void deletenode(Lnode *p){
	p->data=p->next->data;
    Lnode *q=p->next;
    p->next=q->next;
    delete q;
}
```

### åŒé“¾è¡¨

#### åŒé“¾è¡¨çš„æ•°æ®ç»“æ„å®šä¹‰

```c++
struct dnode{
    int data;
    dnode *pre,*next;
    
};

```

#### åŒé“¾è¡¨çš„æ’å…¥

```c++
q->next=p->next;
p->next->pre=q;
p->next=q;
q->pre=p;
```

#### åŒå‘é“¾è¡¨çš„åˆ é™¤æ“ä½œ

```c++
p->next=q->next;
q->next->pre=p;
delete q;
```

### å¾ªç¯å•é“¾è¡¨

#### å¾ªç¯å•é“¾è¡¨çš„åˆå§‹åŒ–

```c++
bool init(Lnode *&head){
    head= new Lnode;
    if(L==nullptr)
        return false;
    head->next=head;
    return true;
}
```

### å¾ªç¯åŒé“¾è¡¨

#### å¾ªç¯åŒé“¾è¡¨åˆå§‹åŒ–

```c++
bool init(dnode *&head){
    head = new dnode;
    if(l==nullptr)
        return false;
    head->pre=head;
    head->next=head;
    return true;
}
```

### é™æ€é“¾è¡¨

#### é™æ€é“¾è¡¨çš„å®šä¹‰

```c++
#define maxsize 50
struct slinklist{
    int data;
    int next;
}list[maxsize];
```

### äºŒå‰æ ‘

#### äºŒå‰æ ‘çš„é¡ºåºå­˜å‚¨

```c++
//å®šä¹‰ä¸åˆå§‹åŒ–
struct treenode{
    int data;
    bool isempty;
};
//åˆå§‹åŒ–é¡ºåºå­˜å‚¨çš„äºŒå‰æ ‘ï¼Œæ‰€æœ‰èŠ‚ç‚¹æ ‡è®°ä¸ºç©º
void init(treenode t[],int length){
    for(int i = 0;i<length;i++)
        t[i].isempty=true;
    
}
int main(){
    treenode t[100];
    init(t,100);
}
//åˆ¤ç©º
bool isempty(treenode t[],int length,int index){
    if(index>=length ||index <1)return true;
    return t[index].isempty;
}
//æ‰¾å·¦å­©å­
int getlkid(treenode t[],int lenght,int index){
    int lkid=index*2;
    if(isempty(t,length,lkid))return -1;
    return lkid;
}
//æ‰¾å³å­©å­
int getrkid(treenode t[],int lenght,int index){
    int rkid=index*2+1;
    if(isempty(t,length,rkid))return -1;
    return rkid;
}
//æ‰¾åŒäº²
int getparent(treenode t[],int lenght,int index){
    if(index==1)return -1
    int parent=index/2;
    if(isempty(t,length,parent))return -1;
    return parent;
}
//å…ˆåºéå†
void pre(treenode *t,int length,int index){
    if(isempty(t,length,index))
        return;
    visit(t[index]);
    pre(t,length,getlkid(t,length,index));
    pre(t,length,getrkid(t,length,index));
}
//ä¸­åºéå†
void mid(treenode *t,int length,int index){
    if(isempty(t,length,index))
        return;
    mid(t,length,getlkid(t,length,index));
    
    visit(t[index]);
   
    mid(t,length,getrkid(t,length,index));
}
//ååºéå†
void post(treenode *t,int length,int index){
    if(isempty(t,length,index))
        return;
    post(t,length,getlkid(t,length,index));
    post(t,length,getrkid(t,length,index));
    visit(t[index]);
   
    
}
```

#### äºŒå‰æ ‘çš„é“¾å¼å­˜å‚¨

```c++
struct treenode{
    int data;
    treenode *lkid,*rkid;
};
//å®šä¹‰ä¸€é¢—ç©ºæ ‘
treenode * root =nullptr;
//æ’å…¥æ ¹èŠ‚ç‚¹
root= new treenode;
root->data=1;
root->lkid=nullptr;
root->rkid=nullptr;

//æ’å…¥æ–°èŠ‚ç‚¹
treenode *p=new treenode(2);
p->lkid=nullptr;
p->rkid=nullptr;
root->lkid=p;
```

#### è¿­ä»£æ³•å…ˆåºéå†

```c++
vector<int> pre(treenode* root){
    stack<treenode*> st;
    vector<int>result;//ç”¨äºè¿”å›éå†åºåˆ—
    if(root=nullptr)return result;
    st.push(root);
    while(!st.empty()){
        treenode *node=st.top();//ä¸­
            st.pop();//å–å‡ºæ ¹èŠ‚ç‚¹ç„¶åå¼¹å‡º
        result.push_back(node->val);//è®¿é—®å¹¶å¤„ç†å½“å‰èŠ‚ç‚¹ï¼Œæœ¬å±‚é€’å½’å¤„ç†ï¼Œå°†ç»“ç‚¹åŠ å…¥å…ˆåºåºåˆ—
        if(node->right)st.push(node->right);//å³å­©å­å…¥æ ˆï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰ï¼Œåé€’å½’å¤„ç†å³å­æ ‘
        if(node->left)st.push(node->left);//å·¦å­©å­å…¥æ ˆï¼Œå…ˆé€’å½’å¤„ç†å·¦å­æ ‘ï¼ˆæ ˆçš„ç‰¹æ€§æ˜¯åè¿›å…ˆå‡ºï¼‰
        
    }
    return result;
}
```

#### è¿­ä»£æ³•ä¸­åºéå†

```c++
vector<int> inorder(treenode *root){
    vector<int>result;//å®šä¹‰ä¸€ä¸ªç»“æœæ•°ç»„ç”¨äºå­˜æ”¾ä¸­åºéå†åºåˆ—
    stack<treenode*>st;
    treenode* cur=root;//curä¸ºéå†æŒ‡é’ˆ
	while(cur!=nullptr ||!st.empty()){//éå†æŒ‡é’ˆä¸ä¸º0ä¸”æ ˆä¸ä¸ºç©º
        if(cur!=nullptr){//æŒ‡é’ˆæ¥è®¿é—®èŠ‚ç‚¹ï¼Œè®¿é—®åˆ°æœ€åº•å±‚
            st.push(cur);//å°†è®¿é—®çš„ç»“ç‚¹æ”¾è¿›æ ˆ
            cur=cur->left;//å·¦
        }
        else{//å½“å‰ç»“ç‚¹ä¸ºç©ºï¼Œè¯´æ˜ä¸Šä¸€ä¸ªç»“ç‚¹æ²¡æœ‰å·¦å­æ ‘
            cur=st.top();//æ­¤æ—¶æ ˆé‡Œé¢ä¿å­˜ç€ä»è·Ÿæ ¹èŠ‚ç‚¹æ²¿ç€å·¦å­æ ‘ä¸€ç›´èµ°çš„ç»“ç‚¹ï¼Œä»æ ˆé‡Œé¢å¼¹å‡ºçš„æ•°æ®ï¼Œå°±æ˜¯æœ€å·¦çš„ç»“ç‚¹ï¼Œå³è¦å¤„ç†çš„æ•°æ®ï¼ˆæ”¾è¿›resultæ•°ç»„é‡Œçš„æ•°æ®ï¼‰
            st.pop();
            result.push_back(cur->val);//å¾€ä¸­åºéå†åºåˆ—ä¸­åŠ å…¥æ ˆé¡¶å…ƒç´ ã€‚æ­¤æ—¶ç”±äºæ ˆé¡¶ä¸ºæ²¡æœ‰å·¦å­æ ‘çš„æœ€å·¦ç»“ç‚¹ï¼Œå¼¹å‡ºåcur=cur->rightä¸å­˜åœ¨ï¼Œç¬¬äºŒæ¬¡å¼¹å‡ºçš„æ˜¯æ ¹èŠ‚ç‚¹ï¼Œå…¶å®å°±ç›¸å½“äºä¸­ç»“ç‚¹
            cur=cur->right;//å·¦ä¸­éå†å®Œï¼Œéå†å³
        }
        
    }
    return result;
}
```

#### è¿­ä»£æ³•ååºéå†

```c++
vector<int> postorder(treenode *root){
    stack<treenode*>st;
    vector<int> result;
    if(root=nullptr)return result;
    st.push(root);
    while(!st.empty()){
        treenode *node=st.top();
        st.pop();
        result.push_back(node->val);
        if(node->left)st.push(node->left);//ç›¸å¯¹äºå‰åºéå†ï¼Œå·¦å³å­æ ‘éå†é¡ºåºäº’æ¢ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
        if(node->right)st.push(node->right);//ç©ºèŠ‚ç‚¹ä¸å…¥æ ˆ
    }
    reverse(result.begin(),reguslt.end());//å°†ç»“æœåè½¬ä¹‹åå°±æ˜¯å·¦å³ä¸­çš„é¡ºåºäº†
    return result;
}
```

#### äºŒå‰æ ‘çš„å±‚åºéå†

```c++
vector<int> levelorder(treenode *root){
    vector<int>res;
    queue<treenode*>que;
    if(root==nullptr)return res;
    que.push(root);//å°†æ ¹èŠ‚ç‚¹å…¥é˜Ÿ
    while(!que.empty()){//é˜Ÿåˆ—éç©º
        treenode *cur=que.front();//å–å‡ºé˜Ÿå¤´
        que.pop();
        res.push_back(cur->val);
        if(cur->left!=nullptr)que.push(cur->left);
        if(cur->right!=nullptr)que.push(cur->right);
    }
    return res;
}
```



#### é‡å»ºäºŒå‰æ ‘

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:

    unordered_map<int,int> pos;

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        for (int i = 0; i < n; i ++ )
            pos[inorder[i]] = i;
        return dfs(preorder, inorder, 0, n - 1, 0, n - 1);
    }

    TreeNode* dfs(vector<int>&pre, vector<int>&in, int pl, int pr, int il, int ir)
    {
        if (pl > pr) return NULL;
        int k = pos[pre[pl]] - il;
        TreeNode* root = new TreeNode(pre[pl]);
        root->left = dfs(pre, in, pl + 1, pl + k, il, il + k - 1);
        root->right = dfs(pre, in, pl + k + 1, pr, il + k + 1, ir);
        return root;
    }
};//ä¸Šæœºé¢˜
```

#### äºŒå‰æ’åºæ ‘

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int INF = 1e8;

struct TreeNode
{
    int val;
    TreeNode *left, *right;
    TreeNode(int _val): val(_val), left(NULL), right(NULL) {}
}*root;

void insert(TreeNode* &root, int x)
{
    if (!root) root = new TreeNode(x);
    else if (x < root->val) insert(root->left, x);
    else insert(root->right, x);
}

void remove(TreeNode* &root, int x)
{
    if (!root) return;
    if (x < root->val) remove(root->left, x);
    else if (x > root->val) remove(root->right, x);
    else
    {
        if (!root->left && !root->right) root = NULL;
        else if (!root->left) root = root->right;
        else if (!root->right) root = root->left;
        else
        {
            auto p = root->left;
            while (p->right) p = p->right;
            root->val = p->val;
            remove(root->left, p->val);
        }
    }
}

int get_pre(TreeNode* root, int x)
{
    if (!root) return -INF;
    if (root->val >= x) return get_pre(root->left, x);
    return max(root->val, get_pre(root->right, x));
}

int get_suc(TreeNode* root, int x)
{
    if (!root) return INF;
    if (root->val <= x) return get_suc(root->right, x);
    return min(root->val, get_suc(root->left, x));
}

int main()
{
    int n;
    cin >> n;
    while (n -- )
    {
        int t, x;
        cin >> t >> x;
        if (t == 1) insert(root, x);
        else if (t == 2) remove(root, x);
        else if (t == 3) cout << get_pre(root, x) << endl;
        else cout << get_suc(root, x) << endl;
    }

    return 0;
}

```

#### çº¿ç´¢äºŒå‰æ ‘çš„ç»“æ„ä½“å®šä¹‰

```c++
struct threadnode{
    int data;
    struct threadnode*lkid,*rkid;
    int ltag,rtag;
};
```

#### ä¸­åºçº¿ç´¢äºŒå‰æ ‘çš„æ„é€ 

```c++
void inthread(threadnode*p,threadnode*pre){
    if(p!=nullptr){
        inthread(p->lkid,pre);//é€’å½’çº¿ç´¢åŒ–å·¦å­æ ‘
        if(p->lkid==nullptr){//å¦‚æœpæ²¡æœ‰å·¦å­©å­ï¼Œå³å·¦å­©å­æŒ‡é’ˆä¸ºç©ºï¼Œå»ºç«‹å‰é©±çº¿ç´¢
            p->lkid=pre;//å°†å…¶æŒ‡å‘å‰é©±èŠ‚ç‚¹
            p->ltag=1;
            
        }
        else{
            p->ltag=0;
        }
        if(pre!=nullptr&&pre->rkid=nullptr){//å¦‚æœpreæ²¡æœ‰å³å­©å­ï¼Œå³å³å­©å­æŒ‡å‘ç©º
        	pre->rkid=p;//å°†å…¶å³å­©å­æŒ‡é’ˆæŒ‡å‘p;
            pre->rtag=1;//ä¿®æ”¹æ ‡è¯†;
        }
        else{
            pre->rtag=0;
        }
        pre=p;//å·¦å³å¤„ç†å®Œæ¯•ï¼Œæ›´æ–°éå†ç»“ç‚¹ï¼›è¡¨ç¤ºå½“å‰èŠ‚ç‚¹æˆä¸ºåˆšåˆšè®¿é—®è¿‡çš„ç»“ç‚¹
        inthread(p->rkid,pre);//é€’å½’çº¿ç´¢åŒ–å³å­æ ‘
    }
}
void creatinthread(treadtree* root){
    threadnode *pre = nullptr;
    if(root){//éç©ºäºŒå‰æ ‘çº¿ç´¢åŒ–;
        inthread(root,pre);//çº¿ç´¢åŒ–äºŒå‰æ ‘
        pre->rkid=nullptr;//å¤„ç†éå†çš„æœ€åä¸€ä¸ªç»“ç‚¹ï¼Œå°†å…¶åç»§æŒ‡å‘ç©º;
        pre->rtag=1;
    }
}
```

#### ä¸­åºçº¿ç´¢äºŒå‰æ ‘æ‰¾åç»§/å‰é©±/éå†

```c++
//æ‰¾åˆ°ä»¥pä¸ºæ ¹çš„å­æ ‘ä¸­ï¼Œç¬¬ä¸€ä¸ªè¢«ä¸­åºéå†è®¿é—®åˆ°çš„ç»“ç‚¹;
threadnode *firstnode(threadnode *p){
    //å¾ªç¯æ‰¾åˆ°æœ€å·¦ä¸‹ç»“ç‚¹ï¼ˆä¸ä¸€å®šæ˜¯å¶èŠ‚ç‚¹ï¼‰
    while(p->ltag==0){
        p=p->lkid;
    }
    return p;
}
//åœ¨ä¸­åºçº¿ç´¢äºŒå‰æ ‘ä¸­æ‰¾åˆ°ç»“ç‚¹pçš„åç»§èŠ‚ç‚¹
threadnode *nextnode(threadnode *p){
    if(p->rtag==0){//ä»£è¡¨æœ‰å³å­©å­
        return firstnode(p->rkid);//åç»§ä¸ºå³å­æ ‘çš„æœ€å·¦ä¸‹ç»“ç‚¹      
    }
    else{//rtag=1è¡¨ç¤ºpç»“ç‚¹æ²¡æœ‰å³å­©å­ï¼Œåˆ™å…¶å³å­©å­æŒ‡é’ˆæŒ‡å‘å…¶åç»§
        return p->rkid;//ç›´æ¥è¿”å›åç»§ç»“ç‚¹
    }
}
//å¯¹ä¸­åºçº¿ç´¢äºŒå‰æ ‘è¿›è¡Œä¸­åºéå†ï¼ˆåˆ©ç”¨çº¿ç´¢åŒ–å®ç°çš„éé€’å½’ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºO(1)
void inorder(threadnode *root){
    for(threadnode *p=firstnode(root);p!=null;p=nextnode(p))
        visit(p);
}
//åœ¨ä¸­åºçº¿ç´¢äºŒå‰æ ‘é‡Œé¢æ‰¾ç»“ç‚¹pçš„å‰é©±
//æ‰¾åˆ°ä»¥pä¸ºæ ¹çš„å­æ ‘ä¸­ï¼Œæœ€åä¸€ä¸ªè¢«ä¸­åºéå†è®¿é—®åˆ°çš„ç»“ç‚¹ï¼›
treadnode*lastnode(thread*p){
    //å¾ªç¯æ‰¾åˆ°æœ€å³ä¸‹ç»“ç‚¹ï¼ˆä¸ä¸€å®šæ˜¯å¶èŠ‚ç‚¹ï¼‰
    while(p->rtag==0){
        p=p->rkid;
    }
    return p;
}
//åœ¨ä¸­åºçº¿ç´¢äºŒå‰æ ‘ä¸­æ‰¾åˆ°ç»“ç‚¹pçš„å‰é©±èŠ‚ç‚¹ï¼›
threadnode *prenode(threadnode *p){
    if(p->ltag==0){//è¡¨ç¤ºpç»“ç‚¹æœ‰å·¦å­©å­
    	p=p->rkid;
    }
    return p;
}
//åœ¨ä¸­åºçº¿ç´¢äºŒå‰æ ‘ä¸­æ‰¾åˆ°ç»“ç‚¹pçš„å‰é©±èŠ‚ç‚¹
threadnode *prenode(threadnode *p){
    if(p->ltag==0){//è¡¨ç¤ºpç»“ç‚¹æœ‰å·¦å­©å­
        return lastnode(p->lkid);//åˆ™å…¶å‰é©±ä¸ºå·¦å­æ ‘çš„æœ€å³ä¸‹ç»“ç‚¹; 
    }
    else{
        return p->lkid;
    }
}
void revorder(threadnode *root){
    for(threadnode *p = lastnode(root);p!=nullptr;p=prenode(p))
        visit(p);
}
```

#### å…ˆåºçº¿ç´¢åŒ–

```c++
// å‰åºçº¿ç´¢åŒ–
void PreThread(ThreadNode* p, ThreadNode* pre) {
    if (p != NULL) {
        if (p->lchild == NULL) {  // å¦‚æœpæ²¡æœ‰å·¦å­©å­ï¼Œå»ºç«‹å‰é©±çº¿ç´¢
            p->lchild = pre;
            p->ltag = 1; // ä¿®æ”¹æ ‡è¯†ï¼Œè¡¨ç¤ºçº¿ç´¢åŒ–
        } else {
            p->ltag = 0;
        }

        if (pre != NULL && pre->rchild == NULL) {  // å¦‚æœpreæ²¡æœ‰å³å­©å­ï¼Œåˆ™å»ºç«‹å‰é©±ç»“ç‚¹çš„åç»§çº¿ç´¢
            pre->rchild = p;
            pre->rtag = 1;  // ä¿®æ”¹æ ‡è¯†
        } else {
            pre->rtag = 0;
        }

        pre = p;  // æ›´æ–°éå†ç»“ç‚¹ï¼Œè¡¨ç¤ºå½“å‰ç»“ç‚¹æˆä¸ºåˆšåˆšè®¿é—®è¿‡çš„ç»“ç‚¹

        if (p->ltag == 0)  // é¿å…çº¿ç´¢åŒ–å·¦å­æ ‘
            PreThread(p->lchild, pre);
        if (p->rtag == 0)  // å¿…é¡»åˆ¤æ–­åå†é€’å½’ï¼Œå¦åˆ™ä¼šé™·å…¥æ­»å¾ªç¯
            PreThread(p->rchild, pre);  // é¿å…çº¿ç´¢åŒ–å³å­æ ‘
    }
}

void CreatePreThread(ThreadTree root) {
    ThreadNode* pre = NULL;
    if (root) {
        PreThread(root, pre);  // çº¿ç´¢åŒ–äºŒå‰æ ‘
        if (pre->rchild == NULL)  // å¤„ç†éå†çš„æœ€åä¸€ä¸ªç»“ç‚¹
            pre->rtag = 1;
    }
}

```

#### ååºçº¿ç´¢åŒ–

```c++
// ååºçº¿ç´¢åŒ–
void PostThread(ThreadNode* p, ThreadNode* pre) {
    if (p != NULL) {
        PostThread(p->lchild, pre);  // é¿å…çº¿ç´¢åŒ–å·¦å­æ ‘
        PostThread(p->rchild, pre);  // é¿å…çº¿ç´¢åŒ–å³å­æ ‘

        if (p->lchild == NULL) {  // å¦‚æœpæ²¡æœ‰å·¦å­©å­ï¼Œå»ºç«‹å‰é©±çº¿ç´¢
            p->lchild = pre;
            p->ltag = 1;  // ä¿®æ”¹æ ‡è¯†ï¼Œè¡¨ç¤ºçº¿ç´¢åŒ–
        } else {
            p->ltag = 0;
        }

        if (pre != NULL && pre->rchild == NULL) {  // å¦‚æœpreæ²¡æœ‰å³å­©å­ï¼Œåˆ™å»ºç«‹å‰é©±ç»“ç‚¹çš„åç»§çº¿ç´¢
            pre->rchild = p;
            pre->rtag = 1;  // ä¿®æ”¹æ ‡è¯†
        } else {
            pre->rtag = 0;
        }

        pre = p;  // æ›´æ–°éå†ç»“ç‚¹ï¼Œè¡¨ç¤ºå½“å‰ç»“ç‚¹æˆä¸ºåˆšåˆšè®¿é—®è¿‡çš„ç»“ç‚¹
    }
}

void CreatePostThread(ThreadTree root) {
    ThreadNode* pre = NULL;
    if (root) {
        PostThread(root, pre);  // çº¿ç´¢åŒ–äºŒå‰æ ‘
        if (pre->rchild == NULL)  // å¤„ç†éå†çš„æœ€åä¸€ä¸ªç»“ç‚¹
            pre->rtag = 1;
    }
}

```

#### äºŒå‰æ ‘çš„å¸¦æƒè·¯å¾„é•¿åº¦

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int dfs(TreeNode* root, int depth) {
        if (!root) return 0;
        if (!root->left && !root->right) return root->val * depth;
        return dfs(root->left, depth + 1) + dfs(root->right, depth + 1);
    }

    int pathSum(TreeNode* root) {
        return dfs(root, 0);
    }
};

ä½œè€…ï¼šyxc
é“¾æ¥ï¼šhttps://www.acwing.com/activity/content/code/content/1466511/
æ¥æºï¼šAcWing
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```



### æ ‘ä¸æ£®æ—çš„å­˜å‚¨

#### åŒäº²è¡¨ç¤ºæ³•

```c++
#define maxsize 100

struct ptnode {
    int data;
    int parent;
};

struct ptree {
    ptnode nodes[maxsize];
    int n;
};

```

#### å­©å­è¡¨ç¤ºæ³•

```c++
struct kid{
    int index;//å­©å­ç»“ç‚¹
    kid*next;//ä¸‹ä¸€ä¸ªå­©å­ï¼›
};

struct treenode
{
    int data;//èŠ‚ç‚¹ä¿¡æ¯
    kid *firstkid;//æŒ‡å‘ç¬¬ä¸€ä¸ªå­©å­
};

treenode tree[10];

```

#### å­©å­å…„å¼Ÿè¡¨ç¤ºæ³•

```c++
struct csnode{
    int data;
    csnode*firstchild ,*rightbro;
};
```

### å¹¶æŸ¥é›†

* æœ´ç´ ç‰ˆ

```c++
#define size 13
int s[size];
//åˆå§‹åŒ–å¹¶æŸ¥é›†
void init(int s[]){
    for(int i = 0;i<size;i++){
        s[i]=-1;
    }
}
//æŸ¥æ“ä½œï¼Œæ‰¾xæ‰€å±é›†åˆï¼ˆè¿”å›xæ‰€å±æ ‘çš„æ ¹èŠ‚ç‚¹ï¼‰
int find(int s[],int x){//xæ˜¯è¯¥å…ƒç´ åœ¨æ•°ç»„ä¸­å­˜å‚¨çš„å€¼ï¼Œå³å…¶çˆ¶èŠ‚ç‚¹çš„æ•°ç»„ä¸‹æ ‡
    while(s[x]>=0){//åªè¦æ•°ç»„ä¸­è¯¥å…ƒç´ å€¼>0ï¼Œè¯´æ˜è¿˜æœªæ‰¾åˆ°å…¶æ‰€å±é›†åˆæ ¹èŠ‚ç‚¹ï¼Œç»§ç»­å¾ªç¯å¯»æ‰¾
        x=s[x];    
    }    
    return x;//æ‰¾åˆ°æ‰€å±é›†åˆæ ¹èŠ‚ç‚¹ï¼Œæ­¤æ—¶xå€¼ä¸ºæ ¹èŠ‚ç‚¹ä¸‹æ ‡
}
//å¹¶æ“ä½œ
void Union(int s[],int root1,int root2){
    if(root1==root2)
        return;//è¦æ±‚æ˜¯ä¸åŒé›†åˆæ‰åˆå¹¶
    s[root2]=root1;//å°†æ ¹rootä½œä¸ºæ ¹root1çš„è‡ªä¸»ï¼Œå³åˆå¹¶
}
```



* è·¯å¾„å‹ç¼©ç‰ˆ

```c++
(1)æœ´ç´ å¹¶æŸ¥é›†ï¼ˆè·¯å¾„å‹ç¼©ç‰ˆï¼‰ï¼š

    int p[N]; //å­˜å‚¨æ¯ä¸ªç‚¹çš„ç¥–å®—èŠ‚ç‚¹

    // è¿”å›xçš„ç¥–å®—èŠ‚ç‚¹ï¼Œå³æ‰€åœ¨é›†åˆçš„ç¼–å·ï¼Œé¡ºä¾¿åŠ ä¸Šè·¯å¾„ä¼˜åŒ–
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);//å½“ä¸æ˜¯ç¥–å®—èŠ‚ç‚¹çš„æ—¶å€™ï¼Œå¯»æ‰¾çˆ¶èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œé€’å½’ä¹‹åæ‰¾åˆ°ç¥–å®—èŠ‚ç‚¹å¹¶å°†è·¯å¾„ä¼˜åŒ–
        return p[x];//è¿”å›ç¥–å®—èŠ‚ç‚¹
    }

    // åˆå§‹åŒ–ï¼Œå‡å®šèŠ‚ç‚¹ç¼–å·æ˜¯1~n
    for (int i = 1; i <= n; i ++ ) p[i] = i;

    // åˆå¹¶aå’Œbæ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆï¼š
    p[find(a)] = find(b);//è®©açš„ç¥–å®—èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ç­‰äºbçš„ç¥–å®—èŠ‚ç‚¹ï¼Œå³å°†aæ’å…¥bä¸­

    //åˆ¤æ–­aå’Œbæ˜¯ä¸æ˜¯åœ¨åŒä¸€ä¸ªé›†åˆä¸­
      if(find(a)==find(b)) puts("yes");
		else puts("no"); 

(2)ç»´æŠ¤sizeçš„å¹¶æŸ¥é›†ï¼š

    int p[N], size[N];
    //p[]å­˜å‚¨æ¯ä¸ªç‚¹çš„ç¥–å®—èŠ‚ç‚¹, size[]åªæœ‰ç¥–å®—èŠ‚ç‚¹çš„æœ‰æ„ä¹‰ï¼Œè¡¨ç¤ºç¥–å®—èŠ‚ç‚¹æ‰€åœ¨é›†åˆä¸­çš„ç‚¹çš„æ•°é‡ï¼Œåªä¿è¯æ ¹èŠ‚ç‚¹çš„sizeæœ‰æ„ä¹‰

    // è¿”å›xçš„ç¥–å®—èŠ‚ç‚¹
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // åˆå§‹åŒ–ï¼Œå‡å®šèŠ‚ç‚¹ç¼–å·æ˜¯1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }

    // åˆå¹¶aå’Œbæ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆï¼š
      if(find(a)==find(b))continue;//aå’Œbåœ¨ä¸€ä¸ªé›†åˆå½“ä¸­
    size[find(b)] += size[find(a)];//æŠŠaé›†åˆä¸­ç‚¹çš„ä¸ªæ•°åŠ åˆ°bé›†åˆä¸­
    p[find(a)] = find(b);//å°†aæ’å…¥b
    //æ‰¾åˆ°æŸç‚¹æ‰€åœ¨çš„é›†åˆçš„ç‚¹çš„ä¸ªæ•°
      cout<<size[find(a)];

(3)ç»´æŠ¤åˆ°ç¥–å®—èŠ‚ç‚¹è·ç¦»çš„å¹¶æŸ¥é›†ï¼š

    int p[N], d[N];
    //p[]å­˜å‚¨æ¯ä¸ªç‚¹çš„ç¥–å®—èŠ‚ç‚¹, d[x]å­˜å‚¨xåˆ°p[x]çš„è·ç¦»

    // è¿”å›xçš„ç¥–å®—èŠ‚ç‚¹
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }

    // åˆå§‹åŒ–ï¼Œå‡å®šèŠ‚ç‚¹ç¼–å·æ˜¯1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        d[i] = 0;
    }

    // åˆå¹¶aå’Œbæ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆï¼š
    p[find(a)] = find(b);
    d[find(a)] = distance; // æ ¹æ®å…·ä½“é—®é¢˜ï¼Œåˆå§‹åŒ–find(a)çš„åç§»é‡

```



### å›¾

#### å›¾çš„é‚»æ¥çŸ©é˜µå­˜å‚¨ç»“æ„

```c++
#define MAX 100
struct mgraph
{
    int numvertex;//å›¾ä¸­å®é™…çš„é¡¶ç‚¹æ•°
    int numedges;//å›¾ä¸­å®é™…çš„è¾¹æ•°
    char vertexlist[MAX];//é¡¶ç‚¹è¡¨
    int edges[MAX][MAX];
};
//è®¡ç®—æŸä¸ªé¡¶ç‚¹çš„å…¥åº¦
int indegree(mgraph graph,char v){
    int index=-1;
    int count=0;
    //æŸ¥æ‰¾é¡¶ç‚¹våœ¨å®šç‚¹è¡¨ä¸­çš„ç´¢å¼•
    for(int i = 0;i<graph.numvertex;i++){
        if(graph.vertexlist[i]==v){
            index=i;
            break;
        }
    }
    if(index==-1){
        return -1;

    }
    for (int i = 0; i < graph.numvertex; i++)
    {
        if (graph.edges[i][index]!=0)
        {
            count++;
        }
        
    }
    return count;
    

}
//è®¡ç®—æŸä¸ªé¡¶ç‚¹çš„å‡ºåº¦
int outdegree(mgraph graph,char v){
    int index=-1;
    int count=0;
    //æŸ¥æ‰¾é¡¶ç‚¹våœ¨é¡¶ç‚¹è¡¨ä¸­çš„ç´¢å¼•
    for (int i = 0; i < graph.numvertex; i++)
    {
        if (graph.vertexlist[i]==v)
        {
            index=i;
            break;  
        }
        
    }
    //å¦‚æœæ²¡æœ‰æ‰¾åˆ°é¡¶ç‚¹vï¼Œè¿”å›-1è¡¨ç¤ºé”™è¯¯
    if (index==-1)
    {
        return -1;
    }
    //éå†é‚»æ¥çŸ©é˜µçš„è¯¥é¡¶ç‚¹å¯¹åº”çš„è¡Œï¼Œæ£€æŸ¥æ˜¯å¦æœ‰ä»è¯¥é¡¶ç‚¹å‡ºå‘çš„è¾¹
    for (int i = 0; i < graph.numvertex; i++)
    {
        if (graph.edges[index][i]!=0)
        {
            count++;
        }
        
    }
    return count;
    
}
```

#### å›¾çš„é‚»æ¥è¡¨å­˜å‚¨ç»“æ„ä½“

```c++
struct arcnode//è¾¹è¡¨èŠ‚ç‚¹
{
    int adjvex;//è¯¥å¼§æŒ‡å‘çš„é¡¶ç‚¹ä½ç½®
    arcnode* next;//æŒ‡å‘ä¸‹ä¸€æ¡å¼§çš„æŒ‡é’ˆ
};
struct vnode//é¡¶ç‚¹è¡¨ç»“ç‚¹
{
    char data;//é¡¶ç‚¹ä¿¡æ¯
    arcnode *first;//æŒ‡å‘ç¬¬ä¸€æ¡ä¾é™„è¯¥é¡¶ç‚¹çš„å¼§çš„æŒ‡é’ˆ
}*graph[10];//å®šä¹‰ä¸€ä¸ªæ‹¥æœ‰10ä¸ªé¡¶ç‚¹çš„å›¾ï¼ˆé‚»æ¥è¡¨æ³•ï¼‰
//ä¹¦ä¸Šå®šä¹‰æ–¹å¼
#define MAX 1000
struct arcnode//è¾¹è¡¨èŠ‚ç‚¹
{
    int adjvex;//è¯¥å¼§æŒ‡å‘çš„é¡¶ç‚¹ä½ç½®
    arcnode* next;//æŒ‡å‘ä¸‹ä¸€æ¡å¼§çš„æŒ‡é’ˆ
};
struct vnode//é¡¶ç‚¹è¡¨ç»“ç‚¹
{
    char data;//é¡¶ç‚¹ä¿¡æ¯
    arcnode *first;//æŒ‡å‘ç¬¬ä¸€æ¡ä¾é™„è¯¥é¡¶ç‚¹çš„å¼§çš„æŒ‡é’ˆ
};
struct graph
{
    int numvertex;
    int numedge;
    vnode vertex[MAX];  
};
//è®¡ç®—æŸä¸ªé¡¶ç‚¹çš„å…¥åº¦
int indegree(graph graph,char v){
    int index=-1;
    int count=0;
    //æ‰¾åˆ°våœ¨é¡ºåºè¡¨ä¸­çš„ä¸‹æ ‡
    for (int i = 0; i < graph.numvertex; i++)
    {
       if (graph.vertex[i].data==v)
       {
        index=i;
        break;
       }
       
    }
    //å¦‚æœæœªæ‰¾åˆ°é¡¶ç‚¹vï¼Œè¿”å›-1è¡¨ç¤ºé”™è¯¯
    if (index==-1)
    {
        return -1;

    }
    //éå†æ¯ä¸ªå•é“¾è¡¨ï¼Œæ‰¾åˆ°æŒ‡å‘vçš„è¾¹ï¼Œå¹¶è®¡æ•°
    for (int i = 0; i < graph.numvertex; i++)
    {
        arcnode*p=graph.vertex[i].first;
        while (p)
        {
            if(p->adjvex==index){
                count++;
            }
            p=p->next;
        }
        return count;
    }
    
}
//è®¡ç®—æŸä¸ªé¡¶ç‚¹çš„å‡ºåº¦
int outdegree(graph graph,char v){
    //æŸ¥æ‰¾é¡¶ç‚¹vå¯¹åº”çš„å‡ºåº¦
    for (int i = 0; i < graph.numvertex; i++)
    {
        if (graph.vertex[i].data==v)
        {
            int count =0;
            arcnode*p=graph.vertex[i].first;
            while (p)
            {
                count++;
                p=p->next;
            }
            return count;
        }
        
    }
    //å¦‚æœæŸ¥æ‰¾å¤±è´¥ï¼Œè¿”å›-1è¡¨ç¤ºè®¡ç®—å¤±è´¥
    return -1;
}

```

#### åå­—é“¾è¡¨å­˜å‚¨ç»“æ„

```c++
#define MAXV 1000
struct arcnode
{
    int tailvex;
    int headvex;
    arcnode* hlink,*tlink;
    int weight; 
};
struct vnode
{
    char data;
    arcnode * firstin,*firstout;
};
struct graph
{
    int numvertex;
    int numedge;
    vnode vertex[MAXV];
};




```

#### é‚»æ¥å¤šé‡è¡¨å­˜å‚¨ç»“æ„

```c++
#define MAXV 1000
struct arcnode
{
    int i,j;
    arcnode*ilink,*jlink;
};
struct vnode
{
    char data;
    arcnode* first;
};
struct graph
{
    int vertexnum;
    int edgenum;
    vnode vertex[MAXV];
};



```



#### åŸºäºBFS/DFSçš„æ‹“æ‰‘æ’åº

```c++
//BFS
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 100010, M = 100010;

int n, m;
struct Node
{
    int id;
    Node* next;
    Node(int _id): id(_id), next(NULL) {}
}*head[N];
int d[N], q[N];

void add(int a, int b)
{
    auto p = new Node(b);
    p->next = head[a];
    head[a] = p;
}

bool topsort()
{
    int hh = 0, tt = -1;
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (auto p = head[t]; p; p = p->next)
            if ( -- d[p->id] == 0)
                q[ ++ tt] = p->id;
    }

    return tt == n - 1;
}

int main()
{
    scanf("%d%d", &n, &m);
    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        d[b] ++ ;
        add(a, b);
    }

    if (!topsort()) puts("-1");
    else
    {
        for (int i = 0; i < n; i ++ )
            printf("%d ", q[i]);
    }

    return 0;
}
```

```c++
//DFS
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 100010, M = 100010;

int n, m;
struct Node
{
    int id;
    Node* next;
    Node(int _id): id(_id), next(NULL) {}
}*head[N];
int st[N], q[N], top;

void add(int a, int b)
{
    auto p = new Node(b);
    p->next = head[a];
    head[a] = p;
}

bool dfs(int u)
{
    st[u] = 1;

    for (auto p = head[u]; p; p = p->next)
    {
        int j = p->id;
        if (!st[j])
        {
            if (!dfs(j)) return false;
        }
        else if (st[j] == 1) return false;
    }

    q[top ++ ] = u;

    st[u] = 2;
    return true;
}

bool topsort()
{
    for (int i = 1; i <= n; i ++ )
        if (!st[i] && !dfs(i))
            return false;
    return true;
}

int main()
{
    scanf("%d%d", &n, &m);
    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
    }

    if (!topsort()) puts("-1");
    else
    {
        for (int i = n - 1; i >= 0; i -- )
            printf("%d ", q[i]);
    }

    return 0;
}
```

#### æœ´ç´ ç‰ˆprimç®—æ³•

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 510, M = 100010, INF = 0x3f3f3f3f;

int n, m;
int g[N][N], dist[N];
bool st[N];

int prim()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                 t = j;
        if (dist[t] == INF) return INF;
        st[t] = true;
        res += dist[t];
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], g[t][j]);
    }
    return res;
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(g, 0x3f, sizeof g);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        g[a][b] = g[b][a] = min(g[a][b], c);
    }

    int res = prim();
    if (res == INF) puts("impossible");
    else printf("%d\n", res);
    return 0;
}
```

#### kruskalç®—æ³•

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 510, M = 100010;

int n, m;
struct Edge
{
    int a, b, c;
    bool operator< (const Edge& t) const
    {
        return c < t.c;
    }
}e[M];
int p[N];

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < m; i ++ )
        scanf("%d%d%d", &e[i].a, &e[i].b, &e[i].c);
    sort(e, e + m);

    for (int i = 1; i <= n; i ++ ) p[i] = i;

    int res = 0, cnt = n;
    for (int i = 0; i < m; i ++ )
    {
        int a = e[i].a, b = e[i].b, c = e[i].c;
        if (find(a) != find(b))
        {
            res += c;
            cnt -- ;
            p[find(a)] = find(b);
        }
    }

    if (cnt > 1) puts("impossible");
    else printf("%d\n", res);

    return 0;
}

```

#### BFSç®—æ³•(é‚»æ¥çŸ©é˜µ)

```c++
#include <queue>
#include <iostream>
#define MAX 100
using namespace std;
struct graph
{
    int vertexnum;
    int edgenum;
    char vertexlist[MAX];
    int edge[MAX][MAX];
};
bool visited[MAX];
//å¯¹äºæ•°ç»„ä¸‹æ ‡ä¸ºvçš„é¡¶ç‚¹ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªå’Œä»–ç›¸é‚»çš„é¡¶ç‚¹ï¼Œå¹¶è¿”å›è¯¥é¡¶ç‚¹çš„æ•°ç»„ä¸‹æ ‡
int firstneighbor(graph G,int v){
    for (int i = 0; i < G.edgenum; i++)
    {
        if (G.edge[v][i])//å¦‚æœå­˜åœ¨è¾¹
        {
            return i;
        }
       
    
    }
      return-1;   
}
//å¯¹äºæ•°ç»„ä¸‹æ ‡ä¸ºvçš„é¡¶ç‚¹ï¼Œä»ä½ç½®wå¼€å§‹æŸ¥æ‰¾å’Œå®ƒç›¸é‚»çš„é¡¶ç‚¹ï¼Œå¹¶è¿”å›è¯¥ç‚¹çš„æ•°ç»„ä¸‹æ ‡
int nextneighbor(graph g,int v,int w){
    for(int i = w+1;i<g.vertexnum;i++){
        if (g.edge[v][i])
        {
            return i;
        }
        
    }
    return -1;
}
//å¹¿åº¦ä¼˜å…ˆéå†
void bfstraverse(graph g){
    for (int i = 0; i < g.vertexnum; i++)
    {
        visited[i]=0;//å°†è®¿é—®æ ‡è®°æ•°ç»„åˆå§‹åŒ–
    }
    for(int i = 0;i<g.vertexnum;i++){
        if(!visited[i])
            bfs(g,i);
    }
    
}
//ä»é¡¶ç‚¹vå‡ºå‘ï¼Œå¹¿åº¦ä¼˜å…ˆéå†å›¾G
void bfs(graph g,int v){
    queue<int>que;//è®¾ç½®ä¸€ä¸ªé˜Ÿåˆ—ï¼Œç”¨æ¥å­˜å‚¨é¡¶ç‚¹çš„ç´¢å¼•
    visit(g.vertexlist[v]);//è®¿é—®åˆå§‹é¡¶ç‚¹v
    visited[v]=1;
    que.push(v);//åˆå§‹é¡¶ç‚¹å…¥é˜Ÿ
    while (!que.empty())
    {
        int cur=que.front();//ç”¨curæ¥æ¥æ”¶é˜Ÿå¤´å¼¹å‡ºçš„é¡¶ç‚¹ç´¢å¼•
        que.pop();//é˜Ÿå¤´å…ƒç´ å‡ºé˜Ÿ
        //æ£€æµ‹å½“å‰é¡¶ç‚¹curçš„æ‰€æœ‰é‚»æ¥ç‚¹
        for(int w = firstneighbor(g,cur);w>=0;w=nextneighbor(g,cur,w)){
            if(!visited[w]){//wä¸ºå½“å‰é¡¶ç‚¹curçš„å°šæœªè®¿é—®è¿‡çš„é‚»æ¥é¡¶ç‚¹
                visit(g.vertexlist[w]);//è®¿é—®wé¡¶ç‚¹
                visited[w]=1;//æ ‡è®°è®¿é—®
                que.push(w);//è®¿é—®å®Œå°†å…¶å…¥é˜Ÿ

            }
        }
    }
    
}
//å®ä¾‹çš„visitå‡½æ•°ï¼Œå¯ä»¥æ ¹æ®éœ€è¦ä¿®æ”¹
void visit(char vertex){
    cout<<vertex<<" ";
}
```

#### BFSç®—æ³•ï¼ˆé‚»æ¥è¡¨ï¼‰

```c++
#include <queue>
#include <iostream>
#define MAX 100
using namespace std;
struct arcnode//è¾¹è¡¨èŠ‚ç‚¹
{
    int adjvex;//è¯¥å¼§æŒ‡å‘çš„é¡¶ç‚¹ä½ç½®
    arcnode* next;//æŒ‡å‘ä¸‹ä¸€æ¡å¼§çš„æŒ‡é’ˆ
};
struct vnode//é¡¶ç‚¹è¡¨ç»“ç‚¹
{
    char data;//é¡¶ç‚¹ä¿¡æ¯
    arcnode *first;//æŒ‡å‘ç¬¬ä¸€æ¡ä¾é™„è¯¥é¡¶ç‚¹çš„å¼§çš„æŒ‡é’ˆ
};
struct graph
{
    int numvertex;
    int numedge;
    vnode vertex[MAX];  
};
bool visited[MAX];
//å¹¿åº¦ä¼˜å…ˆéå†
void bfstraverse(graph g){
    for (int i = 0; i < g.numvertex; i++)
    {
        visited[i]=0;//å°†è®¿é—®æ ‡è®°æ•°ç»„åˆå§‹åŒ–
    }
    for(int i = 0;i<g.numvertex;i++){
        if(!visited[i])
            bfs(g,i);
    }
    
}
//ä»é¡¶ç‚¹vå‡ºå‘ï¼Œå¹¿åº¦ä¼˜å…ˆéå†å›¾G
void bfs(graph g,int v){
    queue<int>que;//è®¾ç½®ä¸€ä¸ªé˜Ÿåˆ—ï¼Œç”¨æ¥å­˜å‚¨é¡¶ç‚¹çš„ç´¢å¼•
    visit(g.vertex[v].data);//è®¿é—®åˆå§‹é¡¶ç‚¹v
    visited[v]=1;
    que.push(v);//åˆå§‹é¡¶ç‚¹å…¥é˜Ÿ
    while (!que.empty())
    {
        int cur=que.front();//ç”¨curæ¥æ¥æ”¶é˜Ÿå¤´å¼¹å‡ºçš„é¡¶ç‚¹ç´¢å¼•
        que.pop();//é˜Ÿå¤´å…ƒç´ å‡ºé˜Ÿ
       arcnode*p=g.vertex[cur].first;//è·å–å½“å‰é¡¶ç‚¹çš„æ¬¡ä¸€ä¸ªé‚»æ¥ç‚¹
       //éå†å½“å‰é¡¶ç‚¹curçš„æ‰€æœ‰é‚»æ¥ç‚¹
       while (p!=nullptr)
       {
        int adjindex=p->adjvex;//è·å–é‚»æ¥é¡¶ç‚¹çš„ç´¢å¼•
        if (!visited[adjindex])
        {
            visit(g.vertex[adjindex].data);//è®¿é—®é‚»æ¥é¡¶ç‚¹
            visited[adjindex]=1;
            que.push(adjindex);
        }
        p=p->next;
       }
       
    }
    
}
//å®ä¾‹çš„visitå‡½æ•°ï¼Œå¯ä»¥æ ¹æ®éœ€è¦ä¿®æ”¹
void visit(char vertex){
    cout<<vertex<<" ";
}
```

#### DFSç®—æ³•ï¼ˆé‚»æ¥çŸ©é˜µï¼‰

```c++
#include <iostream>
using namespace std;
#define maxv 100

struct graph
{
    int vertexnum;
    int edgenum;
    char vertex[maxv];
    int edge[maxv][maxv];
};
bool visited[maxv];
//å¯¹äºæ•°ç»„ä¸‹æ ‡ä¸ºvçš„é¡¶ç‚¹ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªå’Œä»–ç›¸é‚»çš„é¡¶ç‚¹ï¼Œå¹¶è¿”å›è¯¥é¡¶ç‚¹çš„æ•°ç»„ä¸‹æ ‡
int firstneighbor(graph G,int v){
    for (int i = 0; i < G.edgenum; i++)
    {
        if (G.edge[v][i])//å¦‚æœå­˜åœ¨è¾¹
        {
            return i;
        }
       
    
    }
      return-1;   
}
//å¯¹äºæ•°ç»„ä¸‹æ ‡ä¸ºvçš„é¡¶ç‚¹ï¼Œä»ä½ç½®wå¼€å§‹æŸ¥æ‰¾å’Œå®ƒç›¸é‚»çš„é¡¶ç‚¹ï¼Œå¹¶è¿”å›è¯¥ç‚¹çš„æ•°ç»„ä¸‹æ ‡
int nextneighbor(graph g,int v,int w){
    for(int i = w+1;i<g.vertexnum;i++){
        if (g.edge[v][i])
        {
            return i;
        }
        
    }
    return -1;
}
void dfstraverse(graph g){
    //åˆå§‹åŒ–è®¿é—®æ•°ç»„
    for (int  i = 0; i < g.vertexnum; i++)
    {
        visited[i]=0;
    }
    //å¯¹æ¯ä¸ªé¡¶ç‚¹è¿›è¡ŒDFSï¼Œé˜²æ­¢éè¿é€šå›¾æœªéå†å®Œå…¨
    for (int i = 0; i < g.vertexnum; i++)
    {
        if(!visited[i])
            dfs(g,i);
    }
    
    
}
void dfs(graph g,int v){
    visit(g.vertex[v]);//è®¿é—®é¡¶ç‚¹v
    visited[v]=1;
    //å¯¹é¡¶ç‚¹vçš„æ¯ä¸ªé‚»æ¥é¡¶ç‚¹è¿›è¡Œé€’å½’dfs
    for(int w=firstneighbor(g,v);w>=0;w=nextneighbor(g,v,w)){
        if(!visited[w]){
            dfs(g,w);
        }
    }
    
}
void visit(char vertex){
    cout<<vertex<<" ";
}


```

#### DFSç®—æ³•ï¼ˆé‚»æ¥è¡¨ï¼‰

```c++
#include <queue>
#include <iostream>
#define MAX 100
using namespace std;
struct arcnode//è¾¹è¡¨èŠ‚ç‚¹
{
    int adjvex;//è¯¥å¼§æŒ‡å‘çš„é¡¶ç‚¹ä½ç½®
    arcnode* next;//æŒ‡å‘ä¸‹ä¸€æ¡å¼§çš„æŒ‡é’ˆ
};
struct vnode//é¡¶ç‚¹è¡¨ç»“ç‚¹
{
    char data;//é¡¶ç‚¹ä¿¡æ¯
    arcnode *first;//æŒ‡å‘ç¬¬ä¸€æ¡ä¾é™„è¯¥é¡¶ç‚¹çš„å¼§çš„æŒ‡é’ˆ
};
struct graph
{
    int numvertex;
    int numedge;
    vnode vertex[MAX];  
};
bool visited[MAX];
//å¹¿åº¦ä¼˜å…ˆéå†
void dfstraverse(graph g){
    for (int i = 0; i < g.numvertex; i++)
    {
        visited[i]=0;//å°†è®¿é—®æ ‡è®°æ•°ç»„åˆå§‹åŒ–
    }
    for(int i = 0;i<g.numvertex;i++){
        if(!visited[i])
            dfs(g,i);
    }
    
}
//ä»é¡¶ç‚¹vå‡ºå‘ï¼Œå¹¿åº¦ä¼˜å…ˆéå†å›¾G
void dfs(graph g,int v){
    visit(g.vertex[v].data);//è®¿é—®åˆå§‹é¡¶ç‚¹v
    visited[v]=1;
   //éå†é¡¶ç‚¹vçš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹
   arcnode*p=g.vertex[v].first;
   while (p!=nullptr)
   {
    if(!visited[p->adjvex]){
        dfs(g,p->adjvex);
    }
    p=p->next;
   }
   
    
}
//å®ä¾‹çš„visitå‡½æ•°ï¼Œå¯ä»¥æ ¹æ®éœ€è¦ä¿®æ”¹
void visit(char vertex){
    cout<<vertex<<" ";
}
```

### æŸ¥æ‰¾

#### Hashè¡¨

* å­˜å‚¨ç»“æ„

  * å¼€æ”¾å¯»å€æ³•

  * æ‹‰é“¾æ³•

    ![](/img/001426.jpg)

* å­—ç¬¦ä¸²å“ˆå¸Œ

* ä½œç”¨ï¼šæŠŠä¸€ä¸ªæ¯”è¾ƒåºå¤§çš„ç©ºé—´ï¼ˆå€¼åŸŸï¼‰æ˜ å°„åˆ°æ¯”è¾ƒå°çš„ç©ºé—´ï¼Œæ˜ å°„åçš„å‡½æ•°å«åšå“ˆå¸Œå‡½æ•°

  * x %10^5 âˆˆ(0,10^5)
    * æ¨¡çš„æ•°ä¸€èˆ¬è¦å–æˆè´¨æ•°ï¼Œæ‰€ä»¥ä¸€èˆ¬è¦éå†å¯»æ‰¾æœ€å°çš„è´¨æ•°
  * å†²çªï¼šä¸¤ä¸ªä¸ä¸€æ ·çš„æ•°æ˜ å°„æˆäº†åŒä¸€ä¸ªæ•°ï¼Œå¤„ç†å†²çªçš„æ–¹å¼å¯ä»¥åˆ†ä¸ºå¼€æ”¾å¯»å€æ³•å’Œæ‹‰é“¾æ³•

##### æ‹‰é“¾æ³•

```c++
(1) æ‹‰é“¾æ³•
    int h[N], e[N], ne[N], idx;//h[N]æ˜¯æ§½ï¼Œe[N]ï¼ˆå€¼ï¼‰ã€ne[N]ï¼ˆä¸‹ä¸€ä¸ªä½ç½®ï¼‰æ˜¯é“¾è¡¨
//memset(h,-1,sizeof h)æŠŠæ§½å…ˆæ¸…ç©º
    // å‘å“ˆå¸Œè¡¨ä¸­æ’å…¥ä¸€ä¸ªæ•°
    void insert(int x)
    {
        int k = (x % N + N) % N;//æŠŠä½™æ•°å˜æˆæ­£æ•°ï¼Œkå°±æ˜¯xçš„å“ˆå¸Œå€¼ï¼Œå°†xæ’åˆ°kæ§½çš„å•é“¾è¡¨ä¸­
        e[idx] = x;//å­˜ä¸‹xçš„å€¼
        ne[idx] = h[k];
        h[k] = idx ++ ;//é“¾è¡¨æ’å…¥æ“ä½œ
    }

    // åœ¨å“ˆå¸Œè¡¨ä¸­æŸ¥è¯¢æŸä¸ªæ•°æ˜¯å¦å­˜åœ¨
    bool find(int x)
    {
        int k = (x % N + N) % N;//æ±‚å‡ºå“ˆå¸Œå€¼å®šä½æ§½ä½ç½®
        for (int i = h[k]; i != -1; i = ne[i])//éå†å•é“¾è¡¨
            if (e[i] == x)//åˆ¤æ–­è¯¥æ§½é“¾è¡¨ä¸­æ˜¯å¦å­˜åœ¨x
                return true;

        return false;
    }
```

```
//å¯»æ‰¾è´¨æ•°
for(int i =  ; ;i++){
bool flag =true;
for(int j = 2;j*j<=i;j++)
	if(i%j==0){
	flag =false ;
	break;
	}
	if(flag)
	{
	cout<<i<<endl
	break;
	}
}
```



##### å¼€æ”¾å¯»å€æ³•

* åªå¼€ä¸€ä¸ªæ•°ç»„ï¼Œä½†æ˜¯å¼€çš„é•¿åº¦ä¸€èˆ¬æ˜¯è¾“å…¥æ•°æ®çš„2-3å€

```c++
(2) å¼€æ”¾å¯»å€æ³•
    int h[N];
//éœ€è¦å®šä¹‰ä¸€ä¸ªä¸åœ¨æ•°æ®èŒƒå›´å†…çš„nullï¼Œå¦‚0x3f3f3f3fï¼Œä¸€èˆ¬è®¾ç½®æœ€å¤§å€¼,INT_MAXä¹Ÿè¿˜æ˜¯0x3f3f3f3f

memset(h,0x3f,sizeof h);//åˆå§‹åŒ–å“ˆå¸Œè¡¨
    //ç”±äºxæ˜¯intç±»å‹ï¼Œä¸€ä¸ªintå››ä¸ªå­—èŠ‚ï¼Œç›¸å½“äº4ä¸ª3fï¼Œå³0x3f3f3f3f

// å¦‚æœxåœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œè¿”å›xçš„ä¸‹æ ‡ï¼›å¦‚æœxä¸åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œè¿”å›xåº”è¯¥æ’å…¥çš„ä½ç½®
    int find(int x)
    {
        int t = (x % N + N) % N;//æ±‚å“ˆå¸Œå€¼ï¼Œå³æ˜ å°„
        while (h[t] != null && h[t] != x)//tä½ç½®ä¸Šé¢æœ‰äººï¼Œå¹¶ä¸”ä½ç½®ä¸Šçš„å€¼ä¸ç­‰äºx
        {
            t ++ ;//çœ‹ä¸‹ä¸€ä¸ªä½ç½®
            if (t == N) t = 0;//çœ‹å®Œäº†æœ€åä¸€ä¸ªä½ç½®ï¼Œéœ€è¦å¾ªç¯çœ‹ç¬¬ä¸€ä¸ªä½ç½®
        }
        return t;//å¦‚æœxåœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œè¿”å›çš„å°±æ˜¯xçš„ä¸‹æ ‡ï¼Œå¦‚æœxä¸åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œè¿”å›çš„å°±æ˜¯xåº”è¯¥æ’å…¥çš„ä½ç½®
    }

//æ’å…¥ä¸€ä¸ªæ•°å­—
h[find(x)]=x;
//åˆ¤æ–­æ•°å­—æ˜¯å¦åœ¨å“ˆå¸Œè¡¨ä¸­
if(h[find(x)])== null cout<<"No";
else cout<<"Yes";
```

##### å­—ç¬¦ä¸²å“ˆå¸Œ

å­—ç¬¦ä¸²å‰ç¼€å“ˆå¸Œæ³•

* å…ˆé¢„å¤„ç†å‡ºæ‰€æœ‰å‰ç¼€çš„å“ˆå¸Œ

  ![](/img/005400.jpg)

  æŠŠå­—ç¬¦ä¸²çœ‹æˆæ˜¯pè¿›åˆ¶çš„æ•°å­—ï¼Œæ¯ä¸€ä½ä¸Šçš„å­—æ¯å°±è¡¨ç¤ºpè¿›åˆ¶ä¸Šçš„æ¯ä¸€ä½æ•°å­—ï¼Œç„¶åå†å–æ¨¡ï¼Œå°±å¯ä»¥æŠŠå­—ç¬¦ä¸²æ˜ å°„åˆ°ä»0åˆ°Q-1

  ![](/img/010031.jpg)

* A-Zä¸èƒ½æ˜ å°„æˆ0ï¼Œä¸€èˆ¬ä»1å¼€å§‹

* å­—ç¬¦ä¸²å“ˆå¸Œå‡å®šä¸å­˜åœ¨å†²çªï¼Œå› æ­¤ä¸è€ƒè™‘å†²çª

* å¥½å¤„æ˜¯å¯ä»¥åˆ©ç”¨å‰ç¼€å“ˆå¸Œç®—å‡ºæ¥ä»»æ„ä¸€ä¸ªå­ä¸²çš„å“ˆå¸Œå€¼

* ä½œç”¨ï¼š

  å¿«é€Ÿåˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸åŒï¼Œå“ˆå¸Œå€¼ç›¸åŒï¼Œä¸¤ä¸ªå­—ç¬¦ä¸²ç›¸åŒï¼Œå¦‚æœå“ˆå¸Œå€¼ä¸åŒï¼Œåˆ™ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸åŒ

```c++
æ ¸å¿ƒæ€æƒ³ï¼šå°†å­—ç¬¦ä¸²çœ‹æˆPè¿›åˆ¶æ•°ï¼ŒPçš„ç»éªŒå€¼æ˜¯131æˆ–13331ï¼Œå–è¿™ä¸¤ä¸ªå€¼çš„å†²çªæ¦‚ç‡ä½
å°æŠ€å·§ï¼šå–æ¨¡çš„æ•°ç”¨2^64ï¼Œè¿™æ ·ç›´æ¥ç”¨unsigned long longå­˜å‚¨ï¼Œæº¢å‡ºçš„ç»“æœå°±æ˜¯å–æ¨¡çš„ç»“æœ

typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k]å­˜å‚¨å­—ç¬¦ä¸²å‰kä¸ªå­—æ¯çš„å“ˆå¸Œå€¼, p[k]å­˜å‚¨ P^k mod 2^64
const int P=131 or 13331 //Pè¿›åˆ¶
// åˆå§‹åŒ–
p[0] = 1;//pçš„é›¶æ¬¡æ–¹ç­‰äº1
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;//ä½æ•°å¯¹åº”çš„æ•°å­—ï¼Œç±»ä¼¼äº024816
}

// è®¡ç®—å­ä¸² str[l ~ r] çš„å“ˆå¸Œå€¼
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
```

### 

### 408ä¸­c++stlå¯ç”¨çš„æƒ…å†µ

#### æ ˆ

```c++
stack<int>stk;
stk.push();
stk.pop();
int top=stk.top();
int size=stk.size();
bool empty=stk.empty();

```

#### é˜Ÿåˆ—

```c++
#inlude <queue>
queue<int> q;
q.push();
q.pop();
int a =q.front();//
int b= q.back();
int c=q.size();
#include <deque>
```

