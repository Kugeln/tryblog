---
title: 数据结构算法笔试
date: 2025-04-02 18:55:05
tags: 408日常
sticky: 259
banner_img: /img/1920x1080 (16).jpg
index_img: /img/1920x1080 (16).jpg
math: true
---

# 如何备考数据结构大题

![](/img/205513.jpg)

![](/img/cweqjcewq.png)

![](/img/qweewqc.png)

![](/img/weqcwqtvqee.png)

* 数据结构的小题最好的复习方法是把王道书的课后习题二刷
* 多做题少听课
* 主动发现自己不足的地方，去查缺补漏而不是遍历课本

## 大题的题型

![](/img/205610.jpg)

* 应用题侧重于算法的逻辑而不是算法代码的实现
* 大纲里面应用相关即大题要考的考点
* 应用题备考思路：
  * 画数据结构和算法运行过程
  * 训练数据结构定义的简单代码
  * 基本操作的简单代码

## 八大考点

![](/img/05710.jpg)

### ①线性表的应用

### ②栈的应用

### ③队列的应用

### ④数组的应用

### ⑤树与二叉树的应用

* 二叉树基本考的就是哈夫曼树和哈夫曼编码，并查集及其应用。其他的题型通常是定义数据结构或者实现基本操作

### ⑥图的基本应用

* 比较基本的应用
* 应用题一般不用写代码但是要手算，能够懂这些算法运行的逻辑

#### 最小（代价）生成树

* 最小生成树考察的是一个图中包含多个点的总路线代价最短
  * 而单源最短路径只考虑两点之间最短距离的路径

#### 最短路径

#### 拓扑排序

#### 关键路径

#### 其他

* 数据结构定义
* 画图

### ⑦查找算法的分析及应用

* 二叉搜索树、平衡二叉树和红黑树可能和树与二叉树考点进行比较深度的结合
  * 比如给出一个关键字序列，从一个空的二叉树开始插入这些关键字，然后画出插入以后的平衡二叉树的形态，同时给出这个平衡二叉树的数据结构定义
  * 大概率应用题而不是代码
  * 尤其是平衡二叉树和红黑树

* 散列（哈希）表
  * 大概率应用题而不是代码
* B树及其基本操作
  * 不太可能在应用题当中考察，只考基本概念，不用管基本操作，b树小题里面一般可能考
* 分块查找
  * 应用题
* 字符串模式匹配
  * 大概率应用题而不是代码
* 查找算法的性能分析，分析平均查找长度，成功的ASL和失败的ASL

### ⑧排序算法的分析及应用

* 希尔排序
  * 更容易考小题而不是应用题
* 堆排序
* 基数排序
* 外部排序

## 七大考法

![](/img/205729.jpg)

### ①画图作答

* （1）画数据结构的状态示意图
  * 重中之重
  * 一般是考察比较复杂的数据结构的图示

### ②代码作答

* （1）写数据结构定义、基本操作代码
  * 简单的代码
  * 基本操作/功能的代码片段，比如判断队空或者插入
  * 比较复杂的数据结构不会考很复杂的算法题，但可能考数据结构的代码定义以及基本操作的代码实现

### ③文字简答

* （1）手算分析算法运行过程/结果
* （2）数据结构、算法的选择
  * 基于应用场景选择一种合适的数据结构
  * 基于应用场景选择一种性能比较好的算法
* （3）算法性质分析
  * 分析算法的时间复杂度和空间复杂度
    * 所有算法都有可能考
  * 查找算法
    * 分析平均查找长度
    * 成功ASL和失败ASL
  * 排序算法
    * 分析关键字的对比次数
      * 某一趟排序当中关键字的对比次数是多少
      * 排完序关键字的总对比次数是多少
    * 稳定性
* （4）文字描述算法思想/过程
  * 可以通过示意图去解释算法的运行过程，用文字描述也可以解和画图去做
  * 将画数据结构的状态示意图和手算分析算法运行过程/结果结合起来，从这两个角度去把各个算法的运行过程和数据结构的示意图捋清楚
* （5）数据结构性质推演
  * 树和图的性质推演
    * 主要根据王道书的课后小题来复习

# 应用题

![](/img/191649.jpg)

* 先找到题目中的线索，然后遍历一下这类问题的做法

## 排序类应用题

![](/img/170219.jpg)

![](/img/171218.jpg)

![](/img/74000.jpg)

![](/img/174043.jpg)

* 插入类排序：直接插入排序、折半插入排序、希尔排序
  * 能够保证相对升序的序列（有可能是跳跃的，也有可能是前面的i+1个
* 选择类排序：简单选择排序、堆排序
  * 堆排序：（大根堆）每次选择堆顶元素放在最后（和堆底元素交换），每次将最大的元素放在最后面
    * 第一趟排序是建堆完之后再把它那个最大的元素换到最后面的结果
  * 每次都有一个元素被放在最终位置
* 交换类排序：冒泡排序、快速排序
  * 每次根据逆序对进行交换
  * 快速排序：
    * 枢值一般选取序列的第一个元素
* 不稳定排序算法的特点
  * 对于一种排序算法，我们要交换前两个位置的时候，如果它看不到前面有一个和他相同的元素，就有可能出现不稳定

## 查找类应用题

![](/img/205833.jpg)

* 折半查找
  * 元素有序，顺序表
* 散列查找查找失败的情况
  * 线性探测法，查找到空位的时候说明查找失败，比较空的数组元素会计入一次比较次数
  * 链地址法，比较到一个空指针的位置才是查找失败，但是该比较空指针不会算进比较次数
  * 装填因子在链地址法中可以大于1，但是存储效率一定是小于等于100%的
  * 查找成功的时候分母是元素数量，查找失败的时候分母是取模后面的那个数字（因为无法映射到其他更大的数字）

![](/img/2213835.jpg)

* 链式存储，考虑二叉搜索树
* 顺序存储，顺序查找和折半查找（注意排序）比较常见

## 树类应用题

## 图类应用题

## 线性表类应用题

# 算法题

![](/img/fhiwqiyehfih.png)

![](/img/defewfqf.png)

![](/img/hntedehb.png)

* 算法题
  * 一题多解，分数高中低三档
  * 可以先写第二小问再写第一小问
  * 顺序表和链表一般情况下要考察时间复杂度
  * 树和图一般不考时间复杂度和空间复杂度，分析要求低一点，但依旧要记得
    * 树和图能解决问题比高效解决问题最重要，只要能解决问题笨方法也可以，只要能掌握常规代码即可
* 备考方法
  * 阶段一：完成历年真题
  * 阶段二：分模块训练
  * 阶段三：少食多餐，增加做题量
  * 阶段四：考前保持手感，再刷历年真题

## 排序

### 顺序表

* 快排和堆排是所有排序算法中效率最高的，但是快排代码简单，堆排代码复杂，所以快排最优

* 考试按照时间复杂度给分

* 套路型算法：

  * 快速排序
    * 能快排就快排，不能用快排的再考虑用其他排序
    * 快排只能在顺序表和数组（静态链表）中使用，链表当中不能用快排，因此当涉及顺序表（数组）的题目，考虑能否使用到快速排序。
    * 如果题目中给的是一个乱序数组的话，如果把这个乱序数组变成有序，我们用快排的套路，先把它变成有序，能否更加轻松的解决这个问题，从这个角度思考
    * 时间复杂度O(nlogn)

  ```c++
  void quick_sort(int q[], int l, int r)
  {
  if (l >= r) return;
  int i = l - 1, j = r + 1, x = q[l + r >> 1];
   while (i < j)
     {
          do i ++ ; while (q[i] < x);
          do j -- ; while (q[j] > x);
          if (i < j) swap(q[i], q[j]);
     }
      quick_sort(q, l, j), quick_sort(q, j + 1, r);
  }
  ```

  

  * 归并排序
    * 时间复杂度O(nlogn)
    * 如果我们在考题当中遇到排序类的题目，要求把一个乱序的数组排成一个更大的数组，如果这个数组本身部分有序，那么我们采用归并排序比快速排序更加优秀

  ```c++
  void merge_sort(int q[], int l, int r)
  {
      if (l >= r) return;
  
      int mid = l + r >> 1;
      merge_sort(q, l, mid);
      merge_sort(q, mid + 1, r);
  
      int k = 0, i = l, j = mid + 1;
      while (i <= mid && j <= r)
          if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
          else tmp[k ++ ] = q[j ++ ];
  
      while (i <= mid) tmp[k ++ ] = q[i ++ ];
      while (j <= r) tmp[k ++ ] = q[j ++ ];
  
      for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
  
  }
  ```

  

  * 快速排序更擅长将一个原本乱序的数组排成有序
    * 二路归并排序更擅长将两个原本有序的数组合并为一个，时间复杂度仅为O(n)
    * 通常来说，对乱序数组的排序，用归并不如用快排
    * 如果题目中给的是两个有序表，并且需要将两个有序表合并为一个，可以考虑用归并思想

### 链表

* 不支持随机访问，算法较少
* 考察偏向于考基本功
  * 按位序查找
  * 按关键字条件查找+删除某个节点
  * 按关键字条件查找+插入某个节点
  * 头插法（可实现原地逆置）
  * 尾插法（保持原序）

## 树

* 掌握前中后序遍历、层序遍历、递归算法
  * 非递归算法不用掌握
  * 基于这些算法解决思维导图中列出的问题，然后做一下王道书的剩余算法题

## 图

* 数据结构层面
  * 邻接矩阵和邻接表的遍历
  * 邻接多重表和十字链表的定义

* 算法备考

  * DFS，BFS

  ```c++
  bool st[N];
  int dfs(int u)
  {
      st[u] = true; // st[u] 表示点u已经被遍历过
  
      for (int i = h[u]; i != -1; i = ne[i])//遍历点的边
      {
          int j = e[i];//存储当前链表节点对应的图里面的点的编号
          if (!st[j]) dfs(j);//j没有被搜到，继续搜
      }
  }
  ```

  ```c++
  queue<int> q;//初始化
  st[1] = true; // 表示1号点已经被遍历过
  q.push(1);
  
  while (q.size())//队列不空
  {
      int t = q.front();
      q.pop();
  
      for (int i = h[t]; i != -1; i = ne[i])
      {
          int j = e[i];
          if (!st[j])
          {
              st[j] = true; // 表示点j已经被遍历过
              q.push(j);
          }
      }
  }
  
  int bfs()
  {
  	int hh =0,tt=0;//定义队头队尾
      q[0]=1;//q的第一个元素起点
      memset(d,-1,sizeof d);//初始化距离，-1表示没有被遍历过
      d[1]=0;//第一个点遍历
      while(hh<=tt){//队列不空
          int t=q[hh++]//取到队头
              for(int i = h[t];i!=-1;i=e[i])//拓展队头
              {
                  int j =e[i];//拓展到队头连接的下一个点
                 if(d[j]==-1)//d[j]没有被拓展过
                 {
                     d[j]=d[t]+1;
                     q[++tt]=j;
                 }
              }
      }
      return 0;
  }
  ```

  

  * 拓扑排序

  ```c++
  int n,m;
  int h[N],e[N],ne[N],idx;
  int d[N],q[N];//d[n]表示入度，q[n]是拓扑序列
  void add(int a,int b){
      e[idx] = b;
      ne[idx] = h[a];
      h[a]=idx++;
      
  }
  bool topsort()
  {
      int hh = 0, tt = -1;
  
      // d[i] 存储点i的入度
      for (int i = 1; i <= n; i ++ )
          if (!d[i])
              q[ ++ tt] = i;//数组模拟入队
  
      while (hh <= tt)//队列不空
      {
          int t = q[hh ++ ];//取出来队头
  
          for (int i = h[t]; i != -1; i = ne[i])//枚举t的所有出边t->j，删掉t->j
          {
              int j = e[i];//找到出边
             d[j]--;
              if ( d[j] == 0)//前面的所有点都已经排好了
                  q[ ++ tt] = j;//j入队
           
          }
      }
  
      // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
      return tt == n - 1;
  }
  //出队的顺序就是拓扑序
  ```

  

